!function(g){var I=window.webpackHotUpdate;window.webpackHotUpdate=function(g,n){!function(g,I){if(!u[g]||!o[g])return;for(var n in o[g]=!1,I)Object.prototype.hasOwnProperty.call(I,n)&&(Q[n]=I[n]);0==--s&&0===F&&X()}(g,n),I&&I(g,n)};var n,t=!0,e="c5e03a1395526b778ffb",B=1e4,c={},l=[],C=[];function a(g){var I=p[g];if(!I)return y;var t=function(t){return I.hot.active?(p[t]?-1===p[t].parents.indexOf(g)&&p[t].parents.push(g):(l=[g],n=t),-1===I.children.indexOf(t)&&I.children.push(t)):(console.warn("[HMR] unexpected require("+t+") from disposed module "+g),l=[]),y(t)},e=function(g){return{configurable:!0,enumerable:!0,get:function(){return y[g]},set:function(I){y[g]=I}}};for(var B in y)Object.prototype.hasOwnProperty.call(y,B)&&"e"!==B&&"t"!==B&&Object.defineProperty(t,B,e(B));return t.e=function(g){return"ready"===G&&d("prepare"),F++,y.e(g).then(I,function(g){throw I(),g});function I(){F--,"prepare"===G&&(r[g]||Z(g),0===F&&0===s&&X())}},t.t=function(g,I){return 1&I&&(g=t(g)),y.t(g,-2&I)},t}var i=[],G="idle";function d(g){G=g;for(var I=0;I<i.length;I++)i[I].call(null,g)}var b,Q,A,s=0,F=0,r={},o={},u={};function m(g){return+g+""===g?+g:g}function U(g){if("idle"!==G)throw new Error("check() is only allowed in idle status");return t=g,d("check"),(I=B,I=I||1e4,new Promise(function(g,n){if("undefined"==typeof XMLHttpRequest)return n(new Error("No browser support"));try{var t=new XMLHttpRequest,B=y.p+""+e+".hot-update.json";t.open("GET",B,!0),t.timeout=I,t.send(null)}catch(g){return n(g)}t.onreadystatechange=function(){if(4===t.readyState)if(0===t.status)n(new Error("Manifest request to "+B+" timed out."));else if(404===t.status)g();else if(200!==t.status&&304!==t.status)n(new Error("Manifest request to "+B+" failed."));else{try{var I=JSON.parse(t.responseText)}catch(g){return void n(g)}g(I)}}})).then(function(g){if(!g)return d("idle"),null;o={},r={},u=g.c,A=g.h,d("prepare");var I=new Promise(function(g,I){b={resolve:g,reject:I}});Q={};return Z("main"),"prepare"===G&&0===F&&0===s&&X(),I});var I}function Z(g){u[g]?(o[g]=!0,s++,function(g){var I=document.getElementsByTagName("head")[0],n=document.createElement("script");n.charset="utf-8",n.src=y.p+""+g+"."+e+".hot-update.js",I.appendChild(n)}(g)):r[g]=!0}function X(){d("ready");var g=b;if(b=null,g)if(t)Promise.resolve().then(function(){return h(t)}).then(function(I){g.resolve(I)},function(I){g.reject(I)});else{var I=[];for(var n in Q)Object.prototype.hasOwnProperty.call(Q,n)&&I.push(m(n));g.resolve(I)}}function h(I){if("ready"!==G)throw new Error("apply() is only allowed in ready status");var n,t,B,C,a;function i(g){for(var I=[g],n={},t=I.slice().map(function(g){return{chain:[g],id:g}});t.length>0;){var e=t.pop(),B=e.id,c=e.chain;if((C=p[B])&&!C.hot._selfAccepted){if(C.hot._selfDeclined)return{type:"self-declined",chain:c,moduleId:B};if(C.hot._main)return{type:"unaccepted",chain:c,moduleId:B};for(var l=0;l<C.parents.length;l++){var a=C.parents[l],i=p[a];if(i){if(i.hot._declinedDependencies[B])return{type:"declined",chain:c.concat([a]),moduleId:B,parentId:a};-1===I.indexOf(a)&&(i.hot._acceptedDependencies[B]?(n[a]||(n[a]=[]),b(n[a],[B])):(delete n[a],I.push(a),t.push({chain:c.concat([a]),id:a})))}}}}return{type:"accepted",moduleId:g,outdatedModules:I,outdatedDependencies:n}}function b(g,I){for(var n=0;n<I.length;n++){var t=I[n];-1===g.indexOf(t)&&g.push(t)}}I=I||{};var s={},F=[],r={},o=function(){console.warn("[HMR] unexpected require("+Z.moduleId+") to disposed module")};for(var U in Q)if(Object.prototype.hasOwnProperty.call(Q,U)){var Z;a=m(U);var X=!1,h=!1,V=!1,W="";switch((Z=Q[U]?i(a):{type:"disposed",moduleId:U}).chain&&(W="\nUpdate propagation: "+Z.chain.join(" -> ")),Z.type){case"self-declined":I.onDeclined&&I.onDeclined(Z),I.ignoreDeclined||(X=new Error("Aborted because of self decline: "+Z.moduleId+W));break;case"declined":I.onDeclined&&I.onDeclined(Z),I.ignoreDeclined||(X=new Error("Aborted because of declined dependency: "+Z.moduleId+" in "+Z.parentId+W));break;case"unaccepted":I.onUnaccepted&&I.onUnaccepted(Z),I.ignoreUnaccepted||(X=new Error("Aborted because "+a+" is not accepted"+W));break;case"accepted":I.onAccepted&&I.onAccepted(Z),h=!0;break;case"disposed":I.onDisposed&&I.onDisposed(Z),V=!0;break;default:throw new Error("Unexception type "+Z.type)}if(X)return d("abort"),Promise.reject(X);if(h)for(a in r[a]=Q[a],b(F,Z.outdatedModules),Z.outdatedDependencies)Object.prototype.hasOwnProperty.call(Z.outdatedDependencies,a)&&(s[a]||(s[a]=[]),b(s[a],Z.outdatedDependencies[a]));V&&(b(F,[Z.moduleId]),r[a]=o)}var x,H=[];for(t=0;t<F.length;t++)a=F[t],p[a]&&p[a].hot._selfAccepted&&H.push({module:a,errorHandler:p[a].hot._selfAccepted});d("dispose"),Object.keys(u).forEach(function(g){!1===u[g]&&function(g){delete installedChunks[g]}(g)});for(var R,N,Y=F.slice();Y.length>0;)if(a=Y.pop(),C=p[a]){var S={},v=C.hot._disposeHandlers;for(B=0;B<v.length;B++)(n=v[B])(S);for(c[a]=S,C.hot.active=!1,delete p[a],delete s[a],B=0;B<C.children.length;B++){var E=p[C.children[B]];E&&((x=E.parents.indexOf(a))>=0&&E.parents.splice(x,1))}}for(a in s)if(Object.prototype.hasOwnProperty.call(s,a)&&(C=p[a]))for(N=s[a],B=0;B<N.length;B++)R=N[B],(x=C.children.indexOf(R))>=0&&C.children.splice(x,1);for(a in d("apply"),e=A,r)Object.prototype.hasOwnProperty.call(r,a)&&(g[a]=r[a]);var O=null;for(a in s)if(Object.prototype.hasOwnProperty.call(s,a)&&(C=p[a])){N=s[a];var T=[];for(t=0;t<N.length;t++)if(R=N[t],n=C.hot._acceptedDependencies[R]){if(-1!==T.indexOf(n))continue;T.push(n)}for(t=0;t<T.length;t++){n=T[t];try{n(N)}catch(g){I.onErrored&&I.onErrored({type:"accept-errored",moduleId:a,dependencyId:N[t],error:g}),I.ignoreErrored||O||(O=g)}}}for(t=0;t<H.length;t++){var J=H[t];a=J.module,l=[a];try{y(a)}catch(g){if("function"==typeof J.errorHandler)try{J.errorHandler(g)}catch(n){I.onErrored&&I.onErrored({type:"self-accept-error-handler-errored",moduleId:a,error:n,originalError:g}),I.ignoreErrored||O||(O=n),O||(O=g)}else I.onErrored&&I.onErrored({type:"self-accept-errored",moduleId:a,error:g}),I.ignoreErrored||O||(O=g)}}return O?(d("fail"),Promise.reject(O)):(d("idle"),new Promise(function(g){g(F)}))}var p={};function y(I){if(p[I])return p[I].exports;var t=p[I]={i:I,l:!1,exports:{},hot:function(g){var I={_acceptedDependencies:{},_declinedDependencies:{},_selfAccepted:!1,_selfDeclined:!1,_disposeHandlers:[],_main:n!==g,active:!0,accept:function(g,n){if(void 0===g)I._selfAccepted=!0;else if("function"==typeof g)I._selfAccepted=g;else if("object"==typeof g)for(var t=0;t<g.length;t++)I._acceptedDependencies[g[t]]=n||function(){};else I._acceptedDependencies[g]=n||function(){}},decline:function(g){if(void 0===g)I._selfDeclined=!0;else if("object"==typeof g)for(var n=0;n<g.length;n++)I._declinedDependencies[g[n]]=!0;else I._declinedDependencies[g]=!0},dispose:function(g){I._disposeHandlers.push(g)},addDisposeHandler:function(g){I._disposeHandlers.push(g)},removeDisposeHandler:function(g){var n=I._disposeHandlers.indexOf(g);n>=0&&I._disposeHandlers.splice(n,1)},check:U,apply:h,status:function(g){if(!g)return G;i.push(g)},addStatusHandler:function(g){i.push(g)},removeStatusHandler:function(g){var I=i.indexOf(g);I>=0&&i.splice(I,1)},data:c[g]};return n=void 0,I}(I),parents:(C=l,l=[],C),children:[]};return g[I].call(t.exports,t,t.exports,a(I)),t.l=!0,t.exports}y.m=g,y.c=p,y.d=function(g,I,n){y.o(g,I)||Object.defineProperty(g,I,{enumerable:!0,get:n})},y.r=function(g){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(g,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(g,"__esModule",{value:!0})},y.t=function(g,I){if(1&I&&(g=y(g)),8&I)return g;if(4&I&&"object"==typeof g&&g&&g.__esModule)return g;var n=Object.create(null);if(y.r(n),Object.defineProperty(n,"default",{enumerable:!0,value:g}),2&I&&"string"!=typeof g)for(var t in g)y.d(n,t,function(I){return g[I]}.bind(null,t));return n},y.n=function(g){var I=g&&g.__esModule?function(){return g.default}:function(){return g};return y.d(I,"a",I),I},y.o=function(g,I){return Object.prototype.hasOwnProperty.call(g,I)},y.p="/dist/",y.h=function(){return e},a("./src/index.js")(y.s="./src/index.js")}({"./node_modules/riot/riot.js":
/*!***********************************!*\
  !*** ./node_modules/riot/riot.js ***!
  \***********************************/
/*! no static exports found */function(module,exports,__webpack_require__){eval("/* Riot v3.10.2, @license MIT */\n(function (global, factory) {\n   true ? factory(exports) :\n  undefined;\n}(this, (function (exports) { 'use strict';\n\n  /**\n   * Shorter and fast way to select a single node in the DOM\n   * @param   { String } selector - unique dom selector\n   * @param   { Object } ctx - DOM node where the target of our search will is located\n   * @returns { Object } dom node found\n   */\n  function $(selector, ctx) {\n    return (ctx || document).querySelector(selector)\n  }\n\n  var\n    // be aware, internal usage\n    // ATTENTION: prefix the global dynamic variables with `__`\n    // tags instances cache\n    __TAGS_CACHE = [],\n    // tags implementation cache\n    __TAG_IMPL = {},\n    YIELD_TAG = 'yield',\n\n    /**\n     * Const\n     */\n    GLOBAL_MIXIN = '__global_mixin',\n\n    // riot specific prefixes or attributes\n    ATTRS_PREFIX = 'riot-',\n\n    // Riot Directives\n    REF_DIRECTIVES = ['ref', 'data-ref'],\n    IS_DIRECTIVE = 'data-is',\n    CONDITIONAL_DIRECTIVE = 'if',\n    LOOP_DIRECTIVE = 'each',\n    LOOP_NO_REORDER_DIRECTIVE = 'no-reorder',\n    SHOW_DIRECTIVE = 'show',\n    HIDE_DIRECTIVE = 'hide',\n    KEY_DIRECTIVE = 'key',\n    RIOT_EVENTS_KEY = '__riot-events__',\n\n    // for typeof == '' comparisons\n    T_STRING = 'string',\n    T_OBJECT = 'object',\n    T_UNDEF  = 'undefined',\n    T_FUNCTION = 'function',\n\n    XLINK_NS = 'http://www.w3.org/1999/xlink',\n    SVG_NS = 'http://www.w3.org/2000/svg',\n    XLINK_REGEX = /^xlink:(\\w+)/,\n\n    WIN = typeof window === T_UNDEF ? /* istanbul ignore next */ undefined : window,\n\n    // special native tags that cannot be treated like the others\n    RE_SPECIAL_TAGS = /^(?:t(?:body|head|foot|[rhd])|caption|col(?:group)?|opt(?:ion|group))$/,\n    RE_SPECIAL_TAGS_NO_OPTION = /^(?:t(?:body|head|foot|[rhd])|caption|col(?:group)?)$/,\n    RE_EVENTS_PREFIX = /^on/,\n    RE_HTML_ATTRS = /([-\\w]+) ?= ?(?:\"([^\"]*)|'([^']*)|({[^}]*}))/g,\n    // some DOM attributes must be normalized\n    CASE_SENSITIVE_ATTRIBUTES = {\n      'viewbox': 'viewBox',\n      'preserveaspectratio': 'preserveAspectRatio'\n    },\n    /**\n     * Matches boolean HTML attributes in the riot tag definition.\n     * With a long list like this, a regex is faster than `[].indexOf` in most browsers.\n     * @const {RegExp}\n     * @see [attributes.md](https://github.com/riot/compiler/blob/dev/doc/attributes.md)\n     */\n    RE_BOOL_ATTRS = /^(?:disabled|checked|readonly|required|allowfullscreen|auto(?:focus|play)|compact|controls|default|formnovalidate|hidden|ismap|itemscope|loop|multiple|muted|no(?:resize|shade|validate|wrap)?|open|reversed|seamless|selected|sortable|truespeed|typemustmatch)$/,\n    // version# for IE 8-11, 0 for others\n    IE_VERSION = (WIN && WIN.document || /* istanbul ignore next */ {}).documentMode | 0;\n\n  /**\n   * Create a generic DOM node\n   * @param   { String } name - name of the DOM node we want to create\n   * @returns { Object } DOM node just created\n   */\n  function makeElement(name) {\n    return name === 'svg' ? document.createElementNS(SVG_NS, name) : document.createElement(name)\n  }\n\n  /**\n   * Set any DOM attribute\n   * @param { Object } dom - DOM node we want to update\n   * @param { String } name - name of the property we want to set\n   * @param { String } val - value of the property we want to set\n   */\n  function setAttribute(dom, name, val) {\n    var xlink = XLINK_REGEX.exec(name);\n    if (xlink && xlink[1])\n      { dom.setAttributeNS(XLINK_NS, xlink[1], val); }\n    else\n      { dom.setAttribute(name, val); }\n  }\n\n  var styleNode;\n  // Create cache and shortcut to the correct property\n  var cssTextProp;\n  var byName = {};\n  var needsInject = false;\n\n  // skip the following code on the server\n  if (WIN) {\n    styleNode = ((function () {\n      // create a new style element with the correct type\n      var newNode = makeElement('style');\n      // replace any user node or insert the new one into the head\n      var userNode = $('style[type=riot]');\n\n      setAttribute(newNode, 'type', 'text/css');\n      /* istanbul ignore next */\n      if (userNode) {\n        if (userNode.id) { newNode.id = userNode.id; }\n        userNode.parentNode.replaceChild(newNode, userNode);\n      } else { document.head.appendChild(newNode); }\n\n      return newNode\n    }))();\n    cssTextProp = styleNode.styleSheet;\n  }\n\n  /**\n   * Object that will be used to inject and manage the css of every tag instance\n   */\n  var styleManager = {\n    styleNode: styleNode,\n    /**\n     * Save a tag style to be later injected into DOM\n     * @param { String } css - css string\n     * @param { String } name - if it's passed we will map the css to a tagname\n     */\n    add: function add(css, name) {\n      byName[name] = css;\n      needsInject = true;\n    },\n    /**\n     * Inject all previously saved tag styles into DOM\n     * innerHTML seems slow: http://jsperf.com/riot-insert-style\n     */\n    inject: function inject() {\n      if (!WIN || !needsInject) { return }\n      needsInject = false;\n      var style = Object.keys(byName)\n        .map(function (k) { return byName[k]; })\n        .join('\\n');\n      /* istanbul ignore next */\n      if (cssTextProp) { cssTextProp.cssText = style; }\n      else { styleNode.innerHTML = style; }\n    },\n\n    /**\n     * Remove a tag style of injected DOM later.\n     * @param {String} name a registered tagname\n     */\n    remove: function remove(name) {\n      delete byName[name];\n      needsInject = true;\n    }\n  }\n\n  /**\n   * The riot template engine\n   * @version v3.0.8\n   */\n\n  /* istanbul ignore next */\n  var skipRegex = (function () { //eslint-disable-line no-unused-vars\n\n    var beforeReChars = '[{(,;:?=|&!^~>%*/';\n\n    var beforeReWords = [\n      'case',\n      'default',\n      'do',\n      'else',\n      'in',\n      'instanceof',\n      'prefix',\n      'return',\n      'typeof',\n      'void',\n      'yield'\n    ];\n\n    var wordsLastChar = beforeReWords.reduce(function (s, w) {\n      return s + w.slice(-1)\n    }, '');\n\n    var RE_REGEX = /^\\/(?=[^*>/])[^[/\\\\]*(?:(?:\\\\.|\\[(?:\\\\.|[^\\]\\\\]*)*\\])[^[\\\\/]*)*?\\/[gimuy]*/;\n    var RE_VN_CHAR = /[$\\w]/;\n\n    function prev (code, pos) {\n      while (--pos >= 0 && /\\s/.test(code[pos])){ }\n      return pos\n    }\n\n    function _skipRegex (code, start) {\n\n      var re = /.*/g;\n      var pos = re.lastIndex = start++;\n      var match = re.exec(code)[0].match(RE_REGEX);\n\n      if (match) {\n        var next = pos + match[0].length;\n\n        pos = prev(code, pos);\n        var c = code[pos];\n\n        if (pos < 0 || ~beforeReChars.indexOf(c)) {\n          return next\n        }\n\n        if (c === '.') {\n\n          if (code[pos - 1] === '.') {\n            start = next;\n          }\n\n        } else if (c === '+' || c === '-') {\n\n          if (code[--pos] !== c ||\n              (pos = prev(code, pos)) < 0 ||\n              !RE_VN_CHAR.test(code[pos])) {\n            start = next;\n          }\n\n        } else if (~wordsLastChar.indexOf(c)) {\n\n          var end = pos + 1;\n\n          while (--pos >= 0 && RE_VN_CHAR.test(code[pos])){ }\n          if (~beforeReWords.indexOf(code.slice(pos + 1, end))) {\n            start = next;\n          }\n        }\n      }\n\n      return start\n    }\n\n    return _skipRegex\n\n  })();\n\n  /**\n   * riot.util.brackets\n   *\n   * - `brackets    ` - Returns a string or regex based on its parameter\n   * - `brackets.set` - Change the current riot brackets\n   *\n   * @module\n   */\n\n  /* global riot */\n\n  /* istanbul ignore next */\n  var brackets = (function (UNDEF) {\n\n    var\n      REGLOB = 'g',\n\n      R_MLCOMMS = /\\/\\*[^*]*\\*+(?:[^*\\/][^*]*\\*+)*\\//g,\n\n      R_STRINGS = /\"[^\"\\\\]*(?:\\\\[\\S\\s][^\"\\\\]*)*\"|'[^'\\\\]*(?:\\\\[\\S\\s][^'\\\\]*)*'|`[^`\\\\]*(?:\\\\[\\S\\s][^`\\\\]*)*`/g,\n\n      S_QBLOCKS = R_STRINGS.source + '|' +\n        /(?:\\breturn\\s+|(?:[$\\w\\)\\]]|\\+\\+|--)\\s*(\\/)(?![*\\/]))/.source + '|' +\n        /\\/(?=[^*\\/])[^[\\/\\\\]*(?:(?:\\[(?:\\\\.|[^\\]\\\\]*)*\\]|\\\\.)[^[\\/\\\\]*)*?([^<]\\/)[gim]*/.source,\n\n      UNSUPPORTED = RegExp('[\\\\' + 'x00-\\\\x1F<>a-zA-Z0-9\\'\",;\\\\\\\\]'),\n\n      NEED_ESCAPE = /(?=[[\\]()*+?.^$|])/g,\n\n      S_QBLOCK2 = R_STRINGS.source + '|' + /(\\/)(?![*\\/])/.source,\n\n      FINDBRACES = {\n        '(': RegExp('([()])|'   + S_QBLOCK2, REGLOB),\n        '[': RegExp('([[\\\\]])|' + S_QBLOCK2, REGLOB),\n        '{': RegExp('([{}])|'   + S_QBLOCK2, REGLOB)\n      },\n\n      DEFAULT = '{ }';\n\n    var _pairs = [\n      '{', '}',\n      '{', '}',\n      /{[^}]*}/,\n      /\\\\([{}])/g,\n      /\\\\({)|{/g,\n      RegExp('\\\\\\\\(})|([[({])|(})|' + S_QBLOCK2, REGLOB),\n      DEFAULT,\n      /^\\s*{\\^?\\s*([$\\w]+)(?:\\s*,\\s*(\\S+))?\\s+in\\s+(\\S.*)\\s*}/,\n      /(^|[^\\\\]){=[\\S\\s]*?}/\n    ];\n\n    var\n      cachedBrackets = UNDEF,\n      _regex,\n      _cache = [],\n      _settings;\n\n    function _loopback (re) { return re }\n\n    function _rewrite (re, bp) {\n      if (!bp) { bp = _cache; }\n      return new RegExp(\n        re.source.replace(/{/g, bp[2]).replace(/}/g, bp[3]), re.global ? REGLOB : ''\n      )\n    }\n\n    function _create (pair) {\n      if (pair === DEFAULT) { return _pairs }\n\n      var arr = pair.split(' ');\n\n      if (arr.length !== 2 || UNSUPPORTED.test(pair)) {\n        throw new Error('Unsupported brackets \"' + pair + '\"')\n      }\n      arr = arr.concat(pair.replace(NEED_ESCAPE, '\\\\').split(' '));\n\n      arr[4] = _rewrite(arr[1].length > 1 ? /{[\\S\\s]*?}/ : _pairs[4], arr);\n      arr[5] = _rewrite(pair.length > 3 ? /\\\\({|})/g : _pairs[5], arr);\n      arr[6] = _rewrite(_pairs[6], arr);\n      arr[7] = RegExp('\\\\\\\\(' + arr[3] + ')|([[({])|(' + arr[3] + ')|' + S_QBLOCK2, REGLOB);\n      arr[8] = pair;\n      return arr\n    }\n\n    function _brackets (reOrIdx) {\n      return reOrIdx instanceof RegExp ? _regex(reOrIdx) : _cache[reOrIdx]\n    }\n\n    _brackets.split = function split (str, tmpl, _bp) {\n      // istanbul ignore next: _bp is for the compiler\n      if (!_bp) { _bp = _cache; }\n\n      var\n        parts = [],\n        match,\n        isexpr,\n        start,\n        pos,\n        re = _bp[6];\n\n      var qblocks = [];\n      var prevStr = '';\n      var mark, lastIndex;\n\n      isexpr = start = re.lastIndex = 0;\n\n      while ((match = re.exec(str))) {\n\n        lastIndex = re.lastIndex;\n        pos = match.index;\n\n        if (isexpr) {\n\n          if (match[2]) {\n\n            var ch = match[2];\n            var rech = FINDBRACES[ch];\n            var ix = 1;\n\n            rech.lastIndex = lastIndex;\n            while ((match = rech.exec(str))) {\n              if (match[1]) {\n                if (match[1] === ch) { ++ix; }\n                else if (!--ix) { break }\n              } else {\n                rech.lastIndex = pushQBlock(match.index, rech.lastIndex, match[2]);\n              }\n            }\n            re.lastIndex = ix ? str.length : rech.lastIndex;\n            continue\n          }\n\n          if (!match[3]) {\n            re.lastIndex = pushQBlock(pos, lastIndex, match[4]);\n            continue\n          }\n        }\n\n        if (!match[1]) {\n          unescapeStr(str.slice(start, pos));\n          start = re.lastIndex;\n          re = _bp[6 + (isexpr ^= 1)];\n          re.lastIndex = start;\n        }\n      }\n\n      if (str && start < str.length) {\n        unescapeStr(str.slice(start));\n      }\n\n      parts.qblocks = qblocks;\n\n      return parts\n\n      function unescapeStr (s) {\n        if (prevStr) {\n          s = prevStr + s;\n          prevStr = '';\n        }\n        if (tmpl || isexpr) {\n          parts.push(s && s.replace(_bp[5], '$1'));\n        } else {\n          parts.push(s);\n        }\n      }\n\n      function pushQBlock(_pos, _lastIndex, slash) { //eslint-disable-line\n        if (slash) {\n          _lastIndex = skipRegex(str, _pos);\n        }\n\n        if (tmpl && _lastIndex > _pos + 2) {\n          mark = '\\u2057' + qblocks.length + '~';\n          qblocks.push(str.slice(_pos, _lastIndex));\n          prevStr += str.slice(start, _pos) + mark;\n          start = _lastIndex;\n        }\n        return _lastIndex\n      }\n    };\n\n    _brackets.hasExpr = function hasExpr (str) {\n      return _cache[4].test(str)\n    };\n\n    _brackets.loopKeys = function loopKeys (expr) {\n      var m = expr.match(_cache[9]);\n\n      return m\n        ? { key: m[1], pos: m[2], val: _cache[0] + m[3].trim() + _cache[1] }\n        : { val: expr.trim() }\n    };\n\n    _brackets.array = function array (pair) {\n      return pair ? _create(pair) : _cache\n    };\n\n    function _reset (pair) {\n      if ((pair || (pair = DEFAULT)) !== _cache[8]) {\n        _cache = _create(pair);\n        _regex = pair === DEFAULT ? _loopback : _rewrite;\n        _cache[9] = _regex(_pairs[9]);\n      }\n      cachedBrackets = pair;\n    }\n\n    function _setSettings (o) {\n      var b;\n\n      o = o || {};\n      b = o.brackets;\n      Object.defineProperty(o, 'brackets', {\n        set: _reset,\n        get: function () { return cachedBrackets },\n        enumerable: true\n      });\n      _settings = o;\n      _reset(b);\n    }\n\n    Object.defineProperty(_brackets, 'settings', {\n      set: _setSettings,\n      get: function () { return _settings }\n    });\n\n    /* istanbul ignore next: in the browser riot is always in the scope */\n    _brackets.settings = typeof riot !== 'undefined' && riot.settings || {};\n    _brackets.set = _reset;\n    _brackets.skipRegex = skipRegex;\n\n    _brackets.R_STRINGS = R_STRINGS;\n    _brackets.R_MLCOMMS = R_MLCOMMS;\n    _brackets.S_QBLOCKS = S_QBLOCKS;\n    _brackets.S_QBLOCK2 = S_QBLOCK2;\n\n    return _brackets\n\n  })();\n\n  /**\n   * @module tmpl\n   *\n   * tmpl          - Root function, returns the template value, render with data\n   * tmpl.hasExpr  - Test the existence of a expression inside a string\n   * tmpl.loopKeys - Get the keys for an 'each' loop (used by `_each`)\n   */\n\n  /* istanbul ignore next */\n  var tmpl = (function () {\n\n    var _cache = {};\n\n    function _tmpl (str, data) {\n      if (!str) { return str }\n\n      return (_cache[str] || (_cache[str] = _create(str))).call(\n        data, _logErr.bind({\n          data: data,\n          tmpl: str\n        })\n      )\n    }\n\n    _tmpl.hasExpr = brackets.hasExpr;\n\n    _tmpl.loopKeys = brackets.loopKeys;\n\n    // istanbul ignore next\n    _tmpl.clearCache = function () { _cache = {}; };\n\n    _tmpl.errorHandler = null;\n\n    function _logErr (err, ctx) {\n\n      err.riotData = {\n        tagName: ctx && ctx.__ && ctx.__.tagName,\n        _riot_id: ctx && ctx._riot_id  //eslint-disable-line camelcase\n      };\n\n      if (_tmpl.errorHandler) { _tmpl.errorHandler(err); }\n      else if (\n        typeof console !== 'undefined' &&\n        typeof console.error === 'function'\n      ) {\n        console.error(err.message);\n        console.log('<%s> %s', err.riotData.tagName || 'Unknown tag', this.tmpl); // eslint-disable-line\n        console.log(this.data); // eslint-disable-line\n      }\n    }\n\n    function _create (str) {\n      var expr = _getTmpl(str);\n\n      if (expr.slice(0, 11) !== 'try{return ') { expr = 'return ' + expr; }\n\n      return new Function('E', expr + ';')    // eslint-disable-line no-new-func\n    }\n\n    var RE_DQUOTE = /\\u2057/g;\n    var RE_QBMARK = /\\u2057(\\d+)~/g;\n\n    function _getTmpl (str) {\n      var parts = brackets.split(str.replace(RE_DQUOTE, '\"'), 1);\n      var qstr = parts.qblocks;\n      var expr;\n\n      if (parts.length > 2 || parts[0]) {\n        var i, j, list = [];\n\n        for (i = j = 0; i < parts.length; ++i) {\n\n          expr = parts[i];\n\n          if (expr && (expr = i & 1\n\n              ? _parseExpr(expr, 1, qstr)\n\n              : '\"' + expr\n                  .replace(/\\\\/g, '\\\\\\\\')\n                  .replace(/\\r\\n?|\\n/g, '\\\\n')\n                  .replace(/\"/g, '\\\\\"') +\n                '\"'\n\n            )) { list[j++] = expr; }\n\n        }\n\n        expr = j < 2 ? list[0]\n             : '[' + list.join(',') + '].join(\"\")';\n\n      } else {\n\n        expr = _parseExpr(parts[1], 0, qstr);\n      }\n\n      if (qstr.length) {\n        expr = expr.replace(RE_QBMARK, function (_, pos) {\n          return qstr[pos]\n            .replace(/\\r/g, '\\\\r')\n            .replace(/\\n/g, '\\\\n')\n        });\n      }\n      return expr\n    }\n\n    var RE_CSNAME = /^(?:(-?[_A-Za-z\\xA0-\\xFF][-\\w\\xA0-\\xFF]*)|\\u2057(\\d+)~):/;\n    var\n      RE_BREND = {\n        '(': /[()]/g,\n        '[': /[[\\]]/g,\n        '{': /[{}]/g\n      };\n\n    function _parseExpr (expr, asText, qstr) {\n\n      expr = expr\n        .replace(/\\s+/g, ' ').trim()\n        .replace(/\\ ?([[\\({},?\\.:])\\ ?/g, '$1');\n\n      if (expr) {\n        var\n          list = [],\n          cnt = 0,\n          match;\n\n        while (expr &&\n              (match = expr.match(RE_CSNAME)) &&\n              !match.index\n          ) {\n          var\n            key,\n            jsb,\n            re = /,|([[{(])|$/g;\n\n          expr = RegExp.rightContext;\n          key  = match[2] ? qstr[match[2]].slice(1, -1).trim().replace(/\\s+/g, ' ') : match[1];\n\n          while (jsb = (match = re.exec(expr))[1]) { skipBraces(jsb, re); }\n\n          jsb  = expr.slice(0, match.index);\n          expr = RegExp.rightContext;\n\n          list[cnt++] = _wrapExpr(jsb, 1, key);\n        }\n\n        expr = !cnt ? _wrapExpr(expr, asText)\n             : cnt > 1 ? '[' + list.join(',') + '].join(\" \").trim()' : list[0];\n      }\n      return expr\n\n      function skipBraces (ch, re) {\n        var\n          mm,\n          lv = 1,\n          ir = RE_BREND[ch];\n\n        ir.lastIndex = re.lastIndex;\n        while (mm = ir.exec(expr)) {\n          if (mm[0] === ch) { ++lv; }\n          else if (!--lv) { break }\n        }\n        re.lastIndex = lv ? expr.length : ir.lastIndex;\n      }\n    }\n\n    // istanbul ignore next: not both\n    var // eslint-disable-next-line max-len\n      JS_CONTEXT = '\"in this?this:' + (typeof window !== 'object' ? 'global' : 'window') + ').',\n      JS_VARNAME = /[,{][\\$\\w]+(?=:)|(^ *|[^$\\w\\.{])(?!(?:typeof|true|false|null|undefined|in|instanceof|is(?:Finite|NaN)|void|NaN|new|Date|RegExp|Math)(?![$\\w]))([$_A-Za-z][$\\w]*)/g,\n      JS_NOPROPS = /^(?=(\\.[$\\w]+))\\1(?:[^.[(]|$)/;\n\n    function _wrapExpr (expr, asText, key) {\n      var tb;\n\n      expr = expr.replace(JS_VARNAME, function (match, p, mvar, pos, s) {\n        if (mvar) {\n          pos = tb ? 0 : pos + match.length;\n\n          if (mvar !== 'this' && mvar !== 'global' && mvar !== 'window') {\n            match = p + '(\"' + mvar + JS_CONTEXT + mvar;\n            if (pos) { tb = (s = s[pos]) === '.' || s === '(' || s === '['; }\n          } else if (pos) {\n            tb = !JS_NOPROPS.test(s.slice(pos));\n          }\n        }\n        return match\n      });\n\n      if (tb) {\n        expr = 'try{return ' + expr + '}catch(e){E(e,this)}';\n      }\n\n      if (key) {\n\n        expr = (tb\n            ? 'function(){' + expr + '}.call(this)' : '(' + expr + ')'\n          ) + '?\"' + key + '\":\"\"';\n\n      } else if (asText) {\n\n        expr = 'function(v){' + (tb\n            ? expr.replace('return ', 'v=') : 'v=(' + expr + ')'\n          ) + ';return v||v===0?v:\"\"}.call(this)';\n      }\n\n      return expr\n    }\n\n    _tmpl.version = brackets.version = 'v3.0.8';\n\n    return _tmpl\n\n  })();\n\n  /* istanbul ignore next */\n  var observable = function(el) {\n\n    /**\n     * Extend the original object or create a new empty one\n     * @type { Object }\n     */\n\n    el = el || {};\n\n    /**\n     * Private variables\n     */\n    var callbacks = {},\n      slice = Array.prototype.slice;\n\n    /**\n     * Public Api\n     */\n\n    // extend the el object adding the observable methods\n    Object.defineProperties(el, {\n      /**\n       * Listen to the given `event` ands\n       * execute the `callback` each time an event is triggered.\n       * @param  { String } event - event id\n       * @param  { Function } fn - callback function\n       * @returns { Object } el\n       */\n      on: {\n        value: function(event, fn) {\n          if (typeof fn == 'function')\n            { (callbacks[event] = callbacks[event] || []).push(fn); }\n          return el\n        },\n        enumerable: false,\n        writable: false,\n        configurable: false\n      },\n\n      /**\n       * Removes the given `event` listeners\n       * @param   { String } event - event id\n       * @param   { Function } fn - callback function\n       * @returns { Object } el\n       */\n      off: {\n        value: function(event, fn) {\n          if (event == '*' && !fn) { callbacks = {}; }\n          else {\n            if (fn) {\n              var arr = callbacks[event];\n              for (var i = 0, cb; cb = arr && arr[i]; ++i) {\n                if (cb == fn) { arr.splice(i--, 1); }\n              }\n            } else { delete callbacks[event]; }\n          }\n          return el\n        },\n        enumerable: false,\n        writable: false,\n        configurable: false\n      },\n\n      /**\n       * Listen to the given `event` and\n       * execute the `callback` at most once\n       * @param   { String } event - event id\n       * @param   { Function } fn - callback function\n       * @returns { Object } el\n       */\n      one: {\n        value: function(event, fn) {\n          function on() {\n            el.off(event, on);\n            fn.apply(el, arguments);\n          }\n          return el.on(event, on)\n        },\n        enumerable: false,\n        writable: false,\n        configurable: false\n      },\n\n      /**\n       * Execute all callback functions that listen to\n       * the given `event`\n       * @param   { String } event - event id\n       * @returns { Object } el\n       */\n      trigger: {\n        value: function(event) {\n          var arguments$1 = arguments;\n\n\n          // getting the arguments\n          var arglen = arguments.length - 1,\n            args = new Array(arglen),\n            fns,\n            fn,\n            i;\n\n          for (i = 0; i < arglen; i++) {\n            args[i] = arguments$1[i + 1]; // skip first argument\n          }\n\n          fns = slice.call(callbacks[event] || [], 0);\n\n          for (i = 0; fn = fns[i]; ++i) {\n            fn.apply(el, args);\n          }\n\n          if (callbacks['*'] && event != '*')\n            { el.trigger.apply(el, ['*', event].concat(args)); }\n\n          return el\n        },\n        enumerable: false,\n        writable: false,\n        configurable: false\n      }\n    });\n\n    return el\n\n  };\n\n  /**\n   * Short alias for Object.getOwnPropertyDescriptor\n   */\n  function getPropDescriptor (o, k) {\n    return Object.getOwnPropertyDescriptor(o, k)\n  }\n\n  /**\n   * Check if passed argument is undefined\n   * @param   { * } value -\n   * @returns { Boolean } -\n   */\n  function isUndefined(value) {\n    return typeof value === T_UNDEF\n  }\n\n  /**\n   * Check whether object's property could be overridden\n   * @param   { Object }  obj - source object\n   * @param   { String }  key - object property\n   * @returns { Boolean } true if writable\n   */\n  function isWritable(obj, key) {\n    var descriptor = getPropDescriptor(obj, key);\n    return isUndefined(obj[key]) || descriptor && descriptor.writable\n  }\n\n  /**\n   * Extend any object with other properties\n   * @param   { Object } src - source object\n   * @returns { Object } the resulting extended object\n   *\n   * var obj = { foo: 'baz' }\n   * extend(obj, {bar: 'bar', foo: 'bar'})\n   * console.log(obj) => {bar: 'bar', foo: 'bar'}\n   *\n   */\n  function extend(src) {\n    var obj;\n    var i = 1;\n    var args = arguments;\n    var l = args.length;\n\n    for (; i < l; i++) {\n      if (obj = args[i]) {\n        for (var key in obj) {\n          // check if this property of the source object could be overridden\n          if (isWritable(src, key))\n            { src[key] = obj[key]; }\n        }\n      }\n    }\n    return src\n  }\n\n  /**\n   * Alias for Object.create\n   */\n  function create(src) {\n    return Object.create(src)\n  }\n\n  var settings = extend(create(brackets.settings), {\n    skipAnonymousTags: true,\n    // handle the auto updates on any DOM event\n    autoUpdate: true\n  })\n\n  /**\n   * Shorter and fast way to select multiple nodes in the DOM\n   * @param   { String } selector - DOM selector\n   * @param   { Object } ctx - DOM node where the targets of our search will is located\n   * @returns { Object } dom nodes found\n   */\n  function $$(selector, ctx) {\n    return [].slice.call((ctx || document).querySelectorAll(selector))\n  }\n\n  /**\n   * Create a document text node\n   * @returns { Object } create a text node to use as placeholder\n   */\n  function createDOMPlaceholder() {\n    return document.createTextNode('')\n  }\n\n  /**\n   * Toggle the visibility of any DOM node\n   * @param   { Object }  dom - DOM node we want to hide\n   * @param   { Boolean } show - do we want to show it?\n   */\n\n  function toggleVisibility(dom, show) {\n    dom.style.display = show ? '' : 'none';\n    dom.hidden = show ? false : true;\n  }\n\n  /**\n   * Get the value of any DOM attribute on a node\n   * @param   { Object } dom - DOM node we want to parse\n   * @param   { String } name - name of the attribute we want to get\n   * @returns { String | undefined } name of the node attribute whether it exists\n   */\n  function getAttribute(dom, name) {\n    return dom.getAttribute(name)\n  }\n\n  /**\n   * Remove any DOM attribute from a node\n   * @param   { Object } dom - DOM node we want to update\n   * @param   { String } name - name of the property we want to remove\n   */\n  function removeAttribute(dom, name) {\n    dom.removeAttribute(name);\n  }\n\n  /**\n   * Set the inner html of any DOM node SVGs included\n   * @param { Object } container - DOM node where we'll inject new html\n   * @param { String } html - html to inject\n   * @param { Boolean } isSvg - svg tags should be treated a bit differently\n   */\n  /* istanbul ignore next */\n  function setInnerHTML(container, html, isSvg) {\n    // innerHTML is not supported on svg tags so we neet to treat them differently\n    if (isSvg) {\n      var node = container.ownerDocument.importNode(\n        new DOMParser()\n          .parseFromString((\"<svg xmlns=\\\"\" + SVG_NS + \"\\\">\" + html + \"</svg>\"), 'application/xml')\n          .documentElement,\n        true\n      );\n\n      container.appendChild(node);\n    } else {\n      container.innerHTML = html;\n    }\n  }\n\n  /**\n   * Minimize risk: only zero or one _space_ between attr & value\n   * @param   { String }   html - html string we want to parse\n   * @param   { Function } fn - callback function to apply on any attribute found\n   */\n  function walkAttributes(html, fn) {\n    if (!html) { return }\n    var m;\n    while (m = RE_HTML_ATTRS.exec(html))\n      { fn(m[1].toLowerCase(), m[2] || m[3] || m[4]); }\n  }\n\n  /**\n   * Create a document fragment\n   * @returns { Object } document fragment\n   */\n  function createFragment() {\n    return document.createDocumentFragment()\n  }\n\n  /**\n   * Insert safely a tag to fix #1962 #1649\n   * @param   { HTMLElement } root - children container\n   * @param   { HTMLElement } curr - node to insert\n   * @param   { HTMLElement } next - node that should preceed the current node inserted\n   */\n  function safeInsert(root, curr, next) {\n    root.insertBefore(curr, next.parentNode && next);\n  }\n\n  /**\n   * Convert a style object to a string\n   * @param   { Object } style - style object we need to parse\n   * @returns { String } resulting css string\n   * @example\n   * styleObjectToString({ color: 'red', height: '10px'}) // => 'color: red; height: 10px'\n   */\n  function styleObjectToString(style) {\n    return Object.keys(style).reduce(function (acc, prop) {\n      return (acc + \" \" + prop + \": \" + (style[prop]) + \";\")\n    }, '')\n  }\n\n  /**\n   * Walk down recursively all the children tags starting dom node\n   * @param   { Object }   dom - starting node where we will start the recursion\n   * @param   { Function } fn - callback to transform the child node just found\n   * @param   { Object }   context - fn can optionally return an object, which is passed to children\n   */\n  function walkNodes(dom, fn, context) {\n    if (dom) {\n      var res = fn(dom, context);\n      var next;\n      // stop the recursion\n      if (res === false) { return }\n\n      dom = dom.firstChild;\n\n      while (dom) {\n        next = dom.nextSibling;\n        walkNodes(dom, fn, res);\n        dom = next;\n      }\n    }\n  }\n\n\n\n  var dom = /*#__PURE__*/Object.freeze({\n    $$: $$,\n    $: $,\n    createDOMPlaceholder: createDOMPlaceholder,\n    mkEl: makeElement,\n    setAttr: setAttribute,\n    toggleVisibility: toggleVisibility,\n    getAttr: getAttribute,\n    remAttr: removeAttribute,\n    setInnerHTML: setInnerHTML,\n    walkAttrs: walkAttributes,\n    createFrag: createFragment,\n    safeInsert: safeInsert,\n    styleObjectToString: styleObjectToString,\n    walkNodes: walkNodes\n  });\n\n  /**\n   * Check against the null and undefined values\n   * @param   { * }  value -\n   * @returns {Boolean} -\n   */\n  function isNil(value) {\n    return isUndefined(value) || value === null\n  }\n\n  /**\n   * Check if passed argument is empty. Different from falsy, because we dont consider 0 or false to be blank\n   * @param { * } value -\n   * @returns { Boolean } -\n   */\n  function isBlank(value) {\n    return isNil(value) || value === ''\n  }\n\n  /**\n   * Check if passed argument is a function\n   * @param   { * } value -\n   * @returns { Boolean } -\n   */\n  function isFunction(value) {\n    return typeof value === T_FUNCTION\n  }\n\n  /**\n   * Check if passed argument is an object, exclude null\n   * NOTE: use isObject(x) && !isArray(x) to excludes arrays.\n   * @param   { * } value -\n   * @returns { Boolean } -\n   */\n  function isObject(value) {\n    return value && typeof value === T_OBJECT // typeof null is 'object'\n  }\n\n  /**\n   * Check if a DOM node is an svg tag or part of an svg\n   * @param   { HTMLElement }  el - node we want to test\n   * @returns {Boolean} true if it's an svg node\n   */\n  function isSvg(el) {\n    var owner = el.ownerSVGElement;\n    return !!owner || owner === null\n  }\n\n  /**\n   * Check if passed argument is a kind of array\n   * @param   { * } value -\n   * @returns { Boolean } -\n   */\n  function isArray(value) {\n    return Array.isArray(value) || value instanceof Array\n  }\n\n  /**\n   * Check if the passed argument is a boolean attribute\n   * @param   { String } value -\n   * @returns { Boolean } -\n   */\n  function isBoolAttr(value) {\n    return RE_BOOL_ATTRS.test(value)\n  }\n\n  /**\n   * Check if passed argument is a string\n   * @param   { * } value -\n   * @returns { Boolean } -\n   */\n  function isString(value) {\n    return typeof value === T_STRING\n  }\n\n\n\n  var check = /*#__PURE__*/Object.freeze({\n    isBlank: isBlank,\n    isFunction: isFunction,\n    isObject: isObject,\n    isSvg: isSvg,\n    isWritable: isWritable,\n    isArray: isArray,\n    isBoolAttr: isBoolAttr,\n    isNil: isNil,\n    isString: isString,\n    isUndefined: isUndefined\n  });\n\n  /**\n   * Check whether an array contains an item\n   * @param   { Array } array - target array\n   * @param   { * } item - item to test\n   * @returns { Boolean } -\n   */\n  function contains(array, item) {\n    return array.indexOf(item) !== -1\n  }\n\n  /**\n   * Specialized function for looping an array-like collection with `each={}`\n   * @param   { Array } list - collection of items\n   * @param   {Function} fn - callback function\n   * @returns { Array } the array looped\n   */\n  function each(list, fn) {\n    var len = list ? list.length : 0;\n    var i = 0;\n    for (; i < len; i++) { fn(list[i], i); }\n    return list\n  }\n\n  /**\n   * Faster String startsWith alternative\n   * @param   { String } str - source string\n   * @param   { String } value - test string\n   * @returns { Boolean } -\n   */\n  function startsWith(str, value) {\n    return str.slice(0, value.length) === value\n  }\n\n  /**\n   * Function returning always a unique identifier\n   * @returns { Number } - number from 0...n\n   */\n  var uid = (function uid() {\n    var i = -1;\n    return function () { return ++i; }\n  })()\n\n  /**\n   * Helper function to set an immutable property\n   * @param   { Object } el - object where the new property will be set\n   * @param   { String } key - object key where the new property will be stored\n   * @param   { * } value - value of the new property\n   * @param   { Object } options - set the propery overriding the default options\n   * @returns { Object } - the initial object\n   */\n  function define(el, key, value, options) {\n    Object.defineProperty(el, key, extend({\n      value: value,\n      enumerable: false,\n      writable: false,\n      configurable: true\n    }, options));\n    return el\n  }\n\n  /**\n   * Convert a string containing dashes to camel case\n   * @param   { String } str - input string\n   * @returns { String } my-string -> myString\n   */\n  function toCamel(str) {\n    return str.replace(/-(\\w)/g, function (_, c) { return c.toUpperCase(); })\n  }\n\n  /**\n   * Warn a message via console\n   * @param   {String} message - warning message\n   */\n  function warn(message) {\n    if (console && console.warn) { console.warn(message); }\n  }\n\n\n\n  var misc = /*#__PURE__*/Object.freeze({\n    contains: contains,\n    each: each,\n    getPropDescriptor: getPropDescriptor,\n    startsWith: startsWith,\n    uid: uid,\n    defineProperty: define,\n    objectCreate: create,\n    extend: extend,\n    toCamel: toCamel,\n    warn: warn\n  });\n\n  /**\n   * Set the property of an object for a given key. If something already\n   * exists there, then it becomes an array containing both the old and new value.\n   * @param { Object } obj - object on which to set the property\n   * @param { String } key - property name\n   * @param { Object } value - the value of the property to be set\n   * @param { Boolean } ensureArray - ensure that the property remains an array\n   * @param { Number } index - add the new item in a certain array position\n   */\n  function arrayishAdd(obj, key, value, ensureArray, index) {\n    var dest = obj[key];\n    var isArr = isArray(dest);\n    var hasIndex = !isUndefined(index);\n\n    if (dest && dest === value) { return }\n\n    // if the key was never set, set it once\n    if (!dest && ensureArray) { obj[key] = [value]; }\n    else if (!dest) { obj[key] = value; }\n    // if it was an array and not yet set\n    else {\n      if (isArr) {\n        var oldIndex = dest.indexOf(value);\n        // this item never changed its position\n        if (oldIndex === index) { return }\n        // remove the item from its old position\n        if (oldIndex !== -1) { dest.splice(oldIndex, 1); }\n        // move or add the item\n        if (hasIndex) {\n          dest.splice(index, 0, value);\n        } else {\n          dest.push(value);\n        }\n      } else { obj[key] = [dest, value]; }\n    }\n  }\n\n  /**\n   * Detect the tag implementation by a DOM node\n   * @param   { Object } dom - DOM node we need to parse to get its tag implementation\n   * @returns { Object } it returns an object containing the implementation of a custom tag (template and boot function)\n   */\n  function get(dom) {\n    return dom.tagName && __TAG_IMPL[getAttribute(dom, IS_DIRECTIVE) ||\n      getAttribute(dom, IS_DIRECTIVE) || dom.tagName.toLowerCase()]\n  }\n\n  /**\n   * Get the tag name of any DOM node\n   * @param   { Object } dom - DOM node we want to parse\n   * @param   { Boolean } skipDataIs - hack to ignore the data-is attribute when attaching to parent\n   * @returns { String } name to identify this dom node in riot\n   */\n  function getName(dom, skipDataIs) {\n    var child = get(dom);\n    var namedTag = !skipDataIs && getAttribute(dom, IS_DIRECTIVE);\n    return namedTag && !tmpl.hasExpr(namedTag) ?\n      namedTag : child ? child.name : dom.tagName.toLowerCase()\n  }\n\n  /**\n   * Return a temporary context containing also the parent properties\n   * @this Tag\n   * @param { Tag } - temporary tag context containing all the parent properties\n   */\n  function inheritParentProps() {\n    if (this.parent) { return extend(create(this), this.parent) }\n    return this\n  }\n\n  /*\n    Includes hacks needed for the Internet Explorer version 9 and below\n    See: http://kangax.github.io/compat-table/es5/#ie8\n         http://codeplanet.io/dropping-ie8/\n  */\n\n  var\n    reHasYield  = /<yield\\b/i,\n    reYieldAll  = /<yield\\s*(?:\\/>|>([\\S\\s]*?)<\\/yield\\s*>|>)/ig,\n    reYieldSrc  = /<yield\\s+to=['\"]([^'\">]*)['\"]\\s*>([\\S\\s]*?)<\\/yield\\s*>/ig,\n    reYieldDest = /<yield\\s+from=['\"]?([-\\w]+)['\"]?\\s*(?:\\/>|>([\\S\\s]*?)<\\/yield\\s*>)/ig,\n    rootEls = { tr: 'tbody', th: 'tr', td: 'tr', col: 'colgroup' },\n    tblTags = IE_VERSION && IE_VERSION < 10 ? RE_SPECIAL_TAGS : RE_SPECIAL_TAGS_NO_OPTION,\n    GENERIC = 'div',\n    SVG = 'svg';\n\n\n  /*\n    Creates the root element for table or select child elements:\n    tr/th/td/thead/tfoot/tbody/caption/col/colgroup/option/optgroup\n  */\n  function specialTags(el, tmpl, tagName) {\n\n    var\n      select = tagName[0] === 'o',\n      parent = select ? 'select>' : 'table>';\n\n    // trim() is important here, this ensures we don't have artifacts,\n    // so we can check if we have only one element inside the parent\n    el.innerHTML = '<' + parent + tmpl.trim() + '</' + parent;\n    parent = el.firstChild;\n\n    // returns the immediate parent if tr/th/td/col is the only element, if not\n    // returns the whole tree, as this can include additional elements\n    /* istanbul ignore next */\n    if (select) {\n      parent.selectedIndex = -1;  // for IE9, compatible w/current riot behavior\n    } else {\n      // avoids insertion of cointainer inside container (ex: tbody inside tbody)\n      var tname = rootEls[tagName];\n      if (tname && parent.childElementCount === 1) { parent = $(tname, parent); }\n    }\n    return parent\n  }\n\n  /*\n    Replace the yield tag from any tag template with the innerHTML of the\n    original tag in the page\n  */\n  function replaceYield(tmpl, html) {\n    // do nothing if no yield\n    if (!reHasYield.test(tmpl)) { return tmpl }\n\n    // be careful with #1343 - string on the source having `$1`\n    var src = {};\n\n    html = html && html.replace(reYieldSrc, function (_, ref, text) {\n      src[ref] = src[ref] || text;   // preserve first definition\n      return ''\n    }).trim();\n\n    return tmpl\n      .replace(reYieldDest, function (_, ref, def) {  // yield with from - to attrs\n        return src[ref] || def || ''\n      })\n      .replace(reYieldAll, function (_, def) {        // yield without any \"from\"\n        return html || def || ''\n      })\n  }\n\n  /**\n   * Creates a DOM element to wrap the given content. Normally an `DIV`, but can be\n   * also a `TABLE`, `SELECT`, `TBODY`, `TR`, or `COLGROUP` element.\n   *\n   * @param   { String } tmpl  - The template coming from the custom tag definition\n   * @param   { String } html - HTML content that comes from the DOM element where you\n   *           will mount the tag, mostly the original tag in the page\n   * @param   { Boolean } isSvg - true if the root node is an svg\n   * @returns { HTMLElement } DOM element with _tmpl_ merged through `YIELD` with the _html_.\n   */\n  function mkdom(tmpl, html, isSvg) {\n    var match   = tmpl && tmpl.match(/^\\s*<([-\\w]+)/);\n    var  tagName = match && match[1].toLowerCase();\n    var el = makeElement(isSvg ? SVG : GENERIC);\n\n    // replace all the yield tags with the tag inner html\n    tmpl = replaceYield(tmpl, html);\n\n    /* istanbul ignore next */\n    if (tblTags.test(tagName))\n      { el = specialTags(el, tmpl, tagName); }\n    else\n      { setInnerHTML(el, tmpl, isSvg); }\n\n    return el\n  }\n\n  var EVENT_ATTR_RE = /^on/;\n\n  /**\n   * True if the event attribute starts with 'on'\n   * @param   { String } attribute - event attribute\n   * @returns { Boolean }\n   */\n  function isEventAttribute(attribute) {\n    return EVENT_ATTR_RE.test(attribute)\n  }\n\n  /**\n   * Loop backward all the parents tree to detect the first custom parent tag\n   * @param   { Object } tag - a Tag instance\n   * @returns { Object } the instance of the first custom parent tag found\n   */\n  function getImmediateCustomParent(tag) {\n    var ptag = tag;\n    while (ptag.__.isAnonymous) {\n      if (!ptag.parent) { break }\n      ptag = ptag.parent;\n    }\n    return ptag\n  }\n\n  /**\n   * Trigger DOM events\n   * @param   { HTMLElement } dom - dom element target of the event\n   * @param   { Function } handler - user function\n   * @param   { Object } e - event object\n   */\n  function handleEvent(dom, handler, e) {\n    var ptag = this.__.parent;\n    var item = this.__.item;\n\n    if (!item)\n      { while (ptag && !item) {\n        item = ptag.__.item;\n        ptag = ptag.__.parent;\n      } }\n\n    // override the event properties\n    /* istanbul ignore next */\n    if (isWritable(e, 'currentTarget')) { e.currentTarget = dom; }\n    /* istanbul ignore next */\n    if (isWritable(e, 'target')) { e.target = e.srcElement; }\n    /* istanbul ignore next */\n    if (isWritable(e, 'which')) { e.which = e.charCode || e.keyCode; }\n\n    e.item = item;\n\n    handler.call(this, e);\n\n    // avoid auto updates\n    if (!settings.autoUpdate) { return }\n\n    if (!e.preventUpdate) {\n      var p = getImmediateCustomParent(this);\n      // fixes #2083\n      if (p.isMounted) { p.update(); }\n    }\n  }\n\n  /**\n   * Attach an event to a DOM node\n   * @param { String } name - event name\n   * @param { Function } handler - event callback\n   * @param { Object } dom - dom node\n   * @param { Tag } tag - tag instance\n   */\n  function setEventHandler(name, handler, dom, tag) {\n    var eventName;\n    var cb = handleEvent.bind(tag, dom, handler);\n\n    // avoid to bind twice the same event\n    // possible fix for #2332\n    dom[name] = null;\n\n    // normalize event name\n    eventName = name.replace(RE_EVENTS_PREFIX, '');\n\n    // cache the listener into the listeners array\n    if (!contains(tag.__.listeners, dom)) { tag.__.listeners.push(dom); }\n    if (!dom[RIOT_EVENTS_KEY]) { dom[RIOT_EVENTS_KEY] = {}; }\n    if (dom[RIOT_EVENTS_KEY][name]) { dom.removeEventListener(eventName, dom[RIOT_EVENTS_KEY][name]); }\n\n    dom[RIOT_EVENTS_KEY][name] = cb;\n    dom.addEventListener(eventName, cb, false);\n  }\n\n  /**\n   * Create a new child tag including it correctly into its parent\n   * @param   { Object } child - child tag implementation\n   * @param   { Object } opts - tag options containing the DOM node where the tag will be mounted\n   * @param   { String } innerHTML - inner html of the child node\n   * @param   { Object } parent - instance of the parent tag including the child custom tag\n   * @returns { Object } instance of the new child tag just created\n   */\n  function initChild(child, opts, innerHTML, parent) {\n    var tag = createTag(child, opts, innerHTML);\n    var tagName = opts.tagName || getName(opts.root, true);\n    var ptag = getImmediateCustomParent(parent);\n    // fix for the parent attribute in the looped elements\n    define(tag, 'parent', ptag);\n    // store the real parent tag\n    // in some cases this could be different from the custom parent tag\n    // for example in nested loops\n    tag.__.parent = parent;\n\n    // add this tag to the custom parent tag\n    arrayishAdd(ptag.tags, tagName, tag);\n\n    // and also to the real parent tag\n    if (ptag !== parent)\n      { arrayishAdd(parent.tags, tagName, tag); }\n\n    return tag\n  }\n\n  /**\n   * Removes an item from an object at a given key. If the key points to an array,\n   * then the item is just removed from the array.\n   * @param { Object } obj - object on which to remove the property\n   * @param { String } key - property name\n   * @param { Object } value - the value of the property to be removed\n   * @param { Boolean } ensureArray - ensure that the property remains an array\n  */\n  function arrayishRemove(obj, key, value, ensureArray) {\n    if (isArray(obj[key])) {\n      var index = obj[key].indexOf(value);\n      if (index !== -1) { obj[key].splice(index, 1); }\n      if (!obj[key].length) { delete obj[key]; }\n      else if (obj[key].length === 1 && !ensureArray) { obj[key] = obj[key][0]; }\n    } else if (obj[key] === value)\n      { delete obj[key]; } // otherwise just delete the key\n  }\n\n  /**\n   * Adds the elements for a virtual tag\n   * @this Tag\n   * @param { Node } src - the node that will do the inserting or appending\n   * @param { Tag } target - only if inserting, insert before this tag's first child\n   */\n  function makeVirtual(src, target) {\n    var this$1 = this;\n\n    var head = createDOMPlaceholder();\n    var tail = createDOMPlaceholder();\n    var frag = createFragment();\n    var sib;\n    var el;\n\n    this.root.insertBefore(head, this.root.firstChild);\n    this.root.appendChild(tail);\n\n    this.__.head = el = head;\n    this.__.tail = tail;\n\n    while (el) {\n      sib = el.nextSibling;\n      frag.appendChild(el);\n      this$1.__.virts.push(el); // hold for unmounting\n      el = sib;\n    }\n\n    if (target)\n      { src.insertBefore(frag, target.__.head); }\n    else\n      { src.appendChild(frag); }\n  }\n\n  /**\n   * makes a tag virtual and replaces a reference in the dom\n   * @this Tag\n   * @param { tag } the tag to make virtual\n   * @param { ref } the dom reference location\n   */\n  function makeReplaceVirtual(tag, ref) {\n    var frag = createFragment();\n    makeVirtual.call(tag, frag);\n    ref.parentNode.replaceChild(frag, ref);\n  }\n\n  /**\n   * Update dynamically created data-is tags with changing expressions\n   * @param { Object } expr - expression tag and expression info\n   * @param { Tag }    parent - parent for tag creation\n   * @param { String } tagName - tag implementation we want to use\n   */\n  function updateDataIs(expr, parent, tagName) {\n    var tag = expr.tag || expr.dom._tag;\n    var ref;\n\n    var ref$1 = tag ? tag.__ : {};\n    var head = ref$1.head;\n    var isVirtual = expr.dom.tagName === 'VIRTUAL';\n\n    if (tag && expr.tagName === tagName) {\n      tag.update();\n      return\n    }\n\n    // sync _parent to accommodate changing tagnames\n    if (tag) {\n      // need placeholder before unmount\n      if(isVirtual) {\n        ref = createDOMPlaceholder();\n        head.parentNode.insertBefore(ref, head);\n      }\n\n      tag.unmount(true);\n    }\n\n    // unable to get the tag name\n    if (!isString(tagName)) { return }\n\n    expr.impl = __TAG_IMPL[tagName];\n\n    // unknown implementation\n    if (!expr.impl) { return }\n\n    expr.tag = tag = initChild(\n      expr.impl, {\n        root: expr.dom,\n        parent: parent,\n        tagName: tagName\n      },\n      expr.dom.innerHTML,\n      parent\n    );\n\n    each(expr.attrs, function (a) { return setAttribute(tag.root, a.name, a.value); });\n    expr.tagName = tagName;\n    tag.mount();\n\n    // root exist first time, after use placeholder\n    if (isVirtual) { makeReplaceVirtual(tag, ref || tag.root); }\n\n    // parent is the placeholder tag, not the dynamic tag so clean up\n    parent.__.onUnmount = function () {\n      var delName = tag.opts.dataIs;\n      arrayishRemove(tag.parent.tags, delName, tag);\n      arrayishRemove(tag.__.parent.tags, delName, tag);\n      tag.unmount();\n    };\n  }\n\n  /**\n   * Nomalize any attribute removing the \"riot-\" prefix\n   * @param   { String } attrName - original attribute name\n   * @returns { String } valid html attribute name\n   */\n  function normalizeAttrName(attrName) {\n    if (!attrName) { return null }\n    attrName = attrName.replace(ATTRS_PREFIX, '');\n    if (CASE_SENSITIVE_ATTRIBUTES[attrName]) { attrName = CASE_SENSITIVE_ATTRIBUTES[attrName]; }\n    return attrName\n  }\n\n  /**\n   * Update on single tag expression\n   * @this Tag\n   * @param { Object } expr - expression logic\n   * @returns { undefined }\n   */\n  function updateExpression(expr) {\n    if (this.root && getAttribute(this.root,'virtualized')) { return }\n\n    var dom = expr.dom;\n    // remove the riot- prefix\n    var attrName = normalizeAttrName(expr.attr);\n    var isToggle = contains([SHOW_DIRECTIVE, HIDE_DIRECTIVE], attrName);\n    var isVirtual = expr.root && expr.root.tagName === 'VIRTUAL';\n    var ref = this.__;\n    var isAnonymous = ref.isAnonymous;\n    var parent = dom && (expr.parent || dom.parentNode);\n    // detect the style attributes\n    var isStyleAttr = attrName === 'style';\n    var isClassAttr = attrName === 'class';\n\n    var value;\n\n    // if it's a tag we could totally skip the rest\n    if (expr._riot_id) {\n      if (expr.__.wasCreated) {\n        expr.update();\n      // if it hasn't been mounted yet, do that now.\n      } else {\n        expr.mount();\n        if (isVirtual) {\n          makeReplaceVirtual(expr, expr.root);\n        }\n      }\n      return\n    }\n\n    // if this expression has the update method it means it can handle the DOM changes by itself\n    if (expr.update) { return expr.update() }\n\n    var context = isToggle && !isAnonymous ? inheritParentProps.call(this) : this;\n\n    // ...it seems to be a simple expression so we try to calculate its value\n    value = tmpl(expr.expr, context);\n\n    var hasValue = !isBlank(value);\n    var isObj = isObject(value);\n\n    // convert the style/class objects to strings\n    if (isObj) {\n      if (isClassAttr) {\n        value = tmpl(JSON.stringify(value), this);\n      } else if (isStyleAttr) {\n        value = styleObjectToString(value);\n      }\n    }\n\n    // remove original attribute\n    if (expr.attr && (!expr.wasParsedOnce || !hasValue || value === false)) {\n      // remove either riot-* attributes or just the attribute name\n      removeAttribute(dom, getAttribute(dom, expr.attr) ? expr.attr : attrName);\n    }\n\n    // for the boolean attributes we don't need the value\n    // we can convert it to checked=true to checked=checked\n    if (expr.bool) { value = value ? attrName : false; }\n    if (expr.isRtag) { return updateDataIs(expr, this, value) }\n    if (expr.wasParsedOnce && expr.value === value) { return }\n\n    // update the expression value\n    expr.value = value;\n    expr.wasParsedOnce = true;\n\n    // if the value is an object (and it's not a style or class attribute) we can not do much more with it\n    if (isObj && !isClassAttr && !isStyleAttr && !isToggle) { return }\n    // avoid to render undefined/null values\n    if (!hasValue) { value = ''; }\n\n    // textarea and text nodes have no attribute name\n    if (!attrName) {\n      // about #815 w/o replace: the browser converts the value to a string,\n      // the comparison by \"==\" does too, but not in the server\n      value += '';\n      // test for parent avoids error with invalid assignment to nodeValue\n      if (parent) {\n        // cache the parent node because somehow it will become null on IE\n        // on the next iteration\n        expr.parent = parent;\n        if (parent.tagName === 'TEXTAREA') {\n          parent.value = value;                    // #1113\n          if (!IE_VERSION) { dom.nodeValue = value; }  // #1625 IE throws here, nodeValue\n        }                                         // will be available on 'updated'\n        else { dom.nodeValue = value; }\n      }\n      return\n    }\n\n    switch (true) {\n    // handle events binding\n    case isFunction(value):\n      if (isEventAttribute(attrName)) {\n        setEventHandler(attrName, value, dom, this);\n      }\n      break\n    // show / hide\n    case isToggle:\n      toggleVisibility(dom, attrName === HIDE_DIRECTIVE ? !value : value);\n      break\n    // handle attributes\n    default:\n      if (expr.bool) {\n        dom[attrName] = value;\n      }\n\n      if (attrName === 'value' && dom.value !== value) {\n        dom.value = value;\n      } else if (hasValue && value !== false) {\n        setAttribute(dom, attrName, value);\n      }\n\n      // make sure that in case of style changes\n      // the element stays hidden\n      if (isStyleAttr && dom.hidden) { toggleVisibility(dom, false); }\n    }\n  }\n\n  /**\n   * Update all the expressions in a Tag instance\n   * @this Tag\n   * @param { Array } expressions - expression that must be re evaluated\n   */\n  function update(expressions) {\n    each(expressions, updateExpression.bind(this));\n  }\n\n  /**\n   * We need to update opts for this tag. That requires updating the expressions\n   * in any attributes on the tag, and then copying the result onto opts.\n   * @this Tag\n   * @param   {Boolean} isLoop - is it a loop tag?\n   * @param   { Tag }  parent - parent tag node\n   * @param   { Boolean }  isAnonymous - is it a tag without any impl? (a tag not registered)\n   * @param   { Object }  opts - tag options\n   * @param   { Array }  instAttrs - tag attributes array\n   */\n  function updateOpts(isLoop, parent, isAnonymous, opts, instAttrs) {\n    // isAnonymous `each` tags treat `dom` and `root` differently. In this case\n    // (and only this case) we don't need to do updateOpts, because the regular parse\n    // will update those attrs. Plus, isAnonymous tags don't need opts anyway\n    if (isLoop && isAnonymous) { return }\n    var ctx = isLoop ? inheritParentProps.call(this) : parent || this;\n\n    each(instAttrs, function (attr) {\n      if (attr.expr) { updateExpression.call(ctx, attr.expr); }\n      // normalize the attribute names\n      opts[toCamel(attr.name).replace(ATTRS_PREFIX, '')] = attr.expr ? attr.expr.value : attr.value;\n    });\n  }\n\n  /**\n   * Update the tag expressions and options\n   * @param { Tag } tag - tag object\n   * @param { * } data - data we want to use to extend the tag properties\n   * @param { Array } expressions - component expressions array\n   * @returns { Tag } the current tag instance\n   */\n  function componentUpdate(tag, data, expressions) {\n    var __ = tag.__;\n    var nextOpts = {};\n    var canTrigger = tag.isMounted && !__.skipAnonymous;\n\n    // inherit properties from the parent tag\n    if (__.isAnonymous && __.parent) { extend(tag, __.parent); }\n    extend(tag, data);\n\n    updateOpts.apply(tag, [__.isLoop, __.parent, __.isAnonymous, nextOpts, __.instAttrs]);\n\n    if (\n      canTrigger &&\n      tag.isMounted &&\n      isFunction(tag.shouldUpdate) && !tag.shouldUpdate(data, nextOpts)\n    ) {\n      return tag\n    }\n\n    extend(tag.opts, nextOpts);\n\n    if (canTrigger) { tag.trigger('update', data); }\n    update.call(tag, expressions);\n    if (canTrigger) { tag.trigger('updated'); }\n\n    return tag\n  }\n\n  /**\n   * Get selectors for tags\n   * @param   { Array } tags - tag names to select\n   * @returns { String } selector\n   */\n  function query(tags) {\n    // select all tags\n    if (!tags) {\n      var keys = Object.keys(__TAG_IMPL);\n      return keys + query(keys)\n    }\n\n    return tags\n      .filter(function (t) { return !/[^-\\w]/.test(t); })\n      .reduce(function (list, t) {\n        var name = t.trim().toLowerCase();\n        return list + \",[\" + IS_DIRECTIVE + \"=\\\"\" + name + \"\\\"]\"\n      }, '')\n  }\n\n  /**\n   * Another way to create a riot tag a bit more es6 friendly\n   * @param { HTMLElement } el - tag DOM selector or DOM node/s\n   * @param { Object } opts - tag logic\n   * @returns { Tag } new riot tag instance\n   */\n  function Tag(el, opts) {\n    // get the tag properties from the class constructor\n    var ref = this;\n    var name = ref.name;\n    var tmpl = ref.tmpl;\n    var css = ref.css;\n    var attrs = ref.attrs;\n    var onCreate = ref.onCreate;\n    // register a new tag and cache the class prototype\n    if (!__TAG_IMPL[name]) {\n      tag(name, tmpl, css, attrs, onCreate);\n      // cache the class constructor\n      __TAG_IMPL[name].class = this.constructor;\n    }\n\n    // mount the tag using the class instance\n    mount$1(el, name, opts, this);\n    // inject the component css\n    if (css) { styleManager.inject(); }\n\n    return this\n  }\n\n  /**\n   * Create a new riot tag implementation\n   * @param   { String }   name - name/id of the new riot tag\n   * @param   { String }   tmpl - tag template\n   * @param   { String }   css - custom tag css\n   * @param   { String }   attrs - root tag attributes\n   * @param   { Function } fn - user function\n   * @returns { String } name/id of the tag just created\n   */\n  function tag(name, tmpl, css, attrs, fn) {\n    if (isFunction(attrs)) {\n      fn = attrs;\n\n      if (/^[\\w-]+\\s?=/.test(css)) {\n        attrs = css;\n        css = '';\n      } else\n        { attrs = ''; }\n    }\n\n    if (css) {\n      if (isFunction(css))\n        { fn = css; }\n      else\n        { styleManager.add(css, name); }\n    }\n\n    name = name.toLowerCase();\n    __TAG_IMPL[name] = { name: name, tmpl: tmpl, attrs: attrs, fn: fn };\n\n    return name\n  }\n\n  /**\n   * Create a new riot tag implementation (for use by the compiler)\n   * @param   { String }   name - name/id of the new riot tag\n   * @param   { String }   tmpl - tag template\n   * @param   { String }   css - custom tag css\n   * @param   { String }   attrs - root tag attributes\n   * @param   { Function } fn - user function\n   * @returns { String } name/id of the tag just created\n   */\n  function tag2(name, tmpl, css, attrs, fn) {\n    if (css) { styleManager.add(css, name); }\n\n    __TAG_IMPL[name] = { name: name, tmpl: tmpl, attrs: attrs, fn: fn };\n\n    return name\n  }\n\n  /**\n   * Mount a tag using a specific tag implementation\n   * @param   { * } selector - tag DOM selector or DOM node/s\n   * @param   { String } tagName - tag implementation name\n   * @param   { Object } opts - tag logic\n   * @returns { Array } new tags instances\n   */\n  function mount(selector, tagName, opts) {\n    var tags = [];\n    var elem, allTags;\n\n    function pushTagsTo(root) {\n      if (root.tagName) {\n        var riotTag = getAttribute(root, IS_DIRECTIVE), tag;\n\n        // have tagName? force riot-tag to be the same\n        if (tagName && riotTag !== tagName) {\n          riotTag = tagName;\n          setAttribute(root, IS_DIRECTIVE, tagName);\n        }\n\n        tag = mount$1(root, riotTag || root.tagName.toLowerCase(), opts);\n\n        if (tag)\n          { tags.push(tag); }\n      } else if (root.length)\n        { each(root, pushTagsTo); } // assume nodeList\n    }\n\n    // inject styles into DOM\n    styleManager.inject();\n\n    if (isObject(tagName)) {\n      opts = tagName;\n      tagName = 0;\n    }\n\n    // crawl the DOM to find the tag\n    if (isString(selector)) {\n      selector = selector === '*' ?\n        // select all registered tags\n        // & tags found with the riot-tag attribute set\n        allTags = query() :\n        // or just the ones named like the selector\n        selector + query(selector.split(/, */));\n\n      // make sure to pass always a selector\n      // to the querySelectorAll function\n      elem = selector ? $$(selector) : [];\n    }\n    else\n      // probably you have passed already a tag or a NodeList\n      { elem = selector; }\n\n    // select all the registered and mount them inside their root elements\n    if (tagName === '*') {\n      // get all custom tags\n      tagName = allTags || query();\n      // if the root els it's just a single tag\n      if (elem.tagName)\n        { elem = $$(tagName, elem); }\n      else {\n        // select all the children for all the different root elements\n        var nodeList = [];\n\n        each(elem, function (_el) { return nodeList.push($$(tagName, _el)); });\n\n        elem = nodeList;\n      }\n      // get rid of the tagName\n      tagName = 0;\n    }\n\n    pushTagsTo(elem);\n\n    return tags\n  }\n\n  // Create a mixin that could be globally shared across all the tags\n  var mixins = {};\n  var globals = mixins[GLOBAL_MIXIN] = {};\n  var mixins_id = 0;\n\n  /**\n   * Create/Return a mixin by its name\n   * @param   { String }  name - mixin name (global mixin if object)\n   * @param   { Object }  mix - mixin logic\n   * @param   { Boolean } g - is global?\n   * @returns { Object }  the mixin logic\n   */\n  function mixin(name, mix, g) {\n    // Unnamed global\n    if (isObject(name)) {\n      mixin((\"__\" + (mixins_id++) + \"__\"), name, true);\n      return\n    }\n\n    var store = g ? globals : mixins;\n\n    // Getter\n    if (!mix) {\n      if (isUndefined(store[name]))\n        { throw new Error((\"Unregistered mixin: \" + name)) }\n\n      return store[name]\n    }\n\n    // Setter\n    store[name] = isFunction(mix) ?\n      extend(mix.prototype, store[name] || {}) && mix :\n      extend(store[name] || {}, mix);\n  }\n\n  /**\n   * Update all the tags instances created\n   * @returns { Array } all the tags instances\n   */\n  function update$1() {\n    return each(__TAGS_CACHE, function (tag) { return tag.update(); })\n  }\n\n  function unregister(name) {\n    styleManager.remove(name);\n    return delete __TAG_IMPL[name]\n  }\n\n  var version = 'v3.10.2';\n\n  var core = /*#__PURE__*/Object.freeze({\n    Tag: Tag,\n    tag: tag,\n    tag2: tag2,\n    mount: mount,\n    mixin: mixin,\n    update: update$1,\n    unregister: unregister,\n    version: version\n  });\n\n  /**\n   * Add a mixin to this tag\n   * @returns { Tag } the current tag instance\n   */\n  function componentMixin(tag$$1) {\n    var mixins = [], len = arguments.length - 1;\n    while ( len-- > 0 ) mixins[ len ] = arguments[ len + 1 ];\n\n    each(mixins, function (mix) {\n      var instance;\n      var obj;\n      var props = [];\n\n      // properties blacklisted and will not be bound to the tag instance\n      var propsBlacklist = ['init', '__proto__'];\n\n      mix = isString(mix) ? mixin(mix) : mix;\n\n      // check if the mixin is a function\n      if (isFunction(mix)) {\n        // create the new mixin instance\n        instance = new mix();\n      } else { instance = mix; }\n\n      var proto = Object.getPrototypeOf(instance);\n\n      // build multilevel prototype inheritance chain property list\n      do { props = props.concat(Object.getOwnPropertyNames(obj || instance)); }\n      while (obj = Object.getPrototypeOf(obj || instance))\n\n      // loop the keys in the function prototype or the all object keys\n      each(props, function (key) {\n        // bind methods to tag\n        // allow mixins to override other properties/parent mixins\n        if (!contains(propsBlacklist, key)) {\n          // check for getters/setters\n          var descriptor = getPropDescriptor(instance, key) || getPropDescriptor(proto, key);\n          var hasGetterSetter = descriptor && (descriptor.get || descriptor.set);\n\n          // apply method only if it does not already exist on the instance\n          if (!tag$$1.hasOwnProperty(key) && hasGetterSetter) {\n            Object.defineProperty(tag$$1, key, descriptor);\n          } else {\n            tag$$1[key] = isFunction(instance[key]) ?\n              instance[key].bind(tag$$1) :\n              instance[key];\n          }\n        }\n      });\n\n      // init method will be called automatically\n      if (instance.init)\n        { instance.init.bind(tag$$1)(tag$$1.opts); }\n    });\n\n    return tag$$1\n  }\n\n  /**\n   * Move the position of a custom tag in its parent tag\n   * @this Tag\n   * @param   { String } tagName - key where the tag was stored\n   * @param   { Number } newPos - index where the new tag will be stored\n   */\n  function moveChild(tagName, newPos) {\n    var parent = this.parent;\n    var tags;\n    // no parent no move\n    if (!parent) { return }\n\n    tags = parent.tags[tagName];\n\n    if (isArray(tags))\n      { tags.splice(newPos, 0, tags.splice(tags.indexOf(this), 1)[0]); }\n    else { arrayishAdd(parent.tags, tagName, this); }\n  }\n\n  /**\n   * Move virtual tag and all child nodes\n   * @this Tag\n   * @param { Node } src  - the node that will do the inserting\n   * @param { Tag } target - insert before this tag's first child\n   */\n  function moveVirtual(src, target) {\n    var this$1 = this;\n\n    var el = this.__.head;\n    var sib;\n    var frag = createFragment();\n\n    while (el) {\n      sib = el.nextSibling;\n      frag.appendChild(el);\n      el = sib;\n      if (el === this$1.__.tail) {\n        frag.appendChild(el);\n        src.insertBefore(frag, target.__.head);\n        break\n      }\n    }\n  }\n\n  /**\n   * Convert the item looped into an object used to extend the child tag properties\n   * @param   { Object } expr - object containing the keys used to extend the children tags\n   * @param   { * } key - value to assign to the new object returned\n   * @param   { * } val - value containing the position of the item in the array\n   * @returns { Object } - new object containing the values of the original item\n   *\n   * The variables 'key' and 'val' are arbitrary.\n   * They depend on the collection type looped (Array, Object)\n   * and on the expression used on the each tag\n   *\n   */\n  function mkitem(expr, key, val) {\n    var item = {};\n    item[expr.key] = key;\n    if (expr.pos) { item[expr.pos] = val; }\n    return item\n  }\n\n  /**\n   * Unmount the redundant tags\n   * @param   { Array } items - array containing the current items to loop\n   * @param   { Array } tags - array containing all the children tags\n   */\n  function unmountRedundant(items, tags, filteredItemsCount) {\n    var i = tags.length;\n    var j = items.length - filteredItemsCount;\n\n    while (i > j) {\n      i--;\n      remove.apply(tags[i], [tags, i]);\n    }\n  }\n\n\n  /**\n   * Remove a child tag\n   * @this Tag\n   * @param   { Array } tags - tags collection\n   * @param   { Number } i - index of the tag to remove\n   */\n  function remove(tags, i) {\n    tags.splice(i, 1);\n    this.unmount();\n    arrayishRemove(this.parent, this, this.__.tagName, true);\n  }\n\n  /**\n   * Move the nested custom tags in non custom loop tags\n   * @this Tag\n   * @param   { Number } i - current position of the loop tag\n   */\n  function moveNestedTags(i) {\n    var this$1 = this;\n\n    each(Object.keys(this.tags), function (tagName) {\n      moveChild.apply(this$1.tags[tagName], [tagName, i]);\n    });\n  }\n\n  /**\n   * Move a child tag\n   * @this Tag\n   * @param   { HTMLElement } root - dom node containing all the loop children\n   * @param   { Tag } nextTag - instance of the next tag preceding the one we want to move\n   * @param   { Boolean } isVirtual - is it a virtual tag?\n   */\n  function move(root, nextTag, isVirtual) {\n    if (isVirtual)\n      { moveVirtual.apply(this, [root, nextTag]); }\n    else\n      { safeInsert(root, this.root, nextTag.root); }\n  }\n\n  /**\n   * Insert and mount a child tag\n   * @this Tag\n   * @param   { HTMLElement } root - dom node containing all the loop children\n   * @param   { Tag } nextTag - instance of the next tag preceding the one we want to insert\n   * @param   { Boolean } isVirtual - is it a virtual tag?\n   */\n  function insert(root, nextTag, isVirtual) {\n    if (isVirtual)\n      { makeVirtual.apply(this, [root, nextTag]); }\n    else\n      { safeInsert(root, this.root, nextTag.root); }\n  }\n\n  /**\n   * Append a new tag into the DOM\n   * @this Tag\n   * @param   { HTMLElement } root - dom node containing all the loop children\n   * @param   { Boolean } isVirtual - is it a virtual tag?\n   */\n  function append(root, isVirtual) {\n    if (isVirtual)\n      { makeVirtual.call(this, root); }\n    else\n      { root.appendChild(this.root); }\n  }\n\n  /**\n   * Return the value we want to use to lookup the postion of our items in the collection\n   * @param   { String }  keyAttr         - lookup string or expression\n   * @param   { * }       originalItem    - original item from the collection\n   * @param   { Object }  keyedItem       - object created by riot via { item, i in collection }\n   * @param   { Boolean } hasKeyAttrExpr  - flag to check whether the key is an expression\n   * @returns { * } value that we will use to figure out the item position via collection.indexOf\n   */\n  function getItemId(keyAttr, originalItem, keyedItem, hasKeyAttrExpr) {\n    if (keyAttr) {\n      return hasKeyAttrExpr ?  tmpl(keyAttr, keyedItem) :  originalItem[keyAttr]\n    }\n\n    return originalItem\n  }\n\n  /**\n   * Manage tags having the 'each'\n   * @param   { HTMLElement } dom - DOM node we need to loop\n   * @param   { Tag } parent - parent tag instance where the dom node is contained\n   * @param   { String } expr - string contained in the 'each' attribute\n   * @returns { Object } expression object for this each loop\n   */\n  function _each(dom, parent, expr) {\n    var mustReorder = typeof getAttribute(dom, LOOP_NO_REORDER_DIRECTIVE) !== T_STRING || removeAttribute(dom, LOOP_NO_REORDER_DIRECTIVE);\n    var keyAttr = getAttribute(dom, KEY_DIRECTIVE);\n    var hasKeyAttrExpr = keyAttr ? tmpl.hasExpr(keyAttr) : false;\n    var tagName = getName(dom);\n    var impl = __TAG_IMPL[tagName];\n    var parentNode = dom.parentNode;\n    var placeholder = createDOMPlaceholder();\n    var child = get(dom);\n    var ifExpr = getAttribute(dom, CONDITIONAL_DIRECTIVE);\n    var tags = [];\n    var isLoop = true;\n    var innerHTML = dom.innerHTML;\n    var isAnonymous = !__TAG_IMPL[tagName];\n    var isVirtual = dom.tagName === 'VIRTUAL';\n    var oldItems = [];\n\n    // remove the each property from the original tag\n    removeAttribute(dom, LOOP_DIRECTIVE);\n    removeAttribute(dom, KEY_DIRECTIVE);\n\n    // parse the each expression\n    expr = tmpl.loopKeys(expr);\n    expr.isLoop = true;\n\n    if (ifExpr) { removeAttribute(dom, CONDITIONAL_DIRECTIVE); }\n\n    // insert a marked where the loop tags will be injected\n    parentNode.insertBefore(placeholder, dom);\n    parentNode.removeChild(dom);\n\n    expr.update = function updateEach() {\n      // get the new items collection\n      expr.value = tmpl(expr.val, parent);\n\n      var items = expr.value;\n      var frag = createFragment();\n      var isObject = !isArray(items) && !isString(items);\n      var root = placeholder.parentNode;\n      var tmpItems = [];\n      var hasKeys = isObject && !!items;\n\n      // if this DOM was removed the update here is useless\n      // this condition fixes also a weird async issue on IE in our unit test\n      if (!root) { return }\n\n      // object loop. any changes cause full redraw\n      if (isObject) {\n        items = items ? Object.keys(items).map(function (key) { return mkitem(expr, items[key], key); }) : [];\n      }\n\n      // store the amount of filtered items\n      var filteredItemsCount = 0;\n\n      // loop all the new items\n      each(items, function (_item, i) {\n        i -= filteredItemsCount;\n\n        var item = !hasKeys && expr.key ? mkitem(expr, _item, i) : _item;\n\n        // skip this item because it must be filtered\n        if (ifExpr && !tmpl(ifExpr, extend(create(parent), item))) {\n          filteredItemsCount ++;\n          return\n        }\n\n        var itemId = getItemId(keyAttr, _item, item, hasKeyAttrExpr);\n        // reorder only if the items are not objects\n        // or a key attribute has been provided\n        var doReorder = !isObject && mustReorder && typeof _item === T_OBJECT || keyAttr;\n        var oldPos = oldItems.indexOf(itemId);\n        var isNew = oldPos === -1;\n        var pos = !isNew && doReorder ? oldPos : i;\n        // does a tag exist in this position?\n        var tag = tags[pos];\n        var mustAppend = i >= oldItems.length;\n        var mustCreate = doReorder && isNew || !doReorder && !tag || !tags[i];\n\n        // new tag\n        if (mustCreate) {\n          tag = createTag(impl, {\n            parent: parent,\n            isLoop: isLoop,\n            isAnonymous: isAnonymous,\n            tagName: tagName,\n            root: dom.cloneNode(isAnonymous),\n            item: item,\n            index: i,\n          }, innerHTML);\n\n          // mount the tag\n          tag.mount();\n\n          if (mustAppend)\n            { append.apply(tag, [frag || root, isVirtual]); }\n          else\n            { insert.apply(tag, [root, tags[i], isVirtual]); }\n\n          if (!mustAppend) { oldItems.splice(i, 0, item); }\n          tags.splice(i, 0, tag);\n          if (child) { arrayishAdd(parent.tags, tagName, tag, true); }\n        } else if (pos !== i && doReorder) {\n          // move\n          if (keyAttr || contains(items, oldItems[pos])) {\n            move.apply(tag, [root, tags[i], isVirtual]);\n            // move the old tag instance\n            tags.splice(i, 0, tags.splice(pos, 1)[0]);\n            // move the old item\n            oldItems.splice(i, 0, oldItems.splice(pos, 1)[0]);\n          }\n\n          // update the position attribute if it exists\n          if (expr.pos) { tag[expr.pos] = i; }\n\n          // if the loop tags are not custom\n          // we need to move all their custom tags into the right position\n          if (!child && tag.tags) { moveNestedTags.call(tag, i); }\n        }\n\n        // cache the original item to use it in the events bound to this node\n        // and its children\n        extend(tag.__, {\n          item: item,\n          index: i,\n          parent: parent\n        });\n\n        tmpItems[i] = itemId;\n\n        if (!mustCreate) { tag.update(item); }\n      });\n\n      // remove the redundant tags\n      unmountRedundant(items, tags, filteredItemsCount);\n\n      // clone the items array\n      oldItems = tmpItems.slice();\n\n      root.insertBefore(frag, placeholder);\n    };\n\n    expr.unmount = function () {\n      each(tags, function (t) { t.unmount(); });\n    };\n\n    return expr\n  }\n\n  var RefExpr = {\n    init: function init(dom, parent, attrName, attrValue) {\n      this.dom = dom;\n      this.attr = attrName;\n      this.rawValue = attrValue;\n      this.parent = parent;\n      this.hasExp = tmpl.hasExpr(attrValue);\n      return this\n    },\n    update: function update() {\n      var old = this.value;\n      var customParent = this.parent && getImmediateCustomParent(this.parent);\n      // if the referenced element is a custom tag, then we set the tag itself, rather than DOM\n      var tagOrDom = this.dom.__ref || this.tag || this.dom;\n\n      this.value = this.hasExp ? tmpl(this.rawValue, this.parent) : this.rawValue;\n\n      // the name changed, so we need to remove it from the old key (if present)\n      if (!isBlank(old) && customParent) { arrayishRemove(customParent.refs, old, tagOrDom); }\n      if (!isBlank(this.value) && isString(this.value)) {\n        // add it to the refs of parent tag (this behavior was changed >=3.0)\n        if (customParent) { arrayishAdd(\n          customParent.refs,\n          this.value,\n          tagOrDom,\n          // use an array if it's a looped node and the ref is not an expression\n          null,\n          this.parent.__.index\n        ); }\n\n        if (this.value !== old) {\n          setAttribute(this.dom, this.attr, this.value);\n        }\n      } else {\n        removeAttribute(this.dom, this.attr);\n      }\n\n      // cache the ref bound to this dom node\n      // to reuse it in future (see also #2329)\n      if (!this.dom.__ref) { this.dom.__ref = tagOrDom; }\n    },\n    unmount: function unmount() {\n      var tagOrDom = this.tag || this.dom;\n      var customParent = this.parent && getImmediateCustomParent(this.parent);\n      if (!isBlank(this.value) && customParent)\n        { arrayishRemove(customParent.refs, this.value, tagOrDom); }\n    }\n  }\n\n  /**\n   * Create a new ref directive\n   * @param   { HTMLElement } dom - dom node having the ref attribute\n   * @param   { Tag } context - tag instance where the DOM node is located\n   * @param   { String } attrName - either 'ref' or 'data-ref'\n   * @param   { String } attrValue - value of the ref attribute\n   * @returns { RefExpr } a new RefExpr object\n   */\n  function createRefDirective(dom, tag, attrName, attrValue) {\n    return create(RefExpr).init(dom, tag, attrName, attrValue)\n  }\n\n  /**\n   * Trigger the unmount method on all the expressions\n   * @param   { Array } expressions - DOM expressions\n   */\n  function unmountAll(expressions) {\n    each(expressions, function (expr) {\n      if (expr.unmount) { expr.unmount(true); }\n      else if (expr.tagName) { expr.tag.unmount(true); }\n      else if (expr.unmount) { expr.unmount(); }\n    });\n  }\n\n  var IfExpr = {\n    init: function init(dom, tag, expr) {\n      removeAttribute(dom, CONDITIONAL_DIRECTIVE);\n      extend(this, { tag: tag, expr: expr, stub: createDOMPlaceholder(), pristine: dom });\n      var p = dom.parentNode;\n      p.insertBefore(this.stub, dom);\n      p.removeChild(dom);\n\n      return this\n    },\n    update: function update$$1() {\n      this.value = tmpl(this.expr, this.tag);\n\n      if (this.value && !this.current) { // insert\n        this.current = this.pristine.cloneNode(true);\n        this.stub.parentNode.insertBefore(this.current, this.stub);\n        this.expressions = parseExpressions.apply(this.tag, [this.current, true]);\n      } else if (!this.value && this.current) { // remove\n        this.unmount();\n        this.current = null;\n        this.expressions = [];\n      }\n\n      if (this.value) { update.call(this.tag, this.expressions); }\n    },\n    unmount: function unmount() {\n      if (this.current) {\n        if (this.current._tag) {\n          this.current._tag.unmount();\n        } else if (this.current.parentNode) {\n          this.current.parentNode.removeChild(this.current);\n        }\n      }\n\n      unmountAll(this.expressions || []);\n    }\n  }\n\n  /**\n   * Create a new if directive\n   * @param   { HTMLElement } dom - if root dom node\n   * @param   { Tag } context - tag instance where the DOM node is located\n   * @param   { String } attr - if expression\n   * @returns { IFExpr } a new IfExpr object\n   */\n  function createIfDirective(dom, tag, attr) {\n    return create(IfExpr).init(dom, tag, attr)\n  }\n\n  /**\n   * Walk the tag DOM to detect the expressions to evaluate\n   * @this Tag\n   * @param   { HTMLElement } root - root tag where we will start digging the expressions\n   * @param   { Boolean } mustIncludeRoot - flag to decide whether the root must be parsed as well\n   * @returns { Array } all the expressions found\n   */\n  function parseExpressions(root, mustIncludeRoot) {\n    var this$1 = this;\n\n    var expressions = [];\n\n    walkNodes(root, function (dom) {\n      var type = dom.nodeType;\n      var attr;\n      var tagImpl;\n\n      if (!mustIncludeRoot && dom === root) { return }\n\n      // text node\n      if (type === 3 && dom.parentNode.tagName !== 'STYLE' && tmpl.hasExpr(dom.nodeValue))\n        { expressions.push({dom: dom, expr: dom.nodeValue}); }\n\n      if (type !== 1) { return }\n\n      var isVirtual = dom.tagName === 'VIRTUAL';\n\n      // loop. each does it's own thing (for now)\n      if (attr = getAttribute(dom, LOOP_DIRECTIVE)) {\n        if(isVirtual) { setAttribute(dom, 'loopVirtual', true); } // ignore here, handled in _each\n        expressions.push(_each(dom, this$1, attr));\n        return false\n      }\n\n      // if-attrs become the new parent. Any following expressions (either on the current\n      // element, or below it) become children of this expression.\n      if (attr = getAttribute(dom, CONDITIONAL_DIRECTIVE)) {\n        expressions.push(createIfDirective(dom, this$1, attr));\n        return false\n      }\n\n      if (attr = getAttribute(dom, IS_DIRECTIVE)) {\n        if (tmpl.hasExpr(attr)) {\n          expressions.push({\n            isRtag: true,\n            expr: attr,\n            dom: dom,\n            attrs: [].slice.call(dom.attributes)\n          });\n\n          return false\n        }\n      }\n\n      // if this is a tag, stop traversing here.\n      // we ignore the root, since parseExpressions is called while we're mounting that root\n      tagImpl = get(dom);\n\n      if(isVirtual) {\n        if(getAttribute(dom, 'virtualized')) {dom.parentElement.removeChild(dom); } // tag created, remove from dom\n        if(!tagImpl && !getAttribute(dom, 'virtualized') && !getAttribute(dom, 'loopVirtual'))  // ok to create virtual tag\n          { tagImpl = { tmpl: dom.outerHTML }; }\n      }\n\n      if (tagImpl && (dom !== root || mustIncludeRoot)) {\n        var hasIsDirective = getAttribute(dom, IS_DIRECTIVE);\n        if(isVirtual && !hasIsDirective) { // handled in update\n          // can not remove attribute like directives\n          // so flag for removal after creation to prevent maximum stack error\n          setAttribute(dom, 'virtualized', true);\n          var tag = createTag(\n            {tmpl: dom.outerHTML},\n            {root: dom, parent: this$1},\n            dom.innerHTML\n          );\n\n          expressions.push(tag); // no return, anonymous tag, keep parsing\n        } else {\n          if (hasIsDirective && isVirtual)\n            { warn((\"Virtual tags shouldn't be used together with the \\\"\" + IS_DIRECTIVE + \"\\\" attribute - https://github.com/riot/riot/issues/2511\")); }\n\n          expressions.push(\n            initChild(\n              tagImpl,\n              {\n                root: dom,\n                parent: this$1\n              },\n              dom.innerHTML,\n              this$1\n            )\n          );\n          return false\n        }\n      }\n\n      // attribute expressions\n      parseAttributes.apply(this$1, [dom, dom.attributes, function (attr, expr) {\n        if (!expr) { return }\n        expressions.push(expr);\n      }]);\n    });\n\n    return expressions\n  }\n\n  /**\n   * Calls `fn` for every attribute on an element. If that attr has an expression,\n   * it is also passed to fn.\n   * @this Tag\n   * @param   { HTMLElement } dom - dom node to parse\n   * @param   { Array } attrs - array of attributes\n   * @param   { Function } fn - callback to exec on any iteration\n   */\n  function parseAttributes(dom, attrs, fn) {\n    var this$1 = this;\n\n    each(attrs, function (attr) {\n      if (!attr) { return false }\n\n      var name = attr.name;\n      var bool = isBoolAttr(name);\n      var expr;\n\n      if (contains(REF_DIRECTIVES, name) && dom.tagName.toLowerCase() !== YIELD_TAG) {\n        expr =  createRefDirective(dom, this$1, name, attr.value);\n      } else if (tmpl.hasExpr(attr.value)) {\n        expr = {dom: dom, expr: attr.value, attr: name, bool: bool};\n      }\n\n      fn(attr, expr);\n    });\n  }\n\n  /**\n   * Manage the mount state of a tag triggering also the observable events\n   * @this Tag\n   * @param { Boolean } value - ..of the isMounted flag\n   */\n  function setMountState(value) {\n    var ref = this.__;\n    var isAnonymous = ref.isAnonymous;\n\n    define(this, 'isMounted', value);\n\n    if (!isAnonymous) {\n      if (value) { this.trigger('mount'); }\n      else {\n        this.trigger('unmount');\n        this.off('*');\n        this.__.wasCreated = false;\n      }\n    }\n  }\n\n  /**\n   * Mount the current tag instance\n   * @returns { Tag } the current tag instance\n   */\n  function componentMount(tag$$1, dom, expressions, opts) {\n    var __ = tag$$1.__;\n    var root = __.root;\n    root._tag = tag$$1; // keep a reference to the tag just created\n\n    // Read all the attrs on this instance. This give us the info we need for updateOpts\n    parseAttributes.apply(__.parent, [root, root.attributes, function (attr, expr) {\n      if (!__.isAnonymous && RefExpr.isPrototypeOf(expr)) { expr.tag = tag$$1; }\n      attr.expr = expr;\n      __.instAttrs.push(attr);\n    }]);\n\n    // update the root adding custom attributes coming from the compiler\n    walkAttributes(__.impl.attrs, function (k, v) { __.implAttrs.push({name: k, value: v}); });\n    parseAttributes.apply(tag$$1, [root, __.implAttrs, function (attr, expr) {\n      if (expr) { expressions.push(expr); }\n      else { setAttribute(root, attr.name, attr.value); }\n    }]);\n\n    // initialiation\n    updateOpts.apply(tag$$1, [__.isLoop, __.parent, __.isAnonymous, opts, __.instAttrs]);\n\n    // add global mixins\n    var globalMixin = mixin(GLOBAL_MIXIN);\n\n    if (globalMixin && !__.skipAnonymous) {\n      for (var i in globalMixin) {\n        if (globalMixin.hasOwnProperty(i)) {\n          tag$$1.mixin(globalMixin[i]);\n        }\n      }\n    }\n\n    if (__.impl.fn) { __.impl.fn.call(tag$$1, opts); }\n\n    if (!__.skipAnonymous) { tag$$1.trigger('before-mount'); }\n\n    // parse layout after init. fn may calculate args for nested custom tags\n    each(parseExpressions.apply(tag$$1, [dom, __.isAnonymous]), function (e) { return expressions.push(e); });\n\n    tag$$1.update(__.item);\n\n    if (!__.isAnonymous && !__.isInline) {\n      while (dom.firstChild) { root.appendChild(dom.firstChild); }\n    }\n\n    define(tag$$1, 'root', root);\n\n    // if we need to wait that the parent \"mount\" or \"updated\" event gets triggered\n    if (!__.skipAnonymous && tag$$1.parent) {\n      var p = getImmediateCustomParent(tag$$1.parent);\n      p.one(!p.isMounted ? 'mount' : 'updated', function () {\n        setMountState.call(tag$$1, true);\n      });\n    } else {\n      // otherwise it's not a child tag we can trigger its mount event\n      setMountState.call(tag$$1, true);\n    }\n\n    tag$$1.__.wasCreated = true;\n\n    return tag$$1\n  }\n\n  /**\n   * Unmount the tag instance\n   * @param { Boolean } mustKeepRoot - if it's true the root node will not be removed\n   * @returns { Tag } the current tag instance\n   */\n  function tagUnmount(tag, mustKeepRoot, expressions) {\n    var __ = tag.__;\n    var root = __.root;\n    var tagIndex = __TAGS_CACHE.indexOf(tag);\n    var p = root.parentNode;\n\n    if (!__.skipAnonymous) { tag.trigger('before-unmount'); }\n\n    // clear all attributes coming from the mounted tag\n    walkAttributes(__.impl.attrs, function (name) {\n      if (startsWith(name, ATTRS_PREFIX))\n        { name = name.slice(ATTRS_PREFIX.length); }\n\n      removeAttribute(root, name);\n    });\n\n    // remove all the event listeners\n    tag.__.listeners.forEach(function (dom) {\n      Object.keys(dom[RIOT_EVENTS_KEY]).forEach(function (eventName) {\n        dom.removeEventListener(eventName, dom[RIOT_EVENTS_KEY][eventName]);\n      });\n    });\n\n    // remove tag instance from the global tags cache collection\n    if (tagIndex !== -1) { __TAGS_CACHE.splice(tagIndex, 1); }\n\n    // clean up the parent tags object\n    if (__.parent && !__.isAnonymous) {\n      var ptag = getImmediateCustomParent(__.parent);\n\n      if (__.isVirtual) {\n        Object\n          .keys(tag.tags)\n          .forEach(function (tagName) { return arrayishRemove(ptag.tags, tagName, tag.tags[tagName]); });\n      } else {\n        arrayishRemove(ptag.tags, __.tagName, tag);\n      }\n    }\n\n    // unmount all the virtual directives\n    if (tag.__.virts) {\n      each(tag.__.virts, function (v) {\n        if (v.parentNode) { v.parentNode.removeChild(v); }\n      });\n    }\n\n    // allow expressions to unmount themselves\n    unmountAll(expressions);\n    each(__.instAttrs, function (a) { return a.expr && a.expr.unmount && a.expr.unmount(); });\n\n    // clear the tag html if it's necessary\n    if (mustKeepRoot) { setInnerHTML(root, ''); }\n    // otherwise detach the root tag from the DOM\n    else if (p) { p.removeChild(root); }\n\n    // custom internal unmount function to avoid relying on the observable\n    if (__.onUnmount) { __.onUnmount(); }\n\n    // weird fix for a weird edge case #2409 and #2436\n    // some users might use your software not as you've expected\n    // so I need to add these dirty hacks to mitigate unexpected issues\n    if (!tag.isMounted) { setMountState.call(tag, true); }\n\n    setMountState.call(tag, false);\n\n    delete root._tag;\n\n    return tag\n  }\n\n  /**\n   * Tag creation factory function\n   * @constructor\n   * @param { Object } impl - it contains the tag template, and logic\n   * @param { Object } conf - tag options\n   * @param { String } innerHTML - html that eventually we need to inject in the tag\n   */\n  function createTag(impl, conf, innerHTML) {\n    if ( impl === void 0 ) impl = {};\n    if ( conf === void 0 ) conf = {};\n\n    var tag = conf.context || {};\n    var opts = conf.opts || {};\n    var parent = conf.parent;\n    var isLoop = conf.isLoop;\n    var isAnonymous = !!conf.isAnonymous;\n    var skipAnonymous = settings.skipAnonymousTags && isAnonymous;\n    var item = conf.item;\n    // available only for the looped nodes\n    var index = conf.index;\n    // All attributes on the Tag when it's first parsed\n    var instAttrs = [];\n    // expressions on this type of Tag\n    var implAttrs = [];\n    var tmpl = impl.tmpl;\n    var expressions = [];\n    var root = conf.root;\n    var tagName = conf.tagName || getName(root);\n    var isVirtual = tagName === 'virtual';\n    var isInline = !isVirtual && !tmpl;\n    var dom;\n\n    if (isInline || isLoop && isAnonymous) {\n      dom = root;\n    } else {\n      if (!isVirtual) { root.innerHTML = ''; }\n      dom = mkdom(tmpl, innerHTML, isSvg(root));\n    }\n\n    // make this tag observable\n    if (!skipAnonymous) { observable(tag); }\n\n    // only call unmount if we have a valid __TAG_IMPL (has name property)\n    if (impl.name && root._tag) { root._tag.unmount(true); }\n\n    define(tag, '__', {\n      impl: impl,\n      root: root,\n      skipAnonymous: skipAnonymous,\n      implAttrs: implAttrs,\n      isAnonymous: isAnonymous,\n      instAttrs: instAttrs,\n      innerHTML: innerHTML,\n      tagName: tagName,\n      index: index,\n      isLoop: isLoop,\n      isInline: isInline,\n      item: item,\n      parent: parent,\n      // tags having event listeners\n      // it would be better to use weak maps here but we can not introduce breaking changes now\n      listeners: [],\n      // these vars will be needed only for the virtual tags\n      virts: [],\n      wasCreated: false,\n      tail: null,\n      head: null\n    });\n\n    // tag protected properties\n    return [\n      ['isMounted', false],\n      // create a unique id to this tag\n      // it could be handy to use it also to improve the virtual dom rendering speed\n      ['_riot_id', uid()],\n      ['root', root],\n      ['opts', opts, { writable: true, enumerable: true }],\n      ['parent', parent || null],\n      // protect the \"tags\" and \"refs\" property from being overridden\n      ['tags', {}],\n      ['refs', {}],\n      ['update', function (data) { return componentUpdate(tag, data, expressions); }],\n      ['mixin', function () {\n        var mixins = [], len = arguments.length;\n        while ( len-- ) mixins[ len ] = arguments[ len ];\n\n        return componentMixin.apply(void 0, [ tag ].concat( mixins ));\n    }],\n      ['mount', function () { return componentMount(tag, dom, expressions, opts); }],\n      ['unmount', function (mustKeepRoot) { return tagUnmount(tag, mustKeepRoot, expressions); }]\n    ].reduce(function (acc, ref) {\n      var key = ref[0];\n      var value = ref[1];\n      var opts = ref[2];\n\n      define(tag, key, value, opts);\n      return acc\n    }, extend(tag, item))\n  }\n\n  /**\n   * Mount a tag creating new Tag instance\n   * @param   { Object } root - dom node where the tag will be mounted\n   * @param   { String } tagName - name of the riot tag we want to mount\n   * @param   { Object } opts - options to pass to the Tag instance\n   * @param   { Object } ctx - optional context that will be used to extend an existing class ( used in riot.Tag )\n   * @returns { Tag } a new Tag instance\n   */\n  function mount$1(root, tagName, opts, ctx) {\n    var impl = __TAG_IMPL[tagName];\n    var implClass = __TAG_IMPL[tagName].class;\n    var context = ctx || (implClass ? create(implClass.prototype) : {});\n    // cache the inner HTML to fix #855\n    var innerHTML = root._innerHTML = root._innerHTML || root.innerHTML;\n    var conf = extend({ root: root, opts: opts, context: context }, { parent: opts ? opts.parent : null });\n    var tag;\n\n    if (impl && root) { tag = createTag(impl, conf, innerHTML); }\n\n    if (tag && tag.mount) {\n      tag.mount(true);\n      // add this tag to the virtualDom variable\n      if (!contains(__TAGS_CACHE, tag)) { __TAGS_CACHE.push(tag); }\n    }\n\n    return tag\n  }\n\n\n\n  var tags = /*#__PURE__*/Object.freeze({\n    arrayishAdd: arrayishAdd,\n    getTagName: getName,\n    inheritParentProps: inheritParentProps,\n    mountTo: mount$1,\n    selectTags: query,\n    arrayishRemove: arrayishRemove,\n    getTag: get,\n    initChildTag: initChild,\n    moveChildTag: moveChild,\n    makeReplaceVirtual: makeReplaceVirtual,\n    getImmediateCustomParentTag: getImmediateCustomParent,\n    makeVirtual: makeVirtual,\n    moveVirtual: moveVirtual,\n    unmountAll: unmountAll,\n    createIfDirective: createIfDirective,\n    createRefDirective: createRefDirective\n  });\n\n  /**\n   * Riot public api\n   */\n  var settings$1 = settings;\n  var util = {\n    tmpl: tmpl,\n    brackets: brackets,\n    styleManager: styleManager,\n    vdom: __TAGS_CACHE,\n    styleNode: styleManager.styleNode,\n    // export the riot internal utils as well\n    dom: dom,\n    check: check,\n    misc: misc,\n    tags: tags\n  };\n\n  // export the core props/methods\n  var Tag$1 = Tag;\n  var tag$1 = tag;\n  var tag2$1 = tag2;\n  var mount$2 = mount;\n  var mixin$1 = mixin;\n  var update$2 = update$1;\n  var unregister$1 = unregister;\n  var version$1 = version;\n  var observable$1 = observable;\n\n  var riot$1 = extend({}, core, {\n    observable: observable,\n    settings: settings$1,\n    util: util,\n  })\n\n  exports.settings = settings$1;\n  exports.util = util;\n  exports.Tag = Tag$1;\n  exports.tag = tag$1;\n  exports.tag2 = tag2$1;\n  exports.mount = mount$2;\n  exports.mixin = mixin$1;\n  exports.update = update$2;\n  exports.unregister = unregister$1;\n  exports.version = version$1;\n  exports.observable = observable$1;\n  exports.default = riot$1;\n\n  Object.defineProperty(exports, '__esModule', { value: true });\n\n})));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmlvdC9yaW90LmpzPzJlOTEiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0EsV0FDNEI7QUFDNUIsQ0FBQyw0QkFBNEI7O0FBRTdCO0FBQ0E7QUFDQSxlQUFlLFNBQVM7QUFDeEIsZUFBZSxTQUFTO0FBQ3hCLGVBQWUsU0FBUztBQUN4QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RCxHQUFHLEdBQUc7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0VBQXNFOztBQUV0RTtBQUNBO0FBQ0EsZUFBZSxTQUFTO0FBQ3hCLGVBQWUsU0FBUztBQUN4QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYSxTQUFTO0FBQ3RCLGFBQWEsU0FBUztBQUN0QixhQUFhLFNBQVM7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPLDZDQUE2QztBQUNwRDtBQUNBLE9BQU8sNkJBQTZCO0FBQ3BDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLDBCQUEwQjtBQUNwRDtBQUNBLE9BQU8sT0FBTyxvQ0FBb0M7O0FBRWxEO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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b3QvcmlvdC5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qIFJpb3QgdjMuMTAuMiwgQGxpY2Vuc2UgTUlUICovXG4oZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xuICB0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgPyBmYWN0b3J5KGV4cG9ydHMpIDpcbiAgdHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKFsnZXhwb3J0cyddLCBmYWN0b3J5KSA6XG4gIChmYWN0b3J5KChnbG9iYWwucmlvdCA9IHt9KSkpO1xufSh0aGlzLCAoZnVuY3Rpb24gKGV4cG9ydHMpIHsgJ3VzZSBzdHJpY3QnO1xuXG4gIC8qKlxuICAgKiBTaG9ydGVyIGFuZCBmYXN0IHdheSB0byBzZWxlY3QgYSBzaW5nbGUgbm9kZSBpbiB0aGUgRE9NXG4gICAqIEBwYXJhbSAgIHsgU3RyaW5nIH0gc2VsZWN0b3IgLSB1bmlxdWUgZG9tIHNlbGVjdG9yXG4gICAqIEBwYXJhbSAgIHsgT2JqZWN0IH0gY3R4IC0gRE9NIG5vZGUgd2hlcmUgdGhlIHRhcmdldCBvZiBvdXIgc2VhcmNoIHdpbGwgaXMgbG9jYXRlZFxuICAgKiBAcmV0dXJucyB7IE9iamVjdCB9IGRvbSBub2RlIGZvdW5kXG4gICAqL1xuICBmdW5jdGlvbiAkKHNlbGVjdG9yLCBjdHgpIHtcbiAgICByZXR1cm4gKGN0eCB8fCBkb2N1bWVudCkucXVlcnlTZWxlY3RvcihzZWxlY3RvcilcbiAgfVxuXG4gIHZhclxuICAgIC8vIGJlIGF3YXJlLCBpbnRlcm5hbCB1c2FnZVxuICAgIC8vIEFUVEVOVElPTjogcHJlZml4IHRoZSBnbG9iYWwgZHluYW1pYyB2YXJpYWJsZXMgd2l0aCBgX19gXG4gICAgLy8gdGFncyBpbnN0YW5jZXMgY2FjaGVcbiAgICBfX1RBR1NfQ0FDSEUgPSBbXSxcbiAgICAvLyB0YWdzIGltcGxlbWVudGF0aW9uIGNhY2hlXG4gICAgX19UQUdfSU1QTCA9IHt9LFxuICAgIFlJRUxEX1RBRyA9ICd5aWVsZCcsXG5cbiAgICAvKipcbiAgICAgKiBDb25zdFxuICAgICAqL1xuICAgIEdMT0JBTF9NSVhJTiA9ICdfX2dsb2JhbF9taXhpbicsXG5cbiAgICAvLyByaW90IHNwZWNpZmljIHByZWZpeGVzIG9yIGF0dHJpYnV0ZXNcbiAgICBBVFRSU19QUkVGSVggPSAncmlvdC0nLFxuXG4gICAgLy8gUmlvdCBEaXJlY3RpdmVzXG4gICAgUkVGX0RJUkVDVElWRVMgPSBbJ3JlZicsICdkYXRhLXJlZiddLFxuICAgIElTX0RJUkVDVElWRSA9ICdkYXRhLWlzJyxcbiAgICBDT05ESVRJT05BTF9ESVJFQ1RJVkUgPSAnaWYnLFxuICAgIExPT1BfRElSRUNUSVZFID0gJ2VhY2gnLFxuICAgIExPT1BfTk9fUkVPUkRFUl9ESVJFQ1RJVkUgPSAnbm8tcmVvcmRlcicsXG4gICAgU0hPV19ESVJFQ1RJVkUgPSAnc2hvdycsXG4gICAgSElERV9ESVJFQ1RJVkUgPSAnaGlkZScsXG4gICAgS0VZX0RJUkVDVElWRSA9ICdrZXknLFxuICAgIFJJT1RfRVZFTlRTX0tFWSA9ICdfX3Jpb3QtZXZlbnRzX18nLFxuXG4gICAgLy8gZm9yIHR5cGVvZiA9PSAnJyBjb21wYXJpc29uc1xuICAgIFRfU1RSSU5HID0gJ3N0cmluZycsXG4gICAgVF9PQkpFQ1QgPSAnb2JqZWN0JyxcbiAgICBUX1VOREVGICA9ICd1bmRlZmluZWQnLFxuICAgIFRfRlVOQ1RJT04gPSAnZnVuY3Rpb24nLFxuXG4gICAgWExJTktfTlMgPSAnaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluaycsXG4gICAgU1ZHX05TID0gJ2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJyxcbiAgICBYTElOS19SRUdFWCA9IC9eeGxpbms6KFxcdyspLyxcblxuICAgIFdJTiA9IHR5cGVvZiB3aW5kb3cgPT09IFRfVU5ERUYgPyAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqLyB1bmRlZmluZWQgOiB3aW5kb3csXG5cbiAgICAvLyBzcGVjaWFsIG5hdGl2ZSB0YWdzIHRoYXQgY2Fubm90IGJlIHRyZWF0ZWQgbGlrZSB0aGUgb3RoZXJzXG4gICAgUkVfU1BFQ0lBTF9UQUdTID0gL14oPzp0KD86Ym9keXxoZWFkfGZvb3R8W3JoZF0pfGNhcHRpb258Y29sKD86Z3JvdXApP3xvcHQoPzppb258Z3JvdXApKSQvLFxuICAgIFJFX1NQRUNJQUxfVEFHU19OT19PUFRJT04gPSAvXig/OnQoPzpib2R5fGhlYWR8Zm9vdHxbcmhkXSl8Y2FwdGlvbnxjb2woPzpncm91cCk/KSQvLFxuICAgIFJFX0VWRU5UU19QUkVGSVggPSAvXm9uLyxcbiAgICBSRV9IVE1MX0FUVFJTID0gLyhbLVxcd10rKSA/PSA/KD86XCIoW15cIl0qKXwnKFteJ10qKXwoe1tefV0qfSkpL2csXG4gICAgLy8gc29tZSBET00gYXR0cmlidXRlcyBtdXN0IGJlIG5vcm1hbGl6ZWRcbiAgICBDQVNFX1NFTlNJVElWRV9BVFRSSUJVVEVTID0ge1xuICAgICAgJ3ZpZXdib3gnOiAndmlld0JveCcsXG4gICAgICAncHJlc2VydmVhc3BlY3RyYXRpbyc6ICdwcmVzZXJ2ZUFzcGVjdFJhdGlvJ1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogTWF0Y2hlcyBib29sZWFuIEhUTUwgYXR0cmlidXRlcyBpbiB0aGUgcmlvdCB0YWcgZGVmaW5pdGlvbi5cbiAgICAgKiBXaXRoIGEgbG9uZyBsaXN0IGxpa2UgdGhpcywgYSByZWdleCBpcyBmYXN0ZXIgdGhhbiBgW10uaW5kZXhPZmAgaW4gbW9zdCBicm93c2Vycy5cbiAgICAgKiBAY29uc3Qge1JlZ0V4cH1cbiAgICAgKiBAc2VlIFthdHRyaWJ1dGVzLm1kXShodHRwczovL2dpdGh1Yi5jb20vcmlvdC9jb21waWxlci9ibG9iL2Rldi9kb2MvYXR0cmlidXRlcy5tZClcbiAgICAgKi9cbiAgICBSRV9CT09MX0FUVFJTID0gL14oPzpkaXNhYmxlZHxjaGVja2VkfHJlYWRvbmx5fHJlcXVpcmVkfGFsbG93ZnVsbHNjcmVlbnxhdXRvKD86Zm9jdXN8cGxheSl8Y29tcGFjdHxjb250cm9sc3xkZWZhdWx0fGZvcm1ub3ZhbGlkYXRlfGhpZGRlbnxpc21hcHxpdGVtc2NvcGV8bG9vcHxtdWx0aXBsZXxtdXRlZHxubyg/OnJlc2l6ZXxzaGFkZXx2YWxpZGF0ZXx3cmFwKT98b3BlbnxyZXZlcnNlZHxzZWFtbGVzc3xzZWxlY3RlZHxzb3J0YWJsZXx0cnVlc3BlZWR8dHlwZW11c3RtYXRjaCkkLyxcbiAgICAvLyB2ZXJzaW9uIyBmb3IgSUUgOC0xMSwgMCBmb3Igb3RoZXJzXG4gICAgSUVfVkVSU0lPTiA9IChXSU4gJiYgV0lOLmRvY3VtZW50IHx8IC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovIHt9KS5kb2N1bWVudE1vZGUgfCAwO1xuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSBnZW5lcmljIERPTSBub2RlXG4gICAqIEBwYXJhbSAgIHsgU3RyaW5nIH0gbmFtZSAtIG5hbWUgb2YgdGhlIERPTSBub2RlIHdlIHdhbnQgdG8gY3JlYXRlXG4gICAqIEByZXR1cm5zIHsgT2JqZWN0IH0gRE9NIG5vZGUganVzdCBjcmVhdGVkXG4gICAqL1xuICBmdW5jdGlvbiBtYWtlRWxlbWVudChuYW1lKSB7XG4gICAgcmV0dXJuIG5hbWUgPT09ICdzdmcnID8gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKFNWR19OUywgbmFtZSkgOiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KG5hbWUpXG4gIH1cblxuICAvKipcbiAgICogU2V0IGFueSBET00gYXR0cmlidXRlXG4gICAqIEBwYXJhbSB7IE9iamVjdCB9IGRvbSAtIERPTSBub2RlIHdlIHdhbnQgdG8gdXBkYXRlXG4gICAqIEBwYXJhbSB7IFN0cmluZyB9IG5hbWUgLSBuYW1lIG9mIHRoZSBwcm9wZXJ0eSB3ZSB3YW50IHRvIHNldFxuICAgKiBAcGFyYW0geyBTdHJpbmcgfSB2YWwgLSB2YWx1ZSBvZiB0aGUgcHJvcGVydHkgd2Ugd2FudCB0byBzZXRcbiAgICovXG4gIGZ1bmN0aW9uIHNldEF0dHJpYnV0ZShkb20sIG5hbWUsIHZhbCkge1xuICAgIHZhciB4bGluayA9IFhMSU5LX1JFR0VYLmV4ZWMobmFtZSk7XG4gICAgaWYgKHhsaW5rICYmIHhsaW5rWzFdKVxuICAgICAgeyBkb20uc2V0QXR0cmlidXRlTlMoWExJTktfTlMsIHhsaW5rWzFdLCB2YWwpOyB9XG4gICAgZWxzZVxuICAgICAgeyBkb20uc2V0QXR0cmlidXRlKG5hbWUsIHZhbCk7IH1cbiAgfVxuXG4gIHZhciBzdHlsZU5vZGU7XG4gIC8vIENyZWF0ZSBjYWNoZSBhbmQgc2hvcnRjdXQgdG8gdGhlIGNvcnJlY3QgcHJvcGVydHlcbiAgdmFyIGNzc1RleHRQcm9wO1xuICB2YXIgYnlOYW1lID0ge307XG4gIHZhciBuZWVkc0luamVjdCA9IGZhbHNlO1xuXG4gIC8vIHNraXAgdGhlIGZvbGxvd2luZyBjb2RlIG9uIHRoZSBzZXJ2ZXJcbiAgaWYgKFdJTikge1xuICAgIHN0eWxlTm9kZSA9ICgoZnVuY3Rpb24gKCkge1xuICAgICAgLy8gY3JlYXRlIGEgbmV3IHN0eWxlIGVsZW1lbnQgd2l0aCB0aGUgY29ycmVjdCB0eXBlXG4gICAgICB2YXIgbmV3Tm9kZSA9IG1ha2VFbGVtZW50KCdzdHlsZScpO1xuICAgICAgLy8gcmVwbGFjZSBhbnkgdXNlciBub2RlIG9yIGluc2VydCB0aGUgbmV3IG9uZSBpbnRvIHRoZSBoZWFkXG4gICAgICB2YXIgdXNlck5vZGUgPSAkKCdzdHlsZVt0eXBlPXJpb3RdJyk7XG5cbiAgICAgIHNldEF0dHJpYnV0ZShuZXdOb2RlLCAndHlwZScsICd0ZXh0L2NzcycpO1xuICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAgIGlmICh1c2VyTm9kZSkge1xuICAgICAgICBpZiAodXNlck5vZGUuaWQpIHsgbmV3Tm9kZS5pZCA9IHVzZXJOb2RlLmlkOyB9XG4gICAgICAgIHVzZXJOb2RlLnBhcmVudE5vZGUucmVwbGFjZUNoaWxkKG5ld05vZGUsIHVzZXJOb2RlKTtcbiAgICAgIH0gZWxzZSB7IGRvY3VtZW50LmhlYWQuYXBwZW5kQ2hpbGQobmV3Tm9kZSk7IH1cblxuICAgICAgcmV0dXJuIG5ld05vZGVcbiAgICB9KSkoKTtcbiAgICBjc3NUZXh0UHJvcCA9IHN0eWxlTm9kZS5zdHlsZVNoZWV0O1xuICB9XG5cbiAgLyoqXG4gICAqIE9iamVjdCB0aGF0IHdpbGwgYmUgdXNlZCB0byBpbmplY3QgYW5kIG1hbmFnZSB0aGUgY3NzIG9mIGV2ZXJ5IHRhZyBpbnN0YW5jZVxuICAgKi9cbiAgdmFyIHN0eWxlTWFuYWdlciA9IHtcbiAgICBzdHlsZU5vZGU6IHN0eWxlTm9kZSxcbiAgICAvKipcbiAgICAgKiBTYXZlIGEgdGFnIHN0eWxlIHRvIGJlIGxhdGVyIGluamVjdGVkIGludG8gRE9NXG4gICAgICogQHBhcmFtIHsgU3RyaW5nIH0gY3NzIC0gY3NzIHN0cmluZ1xuICAgICAqIEBwYXJhbSB7IFN0cmluZyB9IG5hbWUgLSBpZiBpdCdzIHBhc3NlZCB3ZSB3aWxsIG1hcCB0aGUgY3NzIHRvIGEgdGFnbmFtZVxuICAgICAqL1xuICAgIGFkZDogZnVuY3Rpb24gYWRkKGNzcywgbmFtZSkge1xuICAgICAgYnlOYW1lW25hbWVdID0gY3NzO1xuICAgICAgbmVlZHNJbmplY3QgPSB0cnVlO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogSW5qZWN0IGFsbCBwcmV2aW91c2x5IHNhdmVkIHRhZyBzdHlsZXMgaW50byBET01cbiAgICAgKiBpbm5lckhUTUwgc2VlbXMgc2xvdzogaHR0cDovL2pzcGVyZi5jb20vcmlvdC1pbnNlcnQtc3R5bGVcbiAgICAgKi9cbiAgICBpbmplY3Q6IGZ1bmN0aW9uIGluamVjdCgpIHtcbiAgICAgIGlmICghV0lOIHx8ICFuZWVkc0luamVjdCkgeyByZXR1cm4gfVxuICAgICAgbmVlZHNJbmplY3QgPSBmYWxzZTtcbiAgICAgIHZhciBzdHlsZSA9IE9iamVjdC5rZXlzKGJ5TmFtZSlcbiAgICAgICAgLm1hcChmdW5jdGlvbiAoaykgeyByZXR1cm4gYnlOYW1lW2tdOyB9KVxuICAgICAgICAuam9pbignXFxuJyk7XG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgaWYgKGNzc1RleHRQcm9wKSB7IGNzc1RleHRQcm9wLmNzc1RleHQgPSBzdHlsZTsgfVxuICAgICAgZWxzZSB7IHN0eWxlTm9kZS5pbm5lckhUTUwgPSBzdHlsZTsgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmUgYSB0YWcgc3R5bGUgb2YgaW5qZWN0ZWQgRE9NIGxhdGVyLlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIGEgcmVnaXN0ZXJlZCB0YWduYW1lXG4gICAgICovXG4gICAgcmVtb3ZlOiBmdW5jdGlvbiByZW1vdmUobmFtZSkge1xuICAgICAgZGVsZXRlIGJ5TmFtZVtuYW1lXTtcbiAgICAgIG5lZWRzSW5qZWN0ID0gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogVGhlIHJpb3QgdGVtcGxhdGUgZW5naW5lXG4gICAqIEB2ZXJzaW9uIHYzLjAuOFxuICAgKi9cblxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICB2YXIgc2tpcFJlZ2V4ID0gKGZ1bmN0aW9uICgpIHsgLy9lc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG5cbiAgICB2YXIgYmVmb3JlUmVDaGFycyA9ICdbeygsOzo/PXwmIV5+PiUqLyc7XG5cbiAgICB2YXIgYmVmb3JlUmVXb3JkcyA9IFtcbiAgICAgICdjYXNlJyxcbiAgICAgICdkZWZhdWx0JyxcbiAgICAgICdkbycsXG4gICAgICAnZWxzZScsXG4gICAgICAnaW4nLFxuICAgICAgJ2luc3RhbmNlb2YnLFxuICAgICAgJ3ByZWZpeCcsXG4gICAgICAncmV0dXJuJyxcbiAgICAgICd0eXBlb2YnLFxuICAgICAgJ3ZvaWQnLFxuICAgICAgJ3lpZWxkJ1xuICAgIF07XG5cbiAgICB2YXIgd29yZHNMYXN0Q2hhciA9IGJlZm9yZVJlV29yZHMucmVkdWNlKGZ1bmN0aW9uIChzLCB3KSB7XG4gICAgICByZXR1cm4gcyArIHcuc2xpY2UoLTEpXG4gICAgfSwgJycpO1xuXG4gICAgdmFyIFJFX1JFR0VYID0gL15cXC8oPz1bXio+L10pW15bL1xcXFxdKig/Oig/OlxcXFwufFxcWyg/OlxcXFwufFteXFxdXFxcXF0qKSpcXF0pW15bXFxcXC9dKikqP1xcL1tnaW11eV0qLztcbiAgICB2YXIgUkVfVk5fQ0hBUiA9IC9bJFxcd10vO1xuXG4gICAgZnVuY3Rpb24gcHJldiAoY29kZSwgcG9zKSB7XG4gICAgICB3aGlsZSAoLS1wb3MgPj0gMCAmJiAvXFxzLy50ZXN0KGNvZGVbcG9zXSkpeyB9XG4gICAgICByZXR1cm4gcG9zXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gX3NraXBSZWdleCAoY29kZSwgc3RhcnQpIHtcblxuICAgICAgdmFyIHJlID0gLy4qL2c7XG4gICAgICB2YXIgcG9zID0gcmUubGFzdEluZGV4ID0gc3RhcnQrKztcbiAgICAgIHZhciBtYXRjaCA9IHJlLmV4ZWMoY29kZSlbMF0ubWF0Y2goUkVfUkVHRVgpO1xuXG4gICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgdmFyIG5leHQgPSBwb3MgKyBtYXRjaFswXS5sZW5ndGg7XG5cbiAgICAgICAgcG9zID0gcHJldihjb2RlLCBwb3MpO1xuICAgICAgICB2YXIgYyA9IGNvZGVbcG9zXTtcblxuICAgICAgICBpZiAocG9zIDwgMCB8fCB+YmVmb3JlUmVDaGFycy5pbmRleE9mKGMpKSB7XG4gICAgICAgICAgcmV0dXJuIG5leHRcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjID09PSAnLicpIHtcblxuICAgICAgICAgIGlmIChjb2RlW3BvcyAtIDFdID09PSAnLicpIHtcbiAgICAgICAgICAgIHN0YXJ0ID0gbmV4dDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgfSBlbHNlIGlmIChjID09PSAnKycgfHwgYyA9PT0gJy0nKSB7XG5cbiAgICAgICAgICBpZiAoY29kZVstLXBvc10gIT09IGMgfHxcbiAgICAgICAgICAgICAgKHBvcyA9IHByZXYoY29kZSwgcG9zKSkgPCAwIHx8XG4gICAgICAgICAgICAgICFSRV9WTl9DSEFSLnRlc3QoY29kZVtwb3NdKSkge1xuICAgICAgICAgICAgc3RhcnQgPSBuZXh0O1xuICAgICAgICAgIH1cblxuICAgICAgICB9IGVsc2UgaWYgKH53b3Jkc0xhc3RDaGFyLmluZGV4T2YoYykpIHtcblxuICAgICAgICAgIHZhciBlbmQgPSBwb3MgKyAxO1xuXG4gICAgICAgICAgd2hpbGUgKC0tcG9zID49IDAgJiYgUkVfVk5fQ0hBUi50ZXN0KGNvZGVbcG9zXSkpeyB9XG4gICAgICAgICAgaWYgKH5iZWZvcmVSZVdvcmRzLmluZGV4T2YoY29kZS5zbGljZShwb3MgKyAxLCBlbmQpKSkge1xuICAgICAgICAgICAgc3RhcnQgPSBuZXh0O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gc3RhcnRcbiAgICB9XG5cbiAgICByZXR1cm4gX3NraXBSZWdleFxuXG4gIH0pKCk7XG5cbiAgLyoqXG4gICAqIHJpb3QudXRpbC5icmFja2V0c1xuICAgKlxuICAgKiAtIGBicmFja2V0cyAgICBgIC0gUmV0dXJucyBhIHN0cmluZyBvciByZWdleCBiYXNlZCBvbiBpdHMgcGFyYW1ldGVyXG4gICAqIC0gYGJyYWNrZXRzLnNldGAgLSBDaGFuZ2UgdGhlIGN1cnJlbnQgcmlvdCBicmFja2V0c1xuICAgKlxuICAgKiBAbW9kdWxlXG4gICAqL1xuXG4gIC8qIGdsb2JhbCByaW90ICovXG5cbiAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgdmFyIGJyYWNrZXRzID0gKGZ1bmN0aW9uIChVTkRFRikge1xuXG4gICAgdmFyXG4gICAgICBSRUdMT0IgPSAnZycsXG5cbiAgICAgIFJfTUxDT01NUyA9IC9cXC9cXCpbXipdKlxcKisoPzpbXipcXC9dW14qXSpcXCorKSpcXC8vZyxcblxuICAgICAgUl9TVFJJTkdTID0gL1wiW15cIlxcXFxdKig/OlxcXFxbXFxTXFxzXVteXCJcXFxcXSopKlwifCdbXidcXFxcXSooPzpcXFxcW1xcU1xcc11bXidcXFxcXSopKid8YFteYFxcXFxdKig/OlxcXFxbXFxTXFxzXVteYFxcXFxdKikqYC9nLFxuXG4gICAgICBTX1FCTE9DS1MgPSBSX1NUUklOR1Muc291cmNlICsgJ3wnICtcbiAgICAgICAgLyg/OlxcYnJldHVyblxccyt8KD86WyRcXHdcXClcXF1dfFxcK1xcK3wtLSlcXHMqKFxcLykoPyFbKlxcL10pKS8uc291cmNlICsgJ3wnICtcbiAgICAgICAgL1xcLyg/PVteKlxcL10pW15bXFwvXFxcXF0qKD86KD86XFxbKD86XFxcXC58W15cXF1cXFxcXSopKlxcXXxcXFxcLilbXltcXC9cXFxcXSopKj8oW148XVxcLylbZ2ltXSovLnNvdXJjZSxcblxuICAgICAgVU5TVVBQT1JURUQgPSBSZWdFeHAoJ1tcXFxcJyArICd4MDAtXFxcXHgxRjw+YS16QS1aMC05XFwnXCIsO1xcXFxcXFxcXScpLFxuXG4gICAgICBORUVEX0VTQ0FQRSA9IC8oPz1bW1xcXSgpKis/Ll4kfF0pL2csXG5cbiAgICAgIFNfUUJMT0NLMiA9IFJfU1RSSU5HUy5zb3VyY2UgKyAnfCcgKyAvKFxcLykoPyFbKlxcL10pLy5zb3VyY2UsXG5cbiAgICAgIEZJTkRCUkFDRVMgPSB7XG4gICAgICAgICcoJzogUmVnRXhwKCcoWygpXSl8JyAgICsgU19RQkxPQ0syLCBSRUdMT0IpLFxuICAgICAgICAnWyc6IFJlZ0V4cCgnKFtbXFxcXF1dKXwnICsgU19RQkxPQ0syLCBSRUdMT0IpLFxuICAgICAgICAneyc6IFJlZ0V4cCgnKFt7fV0pfCcgICArIFNfUUJMT0NLMiwgUkVHTE9CKVxuICAgICAgfSxcblxuICAgICAgREVGQVVMVCA9ICd7IH0nO1xuXG4gICAgdmFyIF9wYWlycyA9IFtcbiAgICAgICd7JywgJ30nLFxuICAgICAgJ3snLCAnfScsXG4gICAgICAve1tefV0qfS8sXG4gICAgICAvXFxcXChbe31dKS9nLFxuICAgICAgL1xcXFwoeyl8ey9nLFxuICAgICAgUmVnRXhwKCdcXFxcXFxcXCh9KXwoW1soe10pfCh9KXwnICsgU19RQkxPQ0syLCBSRUdMT0IpLFxuICAgICAgREVGQVVMVCxcbiAgICAgIC9eXFxzKntcXF4/XFxzKihbJFxcd10rKSg/OlxccyosXFxzKihcXFMrKSk/XFxzK2luXFxzKyhcXFMuKilcXHMqfS8sXG4gICAgICAvKF58W15cXFxcXSl7PVtcXFNcXHNdKj99L1xuICAgIF07XG5cbiAgICB2YXJcbiAgICAgIGNhY2hlZEJyYWNrZXRzID0gVU5ERUYsXG4gICAgICBfcmVnZXgsXG4gICAgICBfY2FjaGUgPSBbXSxcbiAgICAgIF9zZXR0aW5ncztcblxuICAgIGZ1bmN0aW9uIF9sb29wYmFjayAocmUpIHsgcmV0dXJuIHJlIH1cblxuICAgIGZ1bmN0aW9uIF9yZXdyaXRlIChyZSwgYnApIHtcbiAgICAgIGlmICghYnApIHsgYnAgPSBfY2FjaGU7IH1cbiAgICAgIHJldHVybiBuZXcgUmVnRXhwKFxuICAgICAgICByZS5zb3VyY2UucmVwbGFjZSgvey9nLCBicFsyXSkucmVwbGFjZSgvfS9nLCBicFszXSksIHJlLmdsb2JhbCA/IFJFR0xPQiA6ICcnXG4gICAgICApXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gX2NyZWF0ZSAocGFpcikge1xuICAgICAgaWYgKHBhaXIgPT09IERFRkFVTFQpIHsgcmV0dXJuIF9wYWlycyB9XG5cbiAgICAgIHZhciBhcnIgPSBwYWlyLnNwbGl0KCcgJyk7XG5cbiAgICAgIGlmIChhcnIubGVuZ3RoICE9PSAyIHx8IFVOU1VQUE9SVEVELnRlc3QocGFpcikpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbnN1cHBvcnRlZCBicmFja2V0cyBcIicgKyBwYWlyICsgJ1wiJylcbiAgICAgIH1cbiAgICAgIGFyciA9IGFyci5jb25jYXQocGFpci5yZXBsYWNlKE5FRURfRVNDQVBFLCAnXFxcXCcpLnNwbGl0KCcgJykpO1xuXG4gICAgICBhcnJbNF0gPSBfcmV3cml0ZShhcnJbMV0ubGVuZ3RoID4gMSA/IC97W1xcU1xcc10qP30vIDogX3BhaXJzWzRdLCBhcnIpO1xuICAgICAgYXJyWzVdID0gX3Jld3JpdGUocGFpci5sZW5ndGggPiAzID8gL1xcXFwoe3x9KS9nIDogX3BhaXJzWzVdLCBhcnIpO1xuICAgICAgYXJyWzZdID0gX3Jld3JpdGUoX3BhaXJzWzZdLCBhcnIpO1xuICAgICAgYXJyWzddID0gUmVnRXhwKCdcXFxcXFxcXCgnICsgYXJyWzNdICsgJyl8KFtbKHtdKXwoJyArIGFyclszXSArICcpfCcgKyBTX1FCTE9DSzIsIFJFR0xPQik7XG4gICAgICBhcnJbOF0gPSBwYWlyO1xuICAgICAgcmV0dXJuIGFyclxuICAgIH1cblxuICAgIGZ1bmN0aW9uIF9icmFja2V0cyAocmVPcklkeCkge1xuICAgICAgcmV0dXJuIHJlT3JJZHggaW5zdGFuY2VvZiBSZWdFeHAgPyBfcmVnZXgocmVPcklkeCkgOiBfY2FjaGVbcmVPcklkeF1cbiAgICB9XG5cbiAgICBfYnJhY2tldHMuc3BsaXQgPSBmdW5jdGlvbiBzcGxpdCAoc3RyLCB0bXBsLCBfYnApIHtcbiAgICAgIC8vIGlzdGFuYnVsIGlnbm9yZSBuZXh0OiBfYnAgaXMgZm9yIHRoZSBjb21waWxlclxuICAgICAgaWYgKCFfYnApIHsgX2JwID0gX2NhY2hlOyB9XG5cbiAgICAgIHZhclxuICAgICAgICBwYXJ0cyA9IFtdLFxuICAgICAgICBtYXRjaCxcbiAgICAgICAgaXNleHByLFxuICAgICAgICBzdGFydCxcbiAgICAgICAgcG9zLFxuICAgICAgICByZSA9IF9icFs2XTtcblxuICAgICAgdmFyIHFibG9ja3MgPSBbXTtcbiAgICAgIHZhciBwcmV2U3RyID0gJyc7XG4gICAgICB2YXIgbWFyaywgbGFzdEluZGV4O1xuXG4gICAgICBpc2V4cHIgPSBzdGFydCA9IHJlLmxhc3RJbmRleCA9IDA7XG5cbiAgICAgIHdoaWxlICgobWF0Y2ggPSByZS5leGVjKHN0cikpKSB7XG5cbiAgICAgICAgbGFzdEluZGV4ID0gcmUubGFzdEluZGV4O1xuICAgICAgICBwb3MgPSBtYXRjaC5pbmRleDtcblxuICAgICAgICBpZiAoaXNleHByKSB7XG5cbiAgICAgICAgICBpZiAobWF0Y2hbMl0pIHtcblxuICAgICAgICAgICAgdmFyIGNoID0gbWF0Y2hbMl07XG4gICAgICAgICAgICB2YXIgcmVjaCA9IEZJTkRCUkFDRVNbY2hdO1xuICAgICAgICAgICAgdmFyIGl4ID0gMTtcblxuICAgICAgICAgICAgcmVjaC5sYXN0SW5kZXggPSBsYXN0SW5kZXg7XG4gICAgICAgICAgICB3aGlsZSAoKG1hdGNoID0gcmVjaC5leGVjKHN0cikpKSB7XG4gICAgICAgICAgICAgIGlmIChtYXRjaFsxXSkge1xuICAgICAgICAgICAgICAgIGlmIChtYXRjaFsxXSA9PT0gY2gpIHsgKytpeDsgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKCEtLWl4KSB7IGJyZWFrIH1cbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZWNoLmxhc3RJbmRleCA9IHB1c2hRQmxvY2sobWF0Y2guaW5kZXgsIHJlY2gubGFzdEluZGV4LCBtYXRjaFsyXSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlLmxhc3RJbmRleCA9IGl4ID8gc3RyLmxlbmd0aCA6IHJlY2gubGFzdEluZGV4O1xuICAgICAgICAgICAgY29udGludWVcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoIW1hdGNoWzNdKSB7XG4gICAgICAgICAgICByZS5sYXN0SW5kZXggPSBwdXNoUUJsb2NrKHBvcywgbGFzdEluZGV4LCBtYXRjaFs0XSk7XG4gICAgICAgICAgICBjb250aW51ZVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghbWF0Y2hbMV0pIHtcbiAgICAgICAgICB1bmVzY2FwZVN0cihzdHIuc2xpY2Uoc3RhcnQsIHBvcykpO1xuICAgICAgICAgIHN0YXJ0ID0gcmUubGFzdEluZGV4O1xuICAgICAgICAgIHJlID0gX2JwWzYgKyAoaXNleHByIF49IDEpXTtcbiAgICAgICAgICByZS5sYXN0SW5kZXggPSBzdGFydDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoc3RyICYmIHN0YXJ0IDwgc3RyLmxlbmd0aCkge1xuICAgICAgICB1bmVzY2FwZVN0cihzdHIuc2xpY2Uoc3RhcnQpKTtcbiAgICAgIH1cblxuICAgICAgcGFydHMucWJsb2NrcyA9IHFibG9ja3M7XG5cbiAgICAgIHJldHVybiBwYXJ0c1xuXG4gICAgICBmdW5jdGlvbiB1bmVzY2FwZVN0ciAocykge1xuICAgICAgICBpZiAocHJldlN0cikge1xuICAgICAgICAgIHMgPSBwcmV2U3RyICsgcztcbiAgICAgICAgICBwcmV2U3RyID0gJyc7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRtcGwgfHwgaXNleHByKSB7XG4gICAgICAgICAgcGFydHMucHVzaChzICYmIHMucmVwbGFjZShfYnBbNV0sICckMScpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwYXJ0cy5wdXNoKHMpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIHB1c2hRQmxvY2soX3BvcywgX2xhc3RJbmRleCwgc2xhc2gpIHsgLy9lc2xpbnQtZGlzYWJsZS1saW5lXG4gICAgICAgIGlmIChzbGFzaCkge1xuICAgICAgICAgIF9sYXN0SW5kZXggPSBza2lwUmVnZXgoc3RyLCBfcG9zKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0bXBsICYmIF9sYXN0SW5kZXggPiBfcG9zICsgMikge1xuICAgICAgICAgIG1hcmsgPSAnXFx1MjA1NycgKyBxYmxvY2tzLmxlbmd0aCArICd+JztcbiAgICAgICAgICBxYmxvY2tzLnB1c2goc3RyLnNsaWNlKF9wb3MsIF9sYXN0SW5kZXgpKTtcbiAgICAgICAgICBwcmV2U3RyICs9IHN0ci5zbGljZShzdGFydCwgX3BvcykgKyBtYXJrO1xuICAgICAgICAgIHN0YXJ0ID0gX2xhc3RJbmRleDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gX2xhc3RJbmRleFxuICAgICAgfVxuICAgIH07XG5cbiAgICBfYnJhY2tldHMuaGFzRXhwciA9IGZ1bmN0aW9uIGhhc0V4cHIgKHN0cikge1xuICAgICAgcmV0dXJuIF9jYWNoZVs0XS50ZXN0KHN0cilcbiAgICB9O1xuXG4gICAgX2JyYWNrZXRzLmxvb3BLZXlzID0gZnVuY3Rpb24gbG9vcEtleXMgKGV4cHIpIHtcbiAgICAgIHZhciBtID0gZXhwci5tYXRjaChfY2FjaGVbOV0pO1xuXG4gICAgICByZXR1cm4gbVxuICAgICAgICA/IHsga2V5OiBtWzFdLCBwb3M6IG1bMl0sIHZhbDogX2NhY2hlWzBdICsgbVszXS50cmltKCkgKyBfY2FjaGVbMV0gfVxuICAgICAgICA6IHsgdmFsOiBleHByLnRyaW0oKSB9XG4gICAgfTtcblxuICAgIF9icmFja2V0cy5hcnJheSA9IGZ1bmN0aW9uIGFycmF5IChwYWlyKSB7XG4gICAgICByZXR1cm4gcGFpciA/IF9jcmVhdGUocGFpcikgOiBfY2FjaGVcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gX3Jlc2V0IChwYWlyKSB7XG4gICAgICBpZiAoKHBhaXIgfHwgKHBhaXIgPSBERUZBVUxUKSkgIT09IF9jYWNoZVs4XSkge1xuICAgICAgICBfY2FjaGUgPSBfY3JlYXRlKHBhaXIpO1xuICAgICAgICBfcmVnZXggPSBwYWlyID09PSBERUZBVUxUID8gX2xvb3BiYWNrIDogX3Jld3JpdGU7XG4gICAgICAgIF9jYWNoZVs5XSA9IF9yZWdleChfcGFpcnNbOV0pO1xuICAgICAgfVxuICAgICAgY2FjaGVkQnJhY2tldHMgPSBwYWlyO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIF9zZXRTZXR0aW5ncyAobykge1xuICAgICAgdmFyIGI7XG5cbiAgICAgIG8gPSBvIHx8IHt9O1xuICAgICAgYiA9IG8uYnJhY2tldHM7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgJ2JyYWNrZXRzJywge1xuICAgICAgICBzZXQ6IF9yZXNldCxcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBjYWNoZWRCcmFja2V0cyB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlXG4gICAgICB9KTtcbiAgICAgIF9zZXR0aW5ncyA9IG87XG4gICAgICBfcmVzZXQoYik7XG4gICAgfVxuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KF9icmFja2V0cywgJ3NldHRpbmdzJywge1xuICAgICAgc2V0OiBfc2V0U2V0dGluZ3MsXG4gICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIF9zZXR0aW5ncyB9XG4gICAgfSk7XG5cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dDogaW4gdGhlIGJyb3dzZXIgcmlvdCBpcyBhbHdheXMgaW4gdGhlIHNjb3BlICovXG4gICAgX2JyYWNrZXRzLnNldHRpbmdzID0gdHlwZW9mIHJpb3QgIT09ICd1bmRlZmluZWQnICYmIHJpb3Quc2V0dGluZ3MgfHwge307XG4gICAgX2JyYWNrZXRzLnNldCA9IF9yZXNldDtcbiAgICBfYnJhY2tldHMuc2tpcFJlZ2V4ID0gc2tpcFJlZ2V4O1xuXG4gICAgX2JyYWNrZXRzLlJfU1RSSU5HUyA9IFJfU1RSSU5HUztcbiAgICBfYnJhY2tldHMuUl9NTENPTU1TID0gUl9NTENPTU1TO1xuICAgIF9icmFja2V0cy5TX1FCTE9DS1MgPSBTX1FCTE9DS1M7XG4gICAgX2JyYWNrZXRzLlNfUUJMT0NLMiA9IFNfUUJMT0NLMjtcblxuICAgIHJldHVybiBfYnJhY2tldHNcblxuICB9KSgpO1xuXG4gIC8qKlxuICAgKiBAbW9kdWxlIHRtcGxcbiAgICpcbiAgICogdG1wbCAgICAgICAgICAtIFJvb3QgZnVuY3Rpb24sIHJldHVybnMgdGhlIHRlbXBsYXRlIHZhbHVlLCByZW5kZXIgd2l0aCBkYXRhXG4gICAqIHRtcGwuaGFzRXhwciAgLSBUZXN0IHRoZSBleGlzdGVuY2Ugb2YgYSBleHByZXNzaW9uIGluc2lkZSBhIHN0cmluZ1xuICAgKiB0bXBsLmxvb3BLZXlzIC0gR2V0IHRoZSBrZXlzIGZvciBhbiAnZWFjaCcgbG9vcCAodXNlZCBieSBgX2VhY2hgKVxuICAgKi9cblxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICB2YXIgdG1wbCA9IChmdW5jdGlvbiAoKSB7XG5cbiAgICB2YXIgX2NhY2hlID0ge307XG5cbiAgICBmdW5jdGlvbiBfdG1wbCAoc3RyLCBkYXRhKSB7XG4gICAgICBpZiAoIXN0cikgeyByZXR1cm4gc3RyIH1cblxuICAgICAgcmV0dXJuIChfY2FjaGVbc3RyXSB8fCAoX2NhY2hlW3N0cl0gPSBfY3JlYXRlKHN0cikpKS5jYWxsKFxuICAgICAgICBkYXRhLCBfbG9nRXJyLmJpbmQoe1xuICAgICAgICAgIGRhdGE6IGRhdGEsXG4gICAgICAgICAgdG1wbDogc3RyXG4gICAgICAgIH0pXG4gICAgICApXG4gICAgfVxuXG4gICAgX3RtcGwuaGFzRXhwciA9IGJyYWNrZXRzLmhhc0V4cHI7XG5cbiAgICBfdG1wbC5sb29wS2V5cyA9IGJyYWNrZXRzLmxvb3BLZXlzO1xuXG4gICAgLy8gaXN0YW5idWwgaWdub3JlIG5leHRcbiAgICBfdG1wbC5jbGVhckNhY2hlID0gZnVuY3Rpb24gKCkgeyBfY2FjaGUgPSB7fTsgfTtcblxuICAgIF90bXBsLmVycm9ySGFuZGxlciA9IG51bGw7XG5cbiAgICBmdW5jdGlvbiBfbG9nRXJyIChlcnIsIGN0eCkge1xuXG4gICAgICBlcnIucmlvdERhdGEgPSB7XG4gICAgICAgIHRhZ05hbWU6IGN0eCAmJiBjdHguX18gJiYgY3R4Ll9fLnRhZ05hbWUsXG4gICAgICAgIF9yaW90X2lkOiBjdHggJiYgY3R4Ll9yaW90X2lkICAvL2VzbGludC1kaXNhYmxlLWxpbmUgY2FtZWxjYXNlXG4gICAgICB9O1xuXG4gICAgICBpZiAoX3RtcGwuZXJyb3JIYW5kbGVyKSB7IF90bXBsLmVycm9ySGFuZGxlcihlcnIpOyB9XG4gICAgICBlbHNlIGlmIChcbiAgICAgICAgdHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnICYmXG4gICAgICAgIHR5cGVvZiBjb25zb2xlLmVycm9yID09PSAnZnVuY3Rpb24nXG4gICAgICApIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihlcnIubWVzc2FnZSk7XG4gICAgICAgIGNvbnNvbGUubG9nKCc8JXM+ICVzJywgZXJyLnJpb3REYXRhLnRhZ05hbWUgfHwgJ1Vua25vd24gdGFnJywgdGhpcy50bXBsKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuICAgICAgICBjb25zb2xlLmxvZyh0aGlzLmRhdGEpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gX2NyZWF0ZSAoc3RyKSB7XG4gICAgICB2YXIgZXhwciA9IF9nZXRUbXBsKHN0cik7XG5cbiAgICAgIGlmIChleHByLnNsaWNlKDAsIDExKSAhPT0gJ3RyeXtyZXR1cm4gJykgeyBleHByID0gJ3JldHVybiAnICsgZXhwcjsgfVxuXG4gICAgICByZXR1cm4gbmV3IEZ1bmN0aW9uKCdFJywgZXhwciArICc7JykgICAgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1uZXctZnVuY1xuICAgIH1cblxuICAgIHZhciBSRV9EUVVPVEUgPSAvXFx1MjA1Ny9nO1xuICAgIHZhciBSRV9RQk1BUksgPSAvXFx1MjA1NyhcXGQrKX4vZztcblxuICAgIGZ1bmN0aW9uIF9nZXRUbXBsIChzdHIpIHtcbiAgICAgIHZhciBwYXJ0cyA9IGJyYWNrZXRzLnNwbGl0KHN0ci5yZXBsYWNlKFJFX0RRVU9URSwgJ1wiJyksIDEpO1xuICAgICAgdmFyIHFzdHIgPSBwYXJ0cy5xYmxvY2tzO1xuICAgICAgdmFyIGV4cHI7XG5cbiAgICAgIGlmIChwYXJ0cy5sZW5ndGggPiAyIHx8IHBhcnRzWzBdKSB7XG4gICAgICAgIHZhciBpLCBqLCBsaXN0ID0gW107XG5cbiAgICAgICAgZm9yIChpID0gaiA9IDA7IGkgPCBwYXJ0cy5sZW5ndGg7ICsraSkge1xuXG4gICAgICAgICAgZXhwciA9IHBhcnRzW2ldO1xuXG4gICAgICAgICAgaWYgKGV4cHIgJiYgKGV4cHIgPSBpICYgMVxuXG4gICAgICAgICAgICAgID8gX3BhcnNlRXhwcihleHByLCAxLCBxc3RyKVxuXG4gICAgICAgICAgICAgIDogJ1wiJyArIGV4cHJcbiAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKC9cXFxcL2csICdcXFxcXFxcXCcpXG4gICAgICAgICAgICAgICAgICAucmVwbGFjZSgvXFxyXFxuP3xcXG4vZywgJ1xcXFxuJylcbiAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKC9cIi9nLCAnXFxcXFwiJykgK1xuICAgICAgICAgICAgICAgICdcIidcblxuICAgICAgICAgICAgKSkgeyBsaXN0W2orK10gPSBleHByOyB9XG5cbiAgICAgICAgfVxuXG4gICAgICAgIGV4cHIgPSBqIDwgMiA/IGxpc3RbMF1cbiAgICAgICAgICAgICA6ICdbJyArIGxpc3Quam9pbignLCcpICsgJ10uam9pbihcIlwiKSc7XG5cbiAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgZXhwciA9IF9wYXJzZUV4cHIocGFydHNbMV0sIDAsIHFzdHIpO1xuICAgICAgfVxuXG4gICAgICBpZiAocXN0ci5sZW5ndGgpIHtcbiAgICAgICAgZXhwciA9IGV4cHIucmVwbGFjZShSRV9RQk1BUkssIGZ1bmN0aW9uIChfLCBwb3MpIHtcbiAgICAgICAgICByZXR1cm4gcXN0cltwb3NdXG4gICAgICAgICAgICAucmVwbGFjZSgvXFxyL2csICdcXFxccicpXG4gICAgICAgICAgICAucmVwbGFjZSgvXFxuL2csICdcXFxcbicpXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGV4cHJcbiAgICB9XG5cbiAgICB2YXIgUkVfQ1NOQU1FID0gL14oPzooLT9bX0EtWmEtelxceEEwLVxceEZGXVstXFx3XFx4QTAtXFx4RkZdKil8XFx1MjA1NyhcXGQrKX4pOi87XG4gICAgdmFyXG4gICAgICBSRV9CUkVORCA9IHtcbiAgICAgICAgJygnOiAvWygpXS9nLFxuICAgICAgICAnWyc6IC9bW1xcXV0vZyxcbiAgICAgICAgJ3snOiAvW3t9XS9nXG4gICAgICB9O1xuXG4gICAgZnVuY3Rpb24gX3BhcnNlRXhwciAoZXhwciwgYXNUZXh0LCBxc3RyKSB7XG5cbiAgICAgIGV4cHIgPSBleHByXG4gICAgICAgIC5yZXBsYWNlKC9cXHMrL2csICcgJykudHJpbSgpXG4gICAgICAgIC5yZXBsYWNlKC9cXCA/KFtbXFwoe30sP1xcLjpdKVxcID8vZywgJyQxJyk7XG5cbiAgICAgIGlmIChleHByKSB7XG4gICAgICAgIHZhclxuICAgICAgICAgIGxpc3QgPSBbXSxcbiAgICAgICAgICBjbnQgPSAwLFxuICAgICAgICAgIG1hdGNoO1xuXG4gICAgICAgIHdoaWxlIChleHByICYmXG4gICAgICAgICAgICAgIChtYXRjaCA9IGV4cHIubWF0Y2goUkVfQ1NOQU1FKSkgJiZcbiAgICAgICAgICAgICAgIW1hdGNoLmluZGV4XG4gICAgICAgICAgKSB7XG4gICAgICAgICAgdmFyXG4gICAgICAgICAgICBrZXksXG4gICAgICAgICAgICBqc2IsXG4gICAgICAgICAgICByZSA9IC8sfChbW3soXSl8JC9nO1xuXG4gICAgICAgICAgZXhwciA9IFJlZ0V4cC5yaWdodENvbnRleHQ7XG4gICAgICAgICAga2V5ICA9IG1hdGNoWzJdID8gcXN0clttYXRjaFsyXV0uc2xpY2UoMSwgLTEpLnRyaW0oKS5yZXBsYWNlKC9cXHMrL2csICcgJykgOiBtYXRjaFsxXTtcblxuICAgICAgICAgIHdoaWxlIChqc2IgPSAobWF0Y2ggPSByZS5leGVjKGV4cHIpKVsxXSkgeyBza2lwQnJhY2VzKGpzYiwgcmUpOyB9XG5cbiAgICAgICAgICBqc2IgID0gZXhwci5zbGljZSgwLCBtYXRjaC5pbmRleCk7XG4gICAgICAgICAgZXhwciA9IFJlZ0V4cC5yaWdodENvbnRleHQ7XG5cbiAgICAgICAgICBsaXN0W2NudCsrXSA9IF93cmFwRXhwcihqc2IsIDEsIGtleSk7XG4gICAgICAgIH1cblxuICAgICAgICBleHByID0gIWNudCA/IF93cmFwRXhwcihleHByLCBhc1RleHQpXG4gICAgICAgICAgICAgOiBjbnQgPiAxID8gJ1snICsgbGlzdC5qb2luKCcsJykgKyAnXS5qb2luKFwiIFwiKS50cmltKCknIDogbGlzdFswXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBleHByXG5cbiAgICAgIGZ1bmN0aW9uIHNraXBCcmFjZXMgKGNoLCByZSkge1xuICAgICAgICB2YXJcbiAgICAgICAgICBtbSxcbiAgICAgICAgICBsdiA9IDEsXG4gICAgICAgICAgaXIgPSBSRV9CUkVORFtjaF07XG5cbiAgICAgICAgaXIubGFzdEluZGV4ID0gcmUubGFzdEluZGV4O1xuICAgICAgICB3aGlsZSAobW0gPSBpci5leGVjKGV4cHIpKSB7XG4gICAgICAgICAgaWYgKG1tWzBdID09PSBjaCkgeyArK2x2OyB9XG4gICAgICAgICAgZWxzZSBpZiAoIS0tbHYpIHsgYnJlYWsgfVxuICAgICAgICB9XG4gICAgICAgIHJlLmxhc3RJbmRleCA9IGx2ID8gZXhwci5sZW5ndGggOiBpci5sYXN0SW5kZXg7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gaXN0YW5idWwgaWdub3JlIG5leHQ6IG5vdCBib3RoXG4gICAgdmFyIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBtYXgtbGVuXG4gICAgICBKU19DT05URVhUID0gJ1wiaW4gdGhpcz90aGlzOicgKyAodHlwZW9mIHdpbmRvdyAhPT0gJ29iamVjdCcgPyAnZ2xvYmFsJyA6ICd3aW5kb3cnKSArICcpLicsXG4gICAgICBKU19WQVJOQU1FID0gL1sse11bXFwkXFx3XSsoPz06KXwoXiAqfFteJFxcd1xcLntdKSg/ISg/OnR5cGVvZnx0cnVlfGZhbHNlfG51bGx8dW5kZWZpbmVkfGlufGluc3RhbmNlb2Z8aXMoPzpGaW5pdGV8TmFOKXx2b2lkfE5hTnxuZXd8RGF0ZXxSZWdFeHB8TWF0aCkoPyFbJFxcd10pKShbJF9BLVphLXpdWyRcXHddKikvZyxcbiAgICAgIEpTX05PUFJPUFMgPSAvXig/PShcXC5bJFxcd10rKSlcXDEoPzpbXi5bKF18JCkvO1xuXG4gICAgZnVuY3Rpb24gX3dyYXBFeHByIChleHByLCBhc1RleHQsIGtleSkge1xuICAgICAgdmFyIHRiO1xuXG4gICAgICBleHByID0gZXhwci5yZXBsYWNlKEpTX1ZBUk5BTUUsIGZ1bmN0aW9uIChtYXRjaCwgcCwgbXZhciwgcG9zLCBzKSB7XG4gICAgICAgIGlmIChtdmFyKSB7XG4gICAgICAgICAgcG9zID0gdGIgPyAwIDogcG9zICsgbWF0Y2gubGVuZ3RoO1xuXG4gICAgICAgICAgaWYgKG12YXIgIT09ICd0aGlzJyAmJiBtdmFyICE9PSAnZ2xvYmFsJyAmJiBtdmFyICE9PSAnd2luZG93Jykge1xuICAgICAgICAgICAgbWF0Y2ggPSBwICsgJyhcIicgKyBtdmFyICsgSlNfQ09OVEVYVCArIG12YXI7XG4gICAgICAgICAgICBpZiAocG9zKSB7IHRiID0gKHMgPSBzW3Bvc10pID09PSAnLicgfHwgcyA9PT0gJygnIHx8IHMgPT09ICdbJzsgfVxuICAgICAgICAgIH0gZWxzZSBpZiAocG9zKSB7XG4gICAgICAgICAgICB0YiA9ICFKU19OT1BST1BTLnRlc3Qocy5zbGljZShwb3MpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1hdGNoXG4gICAgICB9KTtcblxuICAgICAgaWYgKHRiKSB7XG4gICAgICAgIGV4cHIgPSAndHJ5e3JldHVybiAnICsgZXhwciArICd9Y2F0Y2goZSl7RShlLHRoaXMpfSc7XG4gICAgICB9XG5cbiAgICAgIGlmIChrZXkpIHtcblxuICAgICAgICBleHByID0gKHRiXG4gICAgICAgICAgICA/ICdmdW5jdGlvbigpeycgKyBleHByICsgJ30uY2FsbCh0aGlzKScgOiAnKCcgKyBleHByICsgJyknXG4gICAgICAgICAgKSArICc/XCInICsga2V5ICsgJ1wiOlwiXCInO1xuXG4gICAgICB9IGVsc2UgaWYgKGFzVGV4dCkge1xuXG4gICAgICAgIGV4cHIgPSAnZnVuY3Rpb24odil7JyArICh0YlxuICAgICAgICAgICAgPyBleHByLnJlcGxhY2UoJ3JldHVybiAnLCAndj0nKSA6ICd2PSgnICsgZXhwciArICcpJ1xuICAgICAgICAgICkgKyAnO3JldHVybiB2fHx2PT09MD92OlwiXCJ9LmNhbGwodGhpcyknO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZXhwclxuICAgIH1cblxuICAgIF90bXBsLnZlcnNpb24gPSBicmFja2V0cy52ZXJzaW9uID0gJ3YzLjAuOCc7XG5cbiAgICByZXR1cm4gX3RtcGxcblxuICB9KSgpO1xuXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gIHZhciBvYnNlcnZhYmxlID0gZnVuY3Rpb24oZWwpIHtcblxuICAgIC8qKlxuICAgICAqIEV4dGVuZCB0aGUgb3JpZ2luYWwgb2JqZWN0IG9yIGNyZWF0ZSBhIG5ldyBlbXB0eSBvbmVcbiAgICAgKiBAdHlwZSB7IE9iamVjdCB9XG4gICAgICovXG5cbiAgICBlbCA9IGVsIHx8IHt9O1xuXG4gICAgLyoqXG4gICAgICogUHJpdmF0ZSB2YXJpYWJsZXNcbiAgICAgKi9cbiAgICB2YXIgY2FsbGJhY2tzID0ge30sXG4gICAgICBzbGljZSA9IEFycmF5LnByb3RvdHlwZS5zbGljZTtcblxuICAgIC8qKlxuICAgICAqIFB1YmxpYyBBcGlcbiAgICAgKi9cblxuICAgIC8vIGV4dGVuZCB0aGUgZWwgb2JqZWN0IGFkZGluZyB0aGUgb2JzZXJ2YWJsZSBtZXRob2RzXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoZWwsIHtcbiAgICAgIC8qKlxuICAgICAgICogTGlzdGVuIHRvIHRoZSBnaXZlbiBgZXZlbnRgIGFuZHNcbiAgICAgICAqIGV4ZWN1dGUgdGhlIGBjYWxsYmFja2AgZWFjaCB0aW1lIGFuIGV2ZW50IGlzIHRyaWdnZXJlZC5cbiAgICAgICAqIEBwYXJhbSAgeyBTdHJpbmcgfSBldmVudCAtIGV2ZW50IGlkXG4gICAgICAgKiBAcGFyYW0gIHsgRnVuY3Rpb24gfSBmbiAtIGNhbGxiYWNrIGZ1bmN0aW9uXG4gICAgICAgKiBAcmV0dXJucyB7IE9iamVjdCB9IGVsXG4gICAgICAgKi9cbiAgICAgIG9uOiB7XG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbihldmVudCwgZm4pIHtcbiAgICAgICAgICBpZiAodHlwZW9mIGZuID09ICdmdW5jdGlvbicpXG4gICAgICAgICAgICB7IChjYWxsYmFja3NbZXZlbnRdID0gY2FsbGJhY2tzW2V2ZW50XSB8fCBbXSkucHVzaChmbik7IH1cbiAgICAgICAgICByZXR1cm4gZWxcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIHdyaXRhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiBmYWxzZVxuICAgICAgfSxcblxuICAgICAgLyoqXG4gICAgICAgKiBSZW1vdmVzIHRoZSBnaXZlbiBgZXZlbnRgIGxpc3RlbmVyc1xuICAgICAgICogQHBhcmFtICAgeyBTdHJpbmcgfSBldmVudCAtIGV2ZW50IGlkXG4gICAgICAgKiBAcGFyYW0gICB7IEZ1bmN0aW9uIH0gZm4gLSBjYWxsYmFjayBmdW5jdGlvblxuICAgICAgICogQHJldHVybnMgeyBPYmplY3QgfSBlbFxuICAgICAgICovXG4gICAgICBvZmY6IHtcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uKGV2ZW50LCBmbikge1xuICAgICAgICAgIGlmIChldmVudCA9PSAnKicgJiYgIWZuKSB7IGNhbGxiYWNrcyA9IHt9OyB9XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAoZm4pIHtcbiAgICAgICAgICAgICAgdmFyIGFyciA9IGNhbGxiYWNrc1tldmVudF07XG4gICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBjYjsgY2IgPSBhcnIgJiYgYXJyW2ldOyArK2kpIHtcbiAgICAgICAgICAgICAgICBpZiAoY2IgPT0gZm4pIHsgYXJyLnNwbGljZShpLS0sIDEpOyB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7IGRlbGV0ZSBjYWxsYmFja3NbZXZlbnRdOyB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBlbFxuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgd3JpdGFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IGZhbHNlXG4gICAgICB9LFxuXG4gICAgICAvKipcbiAgICAgICAqIExpc3RlbiB0byB0aGUgZ2l2ZW4gYGV2ZW50YCBhbmRcbiAgICAgICAqIGV4ZWN1dGUgdGhlIGBjYWxsYmFja2AgYXQgbW9zdCBvbmNlXG4gICAgICAgKiBAcGFyYW0gICB7IFN0cmluZyB9IGV2ZW50IC0gZXZlbnQgaWRcbiAgICAgICAqIEBwYXJhbSAgIHsgRnVuY3Rpb24gfSBmbiAtIGNhbGxiYWNrIGZ1bmN0aW9uXG4gICAgICAgKiBAcmV0dXJucyB7IE9iamVjdCB9IGVsXG4gICAgICAgKi9cbiAgICAgIG9uZToge1xuICAgICAgICB2YWx1ZTogZnVuY3Rpb24oZXZlbnQsIGZuKSB7XG4gICAgICAgICAgZnVuY3Rpb24gb24oKSB7XG4gICAgICAgICAgICBlbC5vZmYoZXZlbnQsIG9uKTtcbiAgICAgICAgICAgIGZuLmFwcGx5KGVsLCBhcmd1bWVudHMpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gZWwub24oZXZlbnQsIG9uKVxuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgd3JpdGFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IGZhbHNlXG4gICAgICB9LFxuXG4gICAgICAvKipcbiAgICAgICAqIEV4ZWN1dGUgYWxsIGNhbGxiYWNrIGZ1bmN0aW9ucyB0aGF0IGxpc3RlbiB0b1xuICAgICAgICogdGhlIGdpdmVuIGBldmVudGBcbiAgICAgICAqIEBwYXJhbSAgIHsgU3RyaW5nIH0gZXZlbnQgLSBldmVudCBpZFxuICAgICAgICogQHJldHVybnMgeyBPYmplY3QgfSBlbFxuICAgICAgICovXG4gICAgICB0cmlnZ2VyOiB7XG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbihldmVudCkge1xuICAgICAgICAgIHZhciBhcmd1bWVudHMkMSA9IGFyZ3VtZW50cztcblxuXG4gICAgICAgICAgLy8gZ2V0dGluZyB0aGUgYXJndW1lbnRzXG4gICAgICAgICAgdmFyIGFyZ2xlbiA9IGFyZ3VtZW50cy5sZW5ndGggLSAxLFxuICAgICAgICAgICAgYXJncyA9IG5ldyBBcnJheShhcmdsZW4pLFxuICAgICAgICAgICAgZm5zLFxuICAgICAgICAgICAgZm4sXG4gICAgICAgICAgICBpO1xuXG4gICAgICAgICAgZm9yIChpID0gMDsgaSA8IGFyZ2xlbjsgaSsrKSB7XG4gICAgICAgICAgICBhcmdzW2ldID0gYXJndW1lbnRzJDFbaSArIDFdOyAvLyBza2lwIGZpcnN0IGFyZ3VtZW50XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZm5zID0gc2xpY2UuY2FsbChjYWxsYmFja3NbZXZlbnRdIHx8IFtdLCAwKTtcblxuICAgICAgICAgIGZvciAoaSA9IDA7IGZuID0gZm5zW2ldOyArK2kpIHtcbiAgICAgICAgICAgIGZuLmFwcGx5KGVsLCBhcmdzKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoY2FsbGJhY2tzWycqJ10gJiYgZXZlbnQgIT0gJyonKVxuICAgICAgICAgICAgeyBlbC50cmlnZ2VyLmFwcGx5KGVsLCBbJyonLCBldmVudF0uY29uY2F0KGFyZ3MpKTsgfVxuXG4gICAgICAgICAgcmV0dXJuIGVsXG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICB3cml0YWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2VcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHJldHVybiBlbFxuXG4gIH07XG5cbiAgLyoqXG4gICAqIFNob3J0IGFsaWFzIGZvciBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yXG4gICAqL1xuICBmdW5jdGlvbiBnZXRQcm9wRGVzY3JpcHRvciAobywgaykge1xuICAgIHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG8sIGspXG4gIH1cblxuICAvKipcbiAgICogQ2hlY2sgaWYgcGFzc2VkIGFyZ3VtZW50IGlzIHVuZGVmaW5lZFxuICAgKiBAcGFyYW0gICB7ICogfSB2YWx1ZSAtXG4gICAqIEByZXR1cm5zIHsgQm9vbGVhbiB9IC1cbiAgICovXG4gIGZ1bmN0aW9uIGlzVW5kZWZpbmVkKHZhbHVlKSB7XG4gICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gVF9VTkRFRlxuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrIHdoZXRoZXIgb2JqZWN0J3MgcHJvcGVydHkgY291bGQgYmUgb3ZlcnJpZGRlblxuICAgKiBAcGFyYW0gICB7IE9iamVjdCB9ICBvYmogLSBzb3VyY2Ugb2JqZWN0XG4gICAqIEBwYXJhbSAgIHsgU3RyaW5nIH0gIGtleSAtIG9iamVjdCBwcm9wZXJ0eVxuICAgKiBAcmV0dXJucyB7IEJvb2xlYW4gfSB0cnVlIGlmIHdyaXRhYmxlXG4gICAqL1xuICBmdW5jdGlvbiBpc1dyaXRhYmxlKG9iaiwga2V5KSB7XG4gICAgdmFyIGRlc2NyaXB0b3IgPSBnZXRQcm9wRGVzY3JpcHRvcihvYmosIGtleSk7XG4gICAgcmV0dXJuIGlzVW5kZWZpbmVkKG9ialtrZXldKSB8fCBkZXNjcmlwdG9yICYmIGRlc2NyaXB0b3Iud3JpdGFibGVcbiAgfVxuXG4gIC8qKlxuICAgKiBFeHRlbmQgYW55IG9iamVjdCB3aXRoIG90aGVyIHByb3BlcnRpZXNcbiAgICogQHBhcmFtICAgeyBPYmplY3QgfSBzcmMgLSBzb3VyY2Ugb2JqZWN0XG4gICAqIEByZXR1cm5zIHsgT2JqZWN0IH0gdGhlIHJlc3VsdGluZyBleHRlbmRlZCBvYmplY3RcbiAgICpcbiAgICogdmFyIG9iaiA9IHsgZm9vOiAnYmF6JyB9XG4gICAqIGV4dGVuZChvYmosIHtiYXI6ICdiYXInLCBmb286ICdiYXInfSlcbiAgICogY29uc29sZS5sb2cob2JqKSA9PiB7YmFyOiAnYmFyJywgZm9vOiAnYmFyJ31cbiAgICpcbiAgICovXG4gIGZ1bmN0aW9uIGV4dGVuZChzcmMpIHtcbiAgICB2YXIgb2JqO1xuICAgIHZhciBpID0gMTtcbiAgICB2YXIgYXJncyA9IGFyZ3VtZW50cztcbiAgICB2YXIgbCA9IGFyZ3MubGVuZ3RoO1xuXG4gICAgZm9yICg7IGkgPCBsOyBpKyspIHtcbiAgICAgIGlmIChvYmogPSBhcmdzW2ldKSB7XG4gICAgICAgIGZvciAodmFyIGtleSBpbiBvYmopIHtcbiAgICAgICAgICAvLyBjaGVjayBpZiB0aGlzIHByb3BlcnR5IG9mIHRoZSBzb3VyY2Ugb2JqZWN0IGNvdWxkIGJlIG92ZXJyaWRkZW5cbiAgICAgICAgICBpZiAoaXNXcml0YWJsZShzcmMsIGtleSkpXG4gICAgICAgICAgICB7IHNyY1trZXldID0gb2JqW2tleV07IH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gc3JjXG4gIH1cblxuICAvKipcbiAgICogQWxpYXMgZm9yIE9iamVjdC5jcmVhdGVcbiAgICovXG4gIGZ1bmN0aW9uIGNyZWF0ZShzcmMpIHtcbiAgICByZXR1cm4gT2JqZWN0LmNyZWF0ZShzcmMpXG4gIH1cblxuICB2YXIgc2V0dGluZ3MgPSBleHRlbmQoY3JlYXRlKGJyYWNrZXRzLnNldHRpbmdzKSwge1xuICAgIHNraXBBbm9ueW1vdXNUYWdzOiB0cnVlLFxuICAgIC8vIGhhbmRsZSB0aGUgYXV0byB1cGRhdGVzIG9uIGFueSBET00gZXZlbnRcbiAgICBhdXRvVXBkYXRlOiB0cnVlXG4gIH0pXG5cbiAgLyoqXG4gICAqIFNob3J0ZXIgYW5kIGZhc3Qgd2F5IHRvIHNlbGVjdCBtdWx0aXBsZSBub2RlcyBpbiB0aGUgRE9NXG4gICAqIEBwYXJhbSAgIHsgU3RyaW5nIH0gc2VsZWN0b3IgLSBET00gc2VsZWN0b3JcbiAgICogQHBhcmFtICAgeyBPYmplY3QgfSBjdHggLSBET00gbm9kZSB3aGVyZSB0aGUgdGFyZ2V0cyBvZiBvdXIgc2VhcmNoIHdpbGwgaXMgbG9jYXRlZFxuICAgKiBAcmV0dXJucyB7IE9iamVjdCB9IGRvbSBub2RlcyBmb3VuZFxuICAgKi9cbiAgZnVuY3Rpb24gJCQoc2VsZWN0b3IsIGN0eCkge1xuICAgIHJldHVybiBbXS5zbGljZS5jYWxsKChjdHggfHwgZG9jdW1lbnQpLnF1ZXJ5U2VsZWN0b3JBbGwoc2VsZWN0b3IpKVxuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIGRvY3VtZW50IHRleHQgbm9kZVxuICAgKiBAcmV0dXJucyB7IE9iamVjdCB9IGNyZWF0ZSBhIHRleHQgbm9kZSB0byB1c2UgYXMgcGxhY2Vob2xkZXJcbiAgICovXG4gIGZ1bmN0aW9uIGNyZWF0ZURPTVBsYWNlaG9sZGVyKCkge1xuICAgIHJldHVybiBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSgnJylcbiAgfVxuXG4gIC8qKlxuICAgKiBUb2dnbGUgdGhlIHZpc2liaWxpdHkgb2YgYW55IERPTSBub2RlXG4gICAqIEBwYXJhbSAgIHsgT2JqZWN0IH0gIGRvbSAtIERPTSBub2RlIHdlIHdhbnQgdG8gaGlkZVxuICAgKiBAcGFyYW0gICB7IEJvb2xlYW4gfSBzaG93IC0gZG8gd2Ugd2FudCB0byBzaG93IGl0P1xuICAgKi9cblxuICBmdW5jdGlvbiB0b2dnbGVWaXNpYmlsaXR5KGRvbSwgc2hvdykge1xuICAgIGRvbS5zdHlsZS5kaXNwbGF5ID0gc2hvdyA/ICcnIDogJ25vbmUnO1xuICAgIGRvbS5oaWRkZW4gPSBzaG93ID8gZmFsc2UgOiB0cnVlO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgdmFsdWUgb2YgYW55IERPTSBhdHRyaWJ1dGUgb24gYSBub2RlXG4gICAqIEBwYXJhbSAgIHsgT2JqZWN0IH0gZG9tIC0gRE9NIG5vZGUgd2Ugd2FudCB0byBwYXJzZVxuICAgKiBAcGFyYW0gICB7IFN0cmluZyB9IG5hbWUgLSBuYW1lIG9mIHRoZSBhdHRyaWJ1dGUgd2Ugd2FudCB0byBnZXRcbiAgICogQHJldHVybnMgeyBTdHJpbmcgfCB1bmRlZmluZWQgfSBuYW1lIG9mIHRoZSBub2RlIGF0dHJpYnV0ZSB3aGV0aGVyIGl0IGV4aXN0c1xuICAgKi9cbiAgZnVuY3Rpb24gZ2V0QXR0cmlidXRlKGRvbSwgbmFtZSkge1xuICAgIHJldHVybiBkb20uZ2V0QXR0cmlidXRlKG5hbWUpXG4gIH1cblxuICAvKipcbiAgICogUmVtb3ZlIGFueSBET00gYXR0cmlidXRlIGZyb20gYSBub2RlXG4gICAqIEBwYXJhbSAgIHsgT2JqZWN0IH0gZG9tIC0gRE9NIG5vZGUgd2Ugd2FudCB0byB1cGRhdGVcbiAgICogQHBhcmFtICAgeyBTdHJpbmcgfSBuYW1lIC0gbmFtZSBvZiB0aGUgcHJvcGVydHkgd2Ugd2FudCB0byByZW1vdmVcbiAgICovXG4gIGZ1bmN0aW9uIHJlbW92ZUF0dHJpYnV0ZShkb20sIG5hbWUpIHtcbiAgICBkb20ucmVtb3ZlQXR0cmlidXRlKG5hbWUpO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldCB0aGUgaW5uZXIgaHRtbCBvZiBhbnkgRE9NIG5vZGUgU1ZHcyBpbmNsdWRlZFxuICAgKiBAcGFyYW0geyBPYmplY3QgfSBjb250YWluZXIgLSBET00gbm9kZSB3aGVyZSB3ZSdsbCBpbmplY3QgbmV3IGh0bWxcbiAgICogQHBhcmFtIHsgU3RyaW5nIH0gaHRtbCAtIGh0bWwgdG8gaW5qZWN0XG4gICAqIEBwYXJhbSB7IEJvb2xlYW4gfSBpc1N2ZyAtIHN2ZyB0YWdzIHNob3VsZCBiZSB0cmVhdGVkIGEgYml0IGRpZmZlcmVudGx5XG4gICAqL1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICBmdW5jdGlvbiBzZXRJbm5lckhUTUwoY29udGFpbmVyLCBodG1sLCBpc1N2Zykge1xuICAgIC8vIGlubmVySFRNTCBpcyBub3Qgc3VwcG9ydGVkIG9uIHN2ZyB0YWdzIHNvIHdlIG5lZXQgdG8gdHJlYXQgdGhlbSBkaWZmZXJlbnRseVxuICAgIGlmIChpc1N2Zykge1xuICAgICAgdmFyIG5vZGUgPSBjb250YWluZXIub3duZXJEb2N1bWVudC5pbXBvcnROb2RlKFxuICAgICAgICBuZXcgRE9NUGFyc2VyKClcbiAgICAgICAgICAucGFyc2VGcm9tU3RyaW5nKChcIjxzdmcgeG1sbnM9XFxcIlwiICsgU1ZHX05TICsgXCJcXFwiPlwiICsgaHRtbCArIFwiPC9zdmc+XCIpLCAnYXBwbGljYXRpb24veG1sJylcbiAgICAgICAgICAuZG9jdW1lbnRFbGVtZW50LFxuICAgICAgICB0cnVlXG4gICAgICApO1xuXG4gICAgICBjb250YWluZXIuYXBwZW5kQ2hpbGQobm9kZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnRhaW5lci5pbm5lckhUTUwgPSBodG1sO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBNaW5pbWl6ZSByaXNrOiBvbmx5IHplcm8gb3Igb25lIF9zcGFjZV8gYmV0d2VlbiBhdHRyICYgdmFsdWVcbiAgICogQHBhcmFtICAgeyBTdHJpbmcgfSAgIGh0bWwgLSBodG1sIHN0cmluZyB3ZSB3YW50IHRvIHBhcnNlXG4gICAqIEBwYXJhbSAgIHsgRnVuY3Rpb24gfSBmbiAtIGNhbGxiYWNrIGZ1bmN0aW9uIHRvIGFwcGx5IG9uIGFueSBhdHRyaWJ1dGUgZm91bmRcbiAgICovXG4gIGZ1bmN0aW9uIHdhbGtBdHRyaWJ1dGVzKGh0bWwsIGZuKSB7XG4gICAgaWYgKCFodG1sKSB7IHJldHVybiB9XG4gICAgdmFyIG07XG4gICAgd2hpbGUgKG0gPSBSRV9IVE1MX0FUVFJTLmV4ZWMoaHRtbCkpXG4gICAgICB7IGZuKG1bMV0udG9Mb3dlckNhc2UoKSwgbVsyXSB8fCBtWzNdIHx8IG1bNF0pOyB9XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIGEgZG9jdW1lbnQgZnJhZ21lbnRcbiAgICogQHJldHVybnMgeyBPYmplY3QgfSBkb2N1bWVudCBmcmFnbWVudFxuICAgKi9cbiAgZnVuY3Rpb24gY3JlYXRlRnJhZ21lbnQoKSB7XG4gICAgcmV0dXJuIGRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKVxuICB9XG5cbiAgLyoqXG4gICAqIEluc2VydCBzYWZlbHkgYSB0YWcgdG8gZml4ICMxOTYyICMxNjQ5XG4gICAqIEBwYXJhbSAgIHsgSFRNTEVsZW1lbnQgfSByb290IC0gY2hpbGRyZW4gY29udGFpbmVyXG4gICAqIEBwYXJhbSAgIHsgSFRNTEVsZW1lbnQgfSBjdXJyIC0gbm9kZSB0byBpbnNlcnRcbiAgICogQHBhcmFtICAgeyBIVE1MRWxlbWVudCB9IG5leHQgLSBub2RlIHRoYXQgc2hvdWxkIHByZWNlZWQgdGhlIGN1cnJlbnQgbm9kZSBpbnNlcnRlZFxuICAgKi9cbiAgZnVuY3Rpb24gc2FmZUluc2VydChyb290LCBjdXJyLCBuZXh0KSB7XG4gICAgcm9vdC5pbnNlcnRCZWZvcmUoY3VyciwgbmV4dC5wYXJlbnROb2RlICYmIG5leHQpO1xuICB9XG5cbiAgLyoqXG4gICAqIENvbnZlcnQgYSBzdHlsZSBvYmplY3QgdG8gYSBzdHJpbmdcbiAgICogQHBhcmFtICAgeyBPYmplY3QgfSBzdHlsZSAtIHN0eWxlIG9iamVjdCB3ZSBuZWVkIHRvIHBhcnNlXG4gICAqIEByZXR1cm5zIHsgU3RyaW5nIH0gcmVzdWx0aW5nIGNzcyBzdHJpbmdcbiAgICogQGV4YW1wbGVcbiAgICogc3R5bGVPYmplY3RUb1N0cmluZyh7IGNvbG9yOiAncmVkJywgaGVpZ2h0OiAnMTBweCd9KSAvLyA9PiAnY29sb3I6IHJlZDsgaGVpZ2h0OiAxMHB4J1xuICAgKi9cbiAgZnVuY3Rpb24gc3R5bGVPYmplY3RUb1N0cmluZyhzdHlsZSkge1xuICAgIHJldHVybiBPYmplY3Qua2V5cyhzdHlsZSkucmVkdWNlKGZ1bmN0aW9uIChhY2MsIHByb3ApIHtcbiAgICAgIHJldHVybiAoYWNjICsgXCIgXCIgKyBwcm9wICsgXCI6IFwiICsgKHN0eWxlW3Byb3BdKSArIFwiO1wiKVxuICAgIH0sICcnKVxuICB9XG5cbiAgLyoqXG4gICAqIFdhbGsgZG93biByZWN1cnNpdmVseSBhbGwgdGhlIGNoaWxkcmVuIHRhZ3Mgc3RhcnRpbmcgZG9tIG5vZGVcbiAgICogQHBhcmFtICAgeyBPYmplY3QgfSAgIGRvbSAtIHN0YXJ0aW5nIG5vZGUgd2hlcmUgd2Ugd2lsbCBzdGFydCB0aGUgcmVjdXJzaW9uXG4gICAqIEBwYXJhbSAgIHsgRnVuY3Rpb24gfSBmbiAtIGNhbGxiYWNrIHRvIHRyYW5zZm9ybSB0aGUgY2hpbGQgbm9kZSBqdXN0IGZvdW5kXG4gICAqIEBwYXJhbSAgIHsgT2JqZWN0IH0gICBjb250ZXh0IC0gZm4gY2FuIG9wdGlvbmFsbHkgcmV0dXJuIGFuIG9iamVjdCwgd2hpY2ggaXMgcGFzc2VkIHRvIGNoaWxkcmVuXG4gICAqL1xuICBmdW5jdGlvbiB3YWxrTm9kZXMoZG9tLCBmbiwgY29udGV4dCkge1xuICAgIGlmIChkb20pIHtcbiAgICAgIHZhciByZXMgPSBmbihkb20sIGNvbnRleHQpO1xuICAgICAgdmFyIG5leHQ7XG4gICAgICAvLyBzdG9wIHRoZSByZWN1cnNpb25cbiAgICAgIGlmIChyZXMgPT09IGZhbHNlKSB7IHJldHVybiB9XG5cbiAgICAgIGRvbSA9IGRvbS5maXJzdENoaWxkO1xuXG4gICAgICB3aGlsZSAoZG9tKSB7XG4gICAgICAgIG5leHQgPSBkb20ubmV4dFNpYmxpbmc7XG4gICAgICAgIHdhbGtOb2Rlcyhkb20sIGZuLCByZXMpO1xuICAgICAgICBkb20gPSBuZXh0O1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG5cblxuICB2YXIgZG9tID0gLyojX19QVVJFX18qL09iamVjdC5mcmVlemUoe1xuICAgICQkOiAkJCxcbiAgICAkOiAkLFxuICAgIGNyZWF0ZURPTVBsYWNlaG9sZGVyOiBjcmVhdGVET01QbGFjZWhvbGRlcixcbiAgICBta0VsOiBtYWtlRWxlbWVudCxcbiAgICBzZXRBdHRyOiBzZXRBdHRyaWJ1dGUsXG4gICAgdG9nZ2xlVmlzaWJpbGl0eTogdG9nZ2xlVmlzaWJpbGl0eSxcbiAgICBnZXRBdHRyOiBnZXRBdHRyaWJ1dGUsXG4gICAgcmVtQXR0cjogcmVtb3ZlQXR0cmlidXRlLFxuICAgIHNldElubmVySFRNTDogc2V0SW5uZXJIVE1MLFxuICAgIHdhbGtBdHRyczogd2Fsa0F0dHJpYnV0ZXMsXG4gICAgY3JlYXRlRnJhZzogY3JlYXRlRnJhZ21lbnQsXG4gICAgc2FmZUluc2VydDogc2FmZUluc2VydCxcbiAgICBzdHlsZU9iamVjdFRvU3RyaW5nOiBzdHlsZU9iamVjdFRvU3RyaW5nLFxuICAgIHdhbGtOb2Rlczogd2Fsa05vZGVzXG4gIH0pO1xuXG4gIC8qKlxuICAgKiBDaGVjayBhZ2FpbnN0IHRoZSBudWxsIGFuZCB1bmRlZmluZWQgdmFsdWVzXG4gICAqIEBwYXJhbSAgIHsgKiB9ICB2YWx1ZSAtXG4gICAqIEByZXR1cm5zIHtCb29sZWFufSAtXG4gICAqL1xuICBmdW5jdGlvbiBpc05pbCh2YWx1ZSkge1xuICAgIHJldHVybiBpc1VuZGVmaW5lZCh2YWx1ZSkgfHwgdmFsdWUgPT09IG51bGxcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVjayBpZiBwYXNzZWQgYXJndW1lbnQgaXMgZW1wdHkuIERpZmZlcmVudCBmcm9tIGZhbHN5LCBiZWNhdXNlIHdlIGRvbnQgY29uc2lkZXIgMCBvciBmYWxzZSB0byBiZSBibGFua1xuICAgKiBAcGFyYW0geyAqIH0gdmFsdWUgLVxuICAgKiBAcmV0dXJucyB7IEJvb2xlYW4gfSAtXG4gICAqL1xuICBmdW5jdGlvbiBpc0JsYW5rKHZhbHVlKSB7XG4gICAgcmV0dXJuIGlzTmlsKHZhbHVlKSB8fCB2YWx1ZSA9PT0gJydcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVjayBpZiBwYXNzZWQgYXJndW1lbnQgaXMgYSBmdW5jdGlvblxuICAgKiBAcGFyYW0gICB7ICogfSB2YWx1ZSAtXG4gICAqIEByZXR1cm5zIHsgQm9vbGVhbiB9IC1cbiAgICovXG4gIGZ1bmN0aW9uIGlzRnVuY3Rpb24odmFsdWUpIHtcbiAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSBUX0ZVTkNUSU9OXG4gIH1cblxuICAvKipcbiAgICogQ2hlY2sgaWYgcGFzc2VkIGFyZ3VtZW50IGlzIGFuIG9iamVjdCwgZXhjbHVkZSBudWxsXG4gICAqIE5PVEU6IHVzZSBpc09iamVjdCh4KSAmJiAhaXNBcnJheSh4KSB0byBleGNsdWRlcyBhcnJheXMuXG4gICAqIEBwYXJhbSAgIHsgKiB9IHZhbHVlIC1cbiAgICogQHJldHVybnMgeyBCb29sZWFuIH0gLVxuICAgKi9cbiAgZnVuY3Rpb24gaXNPYmplY3QodmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUgJiYgdHlwZW9mIHZhbHVlID09PSBUX09CSkVDVCAvLyB0eXBlb2YgbnVsbCBpcyAnb2JqZWN0J1xuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrIGlmIGEgRE9NIG5vZGUgaXMgYW4gc3ZnIHRhZyBvciBwYXJ0IG9mIGFuIHN2Z1xuICAgKiBAcGFyYW0gICB7IEhUTUxFbGVtZW50IH0gIGVsIC0gbm9kZSB3ZSB3YW50IHRvIHRlc3RcbiAgICogQHJldHVybnMge0Jvb2xlYW59IHRydWUgaWYgaXQncyBhbiBzdmcgbm9kZVxuICAgKi9cbiAgZnVuY3Rpb24gaXNTdmcoZWwpIHtcbiAgICB2YXIgb3duZXIgPSBlbC5vd25lclNWR0VsZW1lbnQ7XG4gICAgcmV0dXJuICEhb3duZXIgfHwgb3duZXIgPT09IG51bGxcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVjayBpZiBwYXNzZWQgYXJndW1lbnQgaXMgYSBraW5kIG9mIGFycmF5XG4gICAqIEBwYXJhbSAgIHsgKiB9IHZhbHVlIC1cbiAgICogQHJldHVybnMgeyBCb29sZWFuIH0gLVxuICAgKi9cbiAgZnVuY3Rpb24gaXNBcnJheSh2YWx1ZSkge1xuICAgIHJldHVybiBBcnJheS5pc0FycmF5KHZhbHVlKSB8fCB2YWx1ZSBpbnN0YW5jZW9mIEFycmF5XG4gIH1cblxuICAvKipcbiAgICogQ2hlY2sgaWYgdGhlIHBhc3NlZCBhcmd1bWVudCBpcyBhIGJvb2xlYW4gYXR0cmlidXRlXG4gICAqIEBwYXJhbSAgIHsgU3RyaW5nIH0gdmFsdWUgLVxuICAgKiBAcmV0dXJucyB7IEJvb2xlYW4gfSAtXG4gICAqL1xuICBmdW5jdGlvbiBpc0Jvb2xBdHRyKHZhbHVlKSB7XG4gICAgcmV0dXJuIFJFX0JPT0xfQVRUUlMudGVzdCh2YWx1ZSlcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVjayBpZiBwYXNzZWQgYXJndW1lbnQgaXMgYSBzdHJpbmdcbiAgICogQHBhcmFtICAgeyAqIH0gdmFsdWUgLVxuICAgKiBAcmV0dXJucyB7IEJvb2xlYW4gfSAtXG4gICAqL1xuICBmdW5jdGlvbiBpc1N0cmluZyh2YWx1ZSkge1xuICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09IFRfU1RSSU5HXG4gIH1cblxuXG5cbiAgdmFyIGNoZWNrID0gLyojX19QVVJFX18qL09iamVjdC5mcmVlemUoe1xuICAgIGlzQmxhbms6IGlzQmxhbmssXG4gICAgaXNGdW5jdGlvbjogaXNGdW5jdGlvbixcbiAgICBpc09iamVjdDogaXNPYmplY3QsXG4gICAgaXNTdmc6IGlzU3ZnLFxuICAgIGlzV3JpdGFibGU6IGlzV3JpdGFibGUsXG4gICAgaXNBcnJheTogaXNBcnJheSxcbiAgICBpc0Jvb2xBdHRyOiBpc0Jvb2xBdHRyLFxuICAgIGlzTmlsOiBpc05pbCxcbiAgICBpc1N0cmluZzogaXNTdHJpbmcsXG4gICAgaXNVbmRlZmluZWQ6IGlzVW5kZWZpbmVkXG4gIH0pO1xuXG4gIC8qKlxuICAgKiBDaGVjayB3aGV0aGVyIGFuIGFycmF5IGNvbnRhaW5zIGFuIGl0ZW1cbiAgICogQHBhcmFtICAgeyBBcnJheSB9IGFycmF5IC0gdGFyZ2V0IGFycmF5XG4gICAqIEBwYXJhbSAgIHsgKiB9IGl0ZW0gLSBpdGVtIHRvIHRlc3RcbiAgICogQHJldHVybnMgeyBCb29sZWFuIH0gLVxuICAgKi9cbiAgZnVuY3Rpb24gY29udGFpbnMoYXJyYXksIGl0ZW0pIHtcbiAgICByZXR1cm4gYXJyYXkuaW5kZXhPZihpdGVtKSAhPT0gLTFcbiAgfVxuXG4gIC8qKlxuICAgKiBTcGVjaWFsaXplZCBmdW5jdGlvbiBmb3IgbG9vcGluZyBhbiBhcnJheS1saWtlIGNvbGxlY3Rpb24gd2l0aCBgZWFjaD17fWBcbiAgICogQHBhcmFtICAgeyBBcnJheSB9IGxpc3QgLSBjb2xsZWN0aW9uIG9mIGl0ZW1zXG4gICAqIEBwYXJhbSAgIHtGdW5jdGlvbn0gZm4gLSBjYWxsYmFjayBmdW5jdGlvblxuICAgKiBAcmV0dXJucyB7IEFycmF5IH0gdGhlIGFycmF5IGxvb3BlZFxuICAgKi9cbiAgZnVuY3Rpb24gZWFjaChsaXN0LCBmbikge1xuICAgIHZhciBsZW4gPSBsaXN0ID8gbGlzdC5sZW5ndGggOiAwO1xuICAgIHZhciBpID0gMDtcbiAgICBmb3IgKDsgaSA8IGxlbjsgaSsrKSB7IGZuKGxpc3RbaV0sIGkpOyB9XG4gICAgcmV0dXJuIGxpc3RcbiAgfVxuXG4gIC8qKlxuICAgKiBGYXN0ZXIgU3RyaW5nIHN0YXJ0c1dpdGggYWx0ZXJuYXRpdmVcbiAgICogQHBhcmFtICAgeyBTdHJpbmcgfSBzdHIgLSBzb3VyY2Ugc3RyaW5nXG4gICAqIEBwYXJhbSAgIHsgU3RyaW5nIH0gdmFsdWUgLSB0ZXN0IHN0cmluZ1xuICAgKiBAcmV0dXJucyB7IEJvb2xlYW4gfSAtXG4gICAqL1xuICBmdW5jdGlvbiBzdGFydHNXaXRoKHN0ciwgdmFsdWUpIHtcbiAgICByZXR1cm4gc3RyLnNsaWNlKDAsIHZhbHVlLmxlbmd0aCkgPT09IHZhbHVlXG4gIH1cblxuICAvKipcbiAgICogRnVuY3Rpb24gcmV0dXJuaW5nIGFsd2F5cyBhIHVuaXF1ZSBpZGVudGlmaWVyXG4gICAqIEByZXR1cm5zIHsgTnVtYmVyIH0gLSBudW1iZXIgZnJvbSAwLi4ublxuICAgKi9cbiAgdmFyIHVpZCA9IChmdW5jdGlvbiB1aWQoKSB7XG4gICAgdmFyIGkgPSAtMTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkgeyByZXR1cm4gKytpOyB9XG4gIH0pKClcblxuICAvKipcbiAgICogSGVscGVyIGZ1bmN0aW9uIHRvIHNldCBhbiBpbW11dGFibGUgcHJvcGVydHlcbiAgICogQHBhcmFtICAgeyBPYmplY3QgfSBlbCAtIG9iamVjdCB3aGVyZSB0aGUgbmV3IHByb3BlcnR5IHdpbGwgYmUgc2V0XG4gICAqIEBwYXJhbSAgIHsgU3RyaW5nIH0ga2V5IC0gb2JqZWN0IGtleSB3aGVyZSB0aGUgbmV3IHByb3BlcnR5IHdpbGwgYmUgc3RvcmVkXG4gICAqIEBwYXJhbSAgIHsgKiB9IHZhbHVlIC0gdmFsdWUgb2YgdGhlIG5ldyBwcm9wZXJ0eVxuICAgKiBAcGFyYW0gICB7IE9iamVjdCB9IG9wdGlvbnMgLSBzZXQgdGhlIHByb3Blcnkgb3ZlcnJpZGluZyB0aGUgZGVmYXVsdCBvcHRpb25zXG4gICAqIEByZXR1cm5zIHsgT2JqZWN0IH0gLSB0aGUgaW5pdGlhbCBvYmplY3RcbiAgICovXG4gIGZ1bmN0aW9uIGRlZmluZShlbCwga2V5LCB2YWx1ZSwgb3B0aW9ucykge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlbCwga2V5LCBleHRlbmQoe1xuICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICB3cml0YWJsZTogZmFsc2UsXG4gICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9LCBvcHRpb25zKSk7XG4gICAgcmV0dXJuIGVsXG4gIH1cblxuICAvKipcbiAgICogQ29udmVydCBhIHN0cmluZyBjb250YWluaW5nIGRhc2hlcyB0byBjYW1lbCBjYXNlXG4gICAqIEBwYXJhbSAgIHsgU3RyaW5nIH0gc3RyIC0gaW5wdXQgc3RyaW5nXG4gICAqIEByZXR1cm5zIHsgU3RyaW5nIH0gbXktc3RyaW5nIC0+IG15U3RyaW5nXG4gICAqL1xuICBmdW5jdGlvbiB0b0NhbWVsKHN0cikge1xuICAgIHJldHVybiBzdHIucmVwbGFjZSgvLShcXHcpL2csIGZ1bmN0aW9uIChfLCBjKSB7IHJldHVybiBjLnRvVXBwZXJDYXNlKCk7IH0pXG4gIH1cblxuICAvKipcbiAgICogV2FybiBhIG1lc3NhZ2UgdmlhIGNvbnNvbGVcbiAgICogQHBhcmFtICAge1N0cmluZ30gbWVzc2FnZSAtIHdhcm5pbmcgbWVzc2FnZVxuICAgKi9cbiAgZnVuY3Rpb24gd2FybihtZXNzYWdlKSB7XG4gICAgaWYgKGNvbnNvbGUgJiYgY29uc29sZS53YXJuKSB7IGNvbnNvbGUud2FybihtZXNzYWdlKTsgfVxuICB9XG5cblxuXG4gIHZhciBtaXNjID0gLyojX19QVVJFX18qL09iamVjdC5mcmVlemUoe1xuICAgIGNvbnRhaW5zOiBjb250YWlucyxcbiAgICBlYWNoOiBlYWNoLFxuICAgIGdldFByb3BEZXNjcmlwdG9yOiBnZXRQcm9wRGVzY3JpcHRvcixcbiAgICBzdGFydHNXaXRoOiBzdGFydHNXaXRoLFxuICAgIHVpZDogdWlkLFxuICAgIGRlZmluZVByb3BlcnR5OiBkZWZpbmUsXG4gICAgb2JqZWN0Q3JlYXRlOiBjcmVhdGUsXG4gICAgZXh0ZW5kOiBleHRlbmQsXG4gICAgdG9DYW1lbDogdG9DYW1lbCxcbiAgICB3YXJuOiB3YXJuXG4gIH0pO1xuXG4gIC8qKlxuICAgKiBTZXQgdGhlIHByb3BlcnR5IG9mIGFuIG9iamVjdCBmb3IgYSBnaXZlbiBrZXkuIElmIHNvbWV0aGluZyBhbHJlYWR5XG4gICAqIGV4aXN0cyB0aGVyZSwgdGhlbiBpdCBiZWNvbWVzIGFuIGFycmF5IGNvbnRhaW5pbmcgYm90aCB0aGUgb2xkIGFuZCBuZXcgdmFsdWUuXG4gICAqIEBwYXJhbSB7IE9iamVjdCB9IG9iaiAtIG9iamVjdCBvbiB3aGljaCB0byBzZXQgdGhlIHByb3BlcnR5XG4gICAqIEBwYXJhbSB7IFN0cmluZyB9IGtleSAtIHByb3BlcnR5IG5hbWVcbiAgICogQHBhcmFtIHsgT2JqZWN0IH0gdmFsdWUgLSB0aGUgdmFsdWUgb2YgdGhlIHByb3BlcnR5IHRvIGJlIHNldFxuICAgKiBAcGFyYW0geyBCb29sZWFuIH0gZW5zdXJlQXJyYXkgLSBlbnN1cmUgdGhhdCB0aGUgcHJvcGVydHkgcmVtYWlucyBhbiBhcnJheVxuICAgKiBAcGFyYW0geyBOdW1iZXIgfSBpbmRleCAtIGFkZCB0aGUgbmV3IGl0ZW0gaW4gYSBjZXJ0YWluIGFycmF5IHBvc2l0aW9uXG4gICAqL1xuICBmdW5jdGlvbiBhcnJheWlzaEFkZChvYmosIGtleSwgdmFsdWUsIGVuc3VyZUFycmF5LCBpbmRleCkge1xuICAgIHZhciBkZXN0ID0gb2JqW2tleV07XG4gICAgdmFyIGlzQXJyID0gaXNBcnJheShkZXN0KTtcbiAgICB2YXIgaGFzSW5kZXggPSAhaXNVbmRlZmluZWQoaW5kZXgpO1xuXG4gICAgaWYgKGRlc3QgJiYgZGVzdCA9PT0gdmFsdWUpIHsgcmV0dXJuIH1cblxuICAgIC8vIGlmIHRoZSBrZXkgd2FzIG5ldmVyIHNldCwgc2V0IGl0IG9uY2VcbiAgICBpZiAoIWRlc3QgJiYgZW5zdXJlQXJyYXkpIHsgb2JqW2tleV0gPSBbdmFsdWVdOyB9XG4gICAgZWxzZSBpZiAoIWRlc3QpIHsgb2JqW2tleV0gPSB2YWx1ZTsgfVxuICAgIC8vIGlmIGl0IHdhcyBhbiBhcnJheSBhbmQgbm90IHlldCBzZXRcbiAgICBlbHNlIHtcbiAgICAgIGlmIChpc0Fycikge1xuICAgICAgICB2YXIgb2xkSW5kZXggPSBkZXN0LmluZGV4T2YodmFsdWUpO1xuICAgICAgICAvLyB0aGlzIGl0ZW0gbmV2ZXIgY2hhbmdlZCBpdHMgcG9zaXRpb25cbiAgICAgICAgaWYgKG9sZEluZGV4ID09PSBpbmRleCkgeyByZXR1cm4gfVxuICAgICAgICAvLyByZW1vdmUgdGhlIGl0ZW0gZnJvbSBpdHMgb2xkIHBvc2l0aW9uXG4gICAgICAgIGlmIChvbGRJbmRleCAhPT0gLTEpIHsgZGVzdC5zcGxpY2Uob2xkSW5kZXgsIDEpOyB9XG4gICAgICAgIC8vIG1vdmUgb3IgYWRkIHRoZSBpdGVtXG4gICAgICAgIGlmIChoYXNJbmRleCkge1xuICAgICAgICAgIGRlc3Quc3BsaWNlKGluZGV4LCAwLCB2YWx1ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZGVzdC5wdXNoKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHsgb2JqW2tleV0gPSBbZGVzdCwgdmFsdWVdOyB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIERldGVjdCB0aGUgdGFnIGltcGxlbWVudGF0aW9uIGJ5IGEgRE9NIG5vZGVcbiAgICogQHBhcmFtICAgeyBPYmplY3QgfSBkb20gLSBET00gbm9kZSB3ZSBuZWVkIHRvIHBhcnNlIHRvIGdldCBpdHMgdGFnIGltcGxlbWVudGF0aW9uXG4gICAqIEByZXR1cm5zIHsgT2JqZWN0IH0gaXQgcmV0dXJucyBhbiBvYmplY3QgY29udGFpbmluZyB0aGUgaW1wbGVtZW50YXRpb24gb2YgYSBjdXN0b20gdGFnICh0ZW1wbGF0ZSBhbmQgYm9vdCBmdW5jdGlvbilcbiAgICovXG4gIGZ1bmN0aW9uIGdldChkb20pIHtcbiAgICByZXR1cm4gZG9tLnRhZ05hbWUgJiYgX19UQUdfSU1QTFtnZXRBdHRyaWJ1dGUoZG9tLCBJU19ESVJFQ1RJVkUpIHx8XG4gICAgICBnZXRBdHRyaWJ1dGUoZG9tLCBJU19ESVJFQ1RJVkUpIHx8IGRvbS50YWdOYW1lLnRvTG93ZXJDYXNlKCldXG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSB0YWcgbmFtZSBvZiBhbnkgRE9NIG5vZGVcbiAgICogQHBhcmFtICAgeyBPYmplY3QgfSBkb20gLSBET00gbm9kZSB3ZSB3YW50IHRvIHBhcnNlXG4gICAqIEBwYXJhbSAgIHsgQm9vbGVhbiB9IHNraXBEYXRhSXMgLSBoYWNrIHRvIGlnbm9yZSB0aGUgZGF0YS1pcyBhdHRyaWJ1dGUgd2hlbiBhdHRhY2hpbmcgdG8gcGFyZW50XG4gICAqIEByZXR1cm5zIHsgU3RyaW5nIH0gbmFtZSB0byBpZGVudGlmeSB0aGlzIGRvbSBub2RlIGluIHJpb3RcbiAgICovXG4gIGZ1bmN0aW9uIGdldE5hbWUoZG9tLCBza2lwRGF0YUlzKSB7XG4gICAgdmFyIGNoaWxkID0gZ2V0KGRvbSk7XG4gICAgdmFyIG5hbWVkVGFnID0gIXNraXBEYXRhSXMgJiYgZ2V0QXR0cmlidXRlKGRvbSwgSVNfRElSRUNUSVZFKTtcbiAgICByZXR1cm4gbmFtZWRUYWcgJiYgIXRtcGwuaGFzRXhwcihuYW1lZFRhZykgP1xuICAgICAgbmFtZWRUYWcgOiBjaGlsZCA/IGNoaWxkLm5hbWUgOiBkb20udGFnTmFtZS50b0xvd2VyQ2FzZSgpXG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIGEgdGVtcG9yYXJ5IGNvbnRleHQgY29udGFpbmluZyBhbHNvIHRoZSBwYXJlbnQgcHJvcGVydGllc1xuICAgKiBAdGhpcyBUYWdcbiAgICogQHBhcmFtIHsgVGFnIH0gLSB0ZW1wb3JhcnkgdGFnIGNvbnRleHQgY29udGFpbmluZyBhbGwgdGhlIHBhcmVudCBwcm9wZXJ0aWVzXG4gICAqL1xuICBmdW5jdGlvbiBpbmhlcml0UGFyZW50UHJvcHMoKSB7XG4gICAgaWYgKHRoaXMucGFyZW50KSB7IHJldHVybiBleHRlbmQoY3JlYXRlKHRoaXMpLCB0aGlzLnBhcmVudCkgfVxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICAvKlxuICAgIEluY2x1ZGVzIGhhY2tzIG5lZWRlZCBmb3IgdGhlIEludGVybmV0IEV4cGxvcmVyIHZlcnNpb24gOSBhbmQgYmVsb3dcbiAgICBTZWU6IGh0dHA6Ly9rYW5nYXguZ2l0aHViLmlvL2NvbXBhdC10YWJsZS9lczUvI2llOFxuICAgICAgICAgaHR0cDovL2NvZGVwbGFuZXQuaW8vZHJvcHBpbmctaWU4L1xuICAqL1xuXG4gIHZhclxuICAgIHJlSGFzWWllbGQgID0gLzx5aWVsZFxcYi9pLFxuICAgIHJlWWllbGRBbGwgID0gLzx5aWVsZFxccyooPzpcXC8+fD4oW1xcU1xcc10qPyk8XFwveWllbGRcXHMqPnw+KS9pZyxcbiAgICByZVlpZWxkU3JjICA9IC88eWllbGRcXHMrdG89WydcIl0oW14nXCI+XSopWydcIl1cXHMqPihbXFxTXFxzXSo/KTxcXC95aWVsZFxccyo+L2lnLFxuICAgIHJlWWllbGREZXN0ID0gLzx5aWVsZFxccytmcm9tPVsnXCJdPyhbLVxcd10rKVsnXCJdP1xccyooPzpcXC8+fD4oW1xcU1xcc10qPyk8XFwveWllbGRcXHMqPikvaWcsXG4gICAgcm9vdEVscyA9IHsgdHI6ICd0Ym9keScsIHRoOiAndHInLCB0ZDogJ3RyJywgY29sOiAnY29sZ3JvdXAnIH0sXG4gICAgdGJsVGFncyA9IElFX1ZFUlNJT04gJiYgSUVfVkVSU0lPTiA8IDEwID8gUkVfU1BFQ0lBTF9UQUdTIDogUkVfU1BFQ0lBTF9UQUdTX05PX09QVElPTixcbiAgICBHRU5FUklDID0gJ2RpdicsXG4gICAgU1ZHID0gJ3N2Zyc7XG5cblxuICAvKlxuICAgIENyZWF0ZXMgdGhlIHJvb3QgZWxlbWVudCBmb3IgdGFibGUgb3Igc2VsZWN0IGNoaWxkIGVsZW1lbnRzOlxuICAgIHRyL3RoL3RkL3RoZWFkL3Rmb290L3Rib2R5L2NhcHRpb24vY29sL2NvbGdyb3VwL29wdGlvbi9vcHRncm91cFxuICAqL1xuICBmdW5jdGlvbiBzcGVjaWFsVGFncyhlbCwgdG1wbCwgdGFnTmFtZSkge1xuXG4gICAgdmFyXG4gICAgICBzZWxlY3QgPSB0YWdOYW1lWzBdID09PSAnbycsXG4gICAgICBwYXJlbnQgPSBzZWxlY3QgPyAnc2VsZWN0PicgOiAndGFibGU+JztcblxuICAgIC8vIHRyaW0oKSBpcyBpbXBvcnRhbnQgaGVyZSwgdGhpcyBlbnN1cmVzIHdlIGRvbid0IGhhdmUgYXJ0aWZhY3RzLFxuICAgIC8vIHNvIHdlIGNhbiBjaGVjayBpZiB3ZSBoYXZlIG9ubHkgb25lIGVsZW1lbnQgaW5zaWRlIHRoZSBwYXJlbnRcbiAgICBlbC5pbm5lckhUTUwgPSAnPCcgKyBwYXJlbnQgKyB0bXBsLnRyaW0oKSArICc8LycgKyBwYXJlbnQ7XG4gICAgcGFyZW50ID0gZWwuZmlyc3RDaGlsZDtcblxuICAgIC8vIHJldHVybnMgdGhlIGltbWVkaWF0ZSBwYXJlbnQgaWYgdHIvdGgvdGQvY29sIGlzIHRoZSBvbmx5IGVsZW1lbnQsIGlmIG5vdFxuICAgIC8vIHJldHVybnMgdGhlIHdob2xlIHRyZWUsIGFzIHRoaXMgY2FuIGluY2x1ZGUgYWRkaXRpb25hbCBlbGVtZW50c1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgaWYgKHNlbGVjdCkge1xuICAgICAgcGFyZW50LnNlbGVjdGVkSW5kZXggPSAtMTsgIC8vIGZvciBJRTksIGNvbXBhdGlibGUgdy9jdXJyZW50IHJpb3QgYmVoYXZpb3JcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gYXZvaWRzIGluc2VydGlvbiBvZiBjb2ludGFpbmVyIGluc2lkZSBjb250YWluZXIgKGV4OiB0Ym9keSBpbnNpZGUgdGJvZHkpXG4gICAgICB2YXIgdG5hbWUgPSByb290RWxzW3RhZ05hbWVdO1xuICAgICAgaWYgKHRuYW1lICYmIHBhcmVudC5jaGlsZEVsZW1lbnRDb3VudCA9PT0gMSkgeyBwYXJlbnQgPSAkKHRuYW1lLCBwYXJlbnQpOyB9XG4gICAgfVxuICAgIHJldHVybiBwYXJlbnRcbiAgfVxuXG4gIC8qXG4gICAgUmVwbGFjZSB0aGUgeWllbGQgdGFnIGZyb20gYW55IHRhZyB0ZW1wbGF0ZSB3aXRoIHRoZSBpbm5lckhUTUwgb2YgdGhlXG4gICAgb3JpZ2luYWwgdGFnIGluIHRoZSBwYWdlXG4gICovXG4gIGZ1bmN0aW9uIHJlcGxhY2VZaWVsZCh0bXBsLCBodG1sKSB7XG4gICAgLy8gZG8gbm90aGluZyBpZiBubyB5aWVsZFxuICAgIGlmICghcmVIYXNZaWVsZC50ZXN0KHRtcGwpKSB7IHJldHVybiB0bXBsIH1cblxuICAgIC8vIGJlIGNhcmVmdWwgd2l0aCAjMTM0MyAtIHN0cmluZyBvbiB0aGUgc291cmNlIGhhdmluZyBgJDFgXG4gICAgdmFyIHNyYyA9IHt9O1xuXG4gICAgaHRtbCA9IGh0bWwgJiYgaHRtbC5yZXBsYWNlKHJlWWllbGRTcmMsIGZ1bmN0aW9uIChfLCByZWYsIHRleHQpIHtcbiAgICAgIHNyY1tyZWZdID0gc3JjW3JlZl0gfHwgdGV4dDsgICAvLyBwcmVzZXJ2ZSBmaXJzdCBkZWZpbml0aW9uXG4gICAgICByZXR1cm4gJydcbiAgICB9KS50cmltKCk7XG5cbiAgICByZXR1cm4gdG1wbFxuICAgICAgLnJlcGxhY2UocmVZaWVsZERlc3QsIGZ1bmN0aW9uIChfLCByZWYsIGRlZikgeyAgLy8geWllbGQgd2l0aCBmcm9tIC0gdG8gYXR0cnNcbiAgICAgICAgcmV0dXJuIHNyY1tyZWZdIHx8IGRlZiB8fCAnJ1xuICAgICAgfSlcbiAgICAgIC5yZXBsYWNlKHJlWWllbGRBbGwsIGZ1bmN0aW9uIChfLCBkZWYpIHsgICAgICAgIC8vIHlpZWxkIHdpdGhvdXQgYW55IFwiZnJvbVwiXG4gICAgICAgIHJldHVybiBodG1sIHx8IGRlZiB8fCAnJ1xuICAgICAgfSlcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgRE9NIGVsZW1lbnQgdG8gd3JhcCB0aGUgZ2l2ZW4gY29udGVudC4gTm9ybWFsbHkgYW4gYERJVmAsIGJ1dCBjYW4gYmVcbiAgICogYWxzbyBhIGBUQUJMRWAsIGBTRUxFQ1RgLCBgVEJPRFlgLCBgVFJgLCBvciBgQ09MR1JPVVBgIGVsZW1lbnQuXG4gICAqXG4gICAqIEBwYXJhbSAgIHsgU3RyaW5nIH0gdG1wbCAgLSBUaGUgdGVtcGxhdGUgY29taW5nIGZyb20gdGhlIGN1c3RvbSB0YWcgZGVmaW5pdGlvblxuICAgKiBAcGFyYW0gICB7IFN0cmluZyB9IGh0bWwgLSBIVE1MIGNvbnRlbnQgdGhhdCBjb21lcyBmcm9tIHRoZSBET00gZWxlbWVudCB3aGVyZSB5b3VcbiAgICogICAgICAgICAgIHdpbGwgbW91bnQgdGhlIHRhZywgbW9zdGx5IHRoZSBvcmlnaW5hbCB0YWcgaW4gdGhlIHBhZ2VcbiAgICogQHBhcmFtICAgeyBCb29sZWFuIH0gaXNTdmcgLSB0cnVlIGlmIHRoZSByb290IG5vZGUgaXMgYW4gc3ZnXG4gICAqIEByZXR1cm5zIHsgSFRNTEVsZW1lbnQgfSBET00gZWxlbWVudCB3aXRoIF90bXBsXyBtZXJnZWQgdGhyb3VnaCBgWUlFTERgIHdpdGggdGhlIF9odG1sXy5cbiAgICovXG4gIGZ1bmN0aW9uIG1rZG9tKHRtcGwsIGh0bWwsIGlzU3ZnKSB7XG4gICAgdmFyIG1hdGNoICAgPSB0bXBsICYmIHRtcGwubWF0Y2goL15cXHMqPChbLVxcd10rKS8pO1xuICAgIHZhciAgdGFnTmFtZSA9IG1hdGNoICYmIG1hdGNoWzFdLnRvTG93ZXJDYXNlKCk7XG4gICAgdmFyIGVsID0gbWFrZUVsZW1lbnQoaXNTdmcgPyBTVkcgOiBHRU5FUklDKTtcblxuICAgIC8vIHJlcGxhY2UgYWxsIHRoZSB5aWVsZCB0YWdzIHdpdGggdGhlIHRhZyBpbm5lciBodG1sXG4gICAgdG1wbCA9IHJlcGxhY2VZaWVsZCh0bXBsLCBodG1sKTtcblxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgaWYgKHRibFRhZ3MudGVzdCh0YWdOYW1lKSlcbiAgICAgIHsgZWwgPSBzcGVjaWFsVGFncyhlbCwgdG1wbCwgdGFnTmFtZSk7IH1cbiAgICBlbHNlXG4gICAgICB7IHNldElubmVySFRNTChlbCwgdG1wbCwgaXNTdmcpOyB9XG5cbiAgICByZXR1cm4gZWxcbiAgfVxuXG4gIHZhciBFVkVOVF9BVFRSX1JFID0gL15vbi87XG5cbiAgLyoqXG4gICAqIFRydWUgaWYgdGhlIGV2ZW50IGF0dHJpYnV0ZSBzdGFydHMgd2l0aCAnb24nXG4gICAqIEBwYXJhbSAgIHsgU3RyaW5nIH0gYXR0cmlidXRlIC0gZXZlbnQgYXR0cmlidXRlXG4gICAqIEByZXR1cm5zIHsgQm9vbGVhbiB9XG4gICAqL1xuICBmdW5jdGlvbiBpc0V2ZW50QXR0cmlidXRlKGF0dHJpYnV0ZSkge1xuICAgIHJldHVybiBFVkVOVF9BVFRSX1JFLnRlc3QoYXR0cmlidXRlKVxuICB9XG5cbiAgLyoqXG4gICAqIExvb3AgYmFja3dhcmQgYWxsIHRoZSBwYXJlbnRzIHRyZWUgdG8gZGV0ZWN0IHRoZSBmaXJzdCBjdXN0b20gcGFyZW50IHRhZ1xuICAgKiBAcGFyYW0gICB7IE9iamVjdCB9IHRhZyAtIGEgVGFnIGluc3RhbmNlXG4gICAqIEByZXR1cm5zIHsgT2JqZWN0IH0gdGhlIGluc3RhbmNlIG9mIHRoZSBmaXJzdCBjdXN0b20gcGFyZW50IHRhZyBmb3VuZFxuICAgKi9cbiAgZnVuY3Rpb24gZ2V0SW1tZWRpYXRlQ3VzdG9tUGFyZW50KHRhZykge1xuICAgIHZhciBwdGFnID0gdGFnO1xuICAgIHdoaWxlIChwdGFnLl9fLmlzQW5vbnltb3VzKSB7XG4gICAgICBpZiAoIXB0YWcucGFyZW50KSB7IGJyZWFrIH1cbiAgICAgIHB0YWcgPSBwdGFnLnBhcmVudDtcbiAgICB9XG4gICAgcmV0dXJuIHB0YWdcbiAgfVxuXG4gIC8qKlxuICAgKiBUcmlnZ2VyIERPTSBldmVudHNcbiAgICogQHBhcmFtICAgeyBIVE1MRWxlbWVudCB9IGRvbSAtIGRvbSBlbGVtZW50IHRhcmdldCBvZiB0aGUgZXZlbnRcbiAgICogQHBhcmFtICAgeyBGdW5jdGlvbiB9IGhhbmRsZXIgLSB1c2VyIGZ1bmN0aW9uXG4gICAqIEBwYXJhbSAgIHsgT2JqZWN0IH0gZSAtIGV2ZW50IG9iamVjdFxuICAgKi9cbiAgZnVuY3Rpb24gaGFuZGxlRXZlbnQoZG9tLCBoYW5kbGVyLCBlKSB7XG4gICAgdmFyIHB0YWcgPSB0aGlzLl9fLnBhcmVudDtcbiAgICB2YXIgaXRlbSA9IHRoaXMuX18uaXRlbTtcblxuICAgIGlmICghaXRlbSlcbiAgICAgIHsgd2hpbGUgKHB0YWcgJiYgIWl0ZW0pIHtcbiAgICAgICAgaXRlbSA9IHB0YWcuX18uaXRlbTtcbiAgICAgICAgcHRhZyA9IHB0YWcuX18ucGFyZW50O1xuICAgICAgfSB9XG5cbiAgICAvLyBvdmVycmlkZSB0aGUgZXZlbnQgcHJvcGVydGllc1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgaWYgKGlzV3JpdGFibGUoZSwgJ2N1cnJlbnRUYXJnZXQnKSkgeyBlLmN1cnJlbnRUYXJnZXQgPSBkb207IH1cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgIGlmIChpc1dyaXRhYmxlKGUsICd0YXJnZXQnKSkgeyBlLnRhcmdldCA9IGUuc3JjRWxlbWVudDsgfVxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgaWYgKGlzV3JpdGFibGUoZSwgJ3doaWNoJykpIHsgZS53aGljaCA9IGUuY2hhckNvZGUgfHwgZS5rZXlDb2RlOyB9XG5cbiAgICBlLml0ZW0gPSBpdGVtO1xuXG4gICAgaGFuZGxlci5jYWxsKHRoaXMsIGUpO1xuXG4gICAgLy8gYXZvaWQgYXV0byB1cGRhdGVzXG4gICAgaWYgKCFzZXR0aW5ncy5hdXRvVXBkYXRlKSB7IHJldHVybiB9XG5cbiAgICBpZiAoIWUucHJldmVudFVwZGF0ZSkge1xuICAgICAgdmFyIHAgPSBnZXRJbW1lZGlhdGVDdXN0b21QYXJlbnQodGhpcyk7XG4gICAgICAvLyBmaXhlcyAjMjA4M1xuICAgICAgaWYgKHAuaXNNb3VudGVkKSB7IHAudXBkYXRlKCk7IH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQXR0YWNoIGFuIGV2ZW50IHRvIGEgRE9NIG5vZGVcbiAgICogQHBhcmFtIHsgU3RyaW5nIH0gbmFtZSAtIGV2ZW50IG5hbWVcbiAgICogQHBhcmFtIHsgRnVuY3Rpb24gfSBoYW5kbGVyIC0gZXZlbnQgY2FsbGJhY2tcbiAgICogQHBhcmFtIHsgT2JqZWN0IH0gZG9tIC0gZG9tIG5vZGVcbiAgICogQHBhcmFtIHsgVGFnIH0gdGFnIC0gdGFnIGluc3RhbmNlXG4gICAqL1xuICBmdW5jdGlvbiBzZXRFdmVudEhhbmRsZXIobmFtZSwgaGFuZGxlciwgZG9tLCB0YWcpIHtcbiAgICB2YXIgZXZlbnROYW1lO1xuICAgIHZhciBjYiA9IGhhbmRsZUV2ZW50LmJpbmQodGFnLCBkb20sIGhhbmRsZXIpO1xuXG4gICAgLy8gYXZvaWQgdG8gYmluZCB0d2ljZSB0aGUgc2FtZSBldmVudFxuICAgIC8vIHBvc3NpYmxlIGZpeCBmb3IgIzIzMzJcbiAgICBkb21bbmFtZV0gPSBudWxsO1xuXG4gICAgLy8gbm9ybWFsaXplIGV2ZW50IG5hbWVcbiAgICBldmVudE5hbWUgPSBuYW1lLnJlcGxhY2UoUkVfRVZFTlRTX1BSRUZJWCwgJycpO1xuXG4gICAgLy8gY2FjaGUgdGhlIGxpc3RlbmVyIGludG8gdGhlIGxpc3RlbmVycyBhcnJheVxuICAgIGlmICghY29udGFpbnModGFnLl9fLmxpc3RlbmVycywgZG9tKSkgeyB0YWcuX18ubGlzdGVuZXJzLnB1c2goZG9tKTsgfVxuICAgIGlmICghZG9tW1JJT1RfRVZFTlRTX0tFWV0pIHsgZG9tW1JJT1RfRVZFTlRTX0tFWV0gPSB7fTsgfVxuICAgIGlmIChkb21bUklPVF9FVkVOVFNfS0VZXVtuYW1lXSkgeyBkb20ucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudE5hbWUsIGRvbVtSSU9UX0VWRU5UU19LRVldW25hbWVdKTsgfVxuXG4gICAgZG9tW1JJT1RfRVZFTlRTX0tFWV1bbmFtZV0gPSBjYjtcbiAgICBkb20uYWRkRXZlbnRMaXN0ZW5lcihldmVudE5hbWUsIGNiLCBmYWxzZSk7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIGEgbmV3IGNoaWxkIHRhZyBpbmNsdWRpbmcgaXQgY29ycmVjdGx5IGludG8gaXRzIHBhcmVudFxuICAgKiBAcGFyYW0gICB7IE9iamVjdCB9IGNoaWxkIC0gY2hpbGQgdGFnIGltcGxlbWVudGF0aW9uXG4gICAqIEBwYXJhbSAgIHsgT2JqZWN0IH0gb3B0cyAtIHRhZyBvcHRpb25zIGNvbnRhaW5pbmcgdGhlIERPTSBub2RlIHdoZXJlIHRoZSB0YWcgd2lsbCBiZSBtb3VudGVkXG4gICAqIEBwYXJhbSAgIHsgU3RyaW5nIH0gaW5uZXJIVE1MIC0gaW5uZXIgaHRtbCBvZiB0aGUgY2hpbGQgbm9kZVxuICAgKiBAcGFyYW0gICB7IE9iamVjdCB9IHBhcmVudCAtIGluc3RhbmNlIG9mIHRoZSBwYXJlbnQgdGFnIGluY2x1ZGluZyB0aGUgY2hpbGQgY3VzdG9tIHRhZ1xuICAgKiBAcmV0dXJucyB7IE9iamVjdCB9IGluc3RhbmNlIG9mIHRoZSBuZXcgY2hpbGQgdGFnIGp1c3QgY3JlYXRlZFxuICAgKi9cbiAgZnVuY3Rpb24gaW5pdENoaWxkKGNoaWxkLCBvcHRzLCBpbm5lckhUTUwsIHBhcmVudCkge1xuICAgIHZhciB0YWcgPSBjcmVhdGVUYWcoY2hpbGQsIG9wdHMsIGlubmVySFRNTCk7XG4gICAgdmFyIHRhZ05hbWUgPSBvcHRzLnRhZ05hbWUgfHwgZ2V0TmFtZShvcHRzLnJvb3QsIHRydWUpO1xuICAgIHZhciBwdGFnID0gZ2V0SW1tZWRpYXRlQ3VzdG9tUGFyZW50KHBhcmVudCk7XG4gICAgLy8gZml4IGZvciB0aGUgcGFyZW50IGF0dHJpYnV0ZSBpbiB0aGUgbG9vcGVkIGVsZW1lbnRzXG4gICAgZGVmaW5lKHRhZywgJ3BhcmVudCcsIHB0YWcpO1xuICAgIC8vIHN0b3JlIHRoZSByZWFsIHBhcmVudCB0YWdcbiAgICAvLyBpbiBzb21lIGNhc2VzIHRoaXMgY291bGQgYmUgZGlmZmVyZW50IGZyb20gdGhlIGN1c3RvbSBwYXJlbnQgdGFnXG4gICAgLy8gZm9yIGV4YW1wbGUgaW4gbmVzdGVkIGxvb3BzXG4gICAgdGFnLl9fLnBhcmVudCA9IHBhcmVudDtcblxuICAgIC8vIGFkZCB0aGlzIHRhZyB0byB0aGUgY3VzdG9tIHBhcmVudCB0YWdcbiAgICBhcnJheWlzaEFkZChwdGFnLnRhZ3MsIHRhZ05hbWUsIHRhZyk7XG5cbiAgICAvLyBhbmQgYWxzbyB0byB0aGUgcmVhbCBwYXJlbnQgdGFnXG4gICAgaWYgKHB0YWcgIT09IHBhcmVudClcbiAgICAgIHsgYXJyYXlpc2hBZGQocGFyZW50LnRhZ3MsIHRhZ05hbWUsIHRhZyk7IH1cblxuICAgIHJldHVybiB0YWdcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW1vdmVzIGFuIGl0ZW0gZnJvbSBhbiBvYmplY3QgYXQgYSBnaXZlbiBrZXkuIElmIHRoZSBrZXkgcG9pbnRzIHRvIGFuIGFycmF5LFxuICAgKiB0aGVuIHRoZSBpdGVtIGlzIGp1c3QgcmVtb3ZlZCBmcm9tIHRoZSBhcnJheS5cbiAgICogQHBhcmFtIHsgT2JqZWN0IH0gb2JqIC0gb2JqZWN0IG9uIHdoaWNoIHRvIHJlbW92ZSB0aGUgcHJvcGVydHlcbiAgICogQHBhcmFtIHsgU3RyaW5nIH0ga2V5IC0gcHJvcGVydHkgbmFtZVxuICAgKiBAcGFyYW0geyBPYmplY3QgfSB2YWx1ZSAtIHRoZSB2YWx1ZSBvZiB0aGUgcHJvcGVydHkgdG8gYmUgcmVtb3ZlZFxuICAgKiBAcGFyYW0geyBCb29sZWFuIH0gZW5zdXJlQXJyYXkgLSBlbnN1cmUgdGhhdCB0aGUgcHJvcGVydHkgcmVtYWlucyBhbiBhcnJheVxuICAqL1xuICBmdW5jdGlvbiBhcnJheWlzaFJlbW92ZShvYmosIGtleSwgdmFsdWUsIGVuc3VyZUFycmF5KSB7XG4gICAgaWYgKGlzQXJyYXkob2JqW2tleV0pKSB7XG4gICAgICB2YXIgaW5kZXggPSBvYmpba2V5XS5pbmRleE9mKHZhbHVlKTtcbiAgICAgIGlmIChpbmRleCAhPT0gLTEpIHsgb2JqW2tleV0uc3BsaWNlKGluZGV4LCAxKTsgfVxuICAgICAgaWYgKCFvYmpba2V5XS5sZW5ndGgpIHsgZGVsZXRlIG9ialtrZXldOyB9XG4gICAgICBlbHNlIGlmIChvYmpba2V5XS5sZW5ndGggPT09IDEgJiYgIWVuc3VyZUFycmF5KSB7IG9ialtrZXldID0gb2JqW2tleV1bMF07IH1cbiAgICB9IGVsc2UgaWYgKG9ialtrZXldID09PSB2YWx1ZSlcbiAgICAgIHsgZGVsZXRlIG9ialtrZXldOyB9IC8vIG90aGVyd2lzZSBqdXN0IGRlbGV0ZSB0aGUga2V5XG4gIH1cblxuICAvKipcbiAgICogQWRkcyB0aGUgZWxlbWVudHMgZm9yIGEgdmlydHVhbCB0YWdcbiAgICogQHRoaXMgVGFnXG4gICAqIEBwYXJhbSB7IE5vZGUgfSBzcmMgLSB0aGUgbm9kZSB0aGF0IHdpbGwgZG8gdGhlIGluc2VydGluZyBvciBhcHBlbmRpbmdcbiAgICogQHBhcmFtIHsgVGFnIH0gdGFyZ2V0IC0gb25seSBpZiBpbnNlcnRpbmcsIGluc2VydCBiZWZvcmUgdGhpcyB0YWcncyBmaXJzdCBjaGlsZFxuICAgKi9cbiAgZnVuY3Rpb24gbWFrZVZpcnR1YWwoc3JjLCB0YXJnZXQpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgIHZhciBoZWFkID0gY3JlYXRlRE9NUGxhY2Vob2xkZXIoKTtcbiAgICB2YXIgdGFpbCA9IGNyZWF0ZURPTVBsYWNlaG9sZGVyKCk7XG4gICAgdmFyIGZyYWcgPSBjcmVhdGVGcmFnbWVudCgpO1xuICAgIHZhciBzaWI7XG4gICAgdmFyIGVsO1xuXG4gICAgdGhpcy5yb290Lmluc2VydEJlZm9yZShoZWFkLCB0aGlzLnJvb3QuZmlyc3RDaGlsZCk7XG4gICAgdGhpcy5yb290LmFwcGVuZENoaWxkKHRhaWwpO1xuXG4gICAgdGhpcy5fXy5oZWFkID0gZWwgPSBoZWFkO1xuICAgIHRoaXMuX18udGFpbCA9IHRhaWw7XG5cbiAgICB3aGlsZSAoZWwpIHtcbiAgICAgIHNpYiA9IGVsLm5leHRTaWJsaW5nO1xuICAgICAgZnJhZy5hcHBlbmRDaGlsZChlbCk7XG4gICAgICB0aGlzJDEuX18udmlydHMucHVzaChlbCk7IC8vIGhvbGQgZm9yIHVubW91bnRpbmdcbiAgICAgIGVsID0gc2liO1xuICAgIH1cblxuICAgIGlmICh0YXJnZXQpXG4gICAgICB7IHNyYy5pbnNlcnRCZWZvcmUoZnJhZywgdGFyZ2V0Ll9fLmhlYWQpOyB9XG4gICAgZWxzZVxuICAgICAgeyBzcmMuYXBwZW5kQ2hpbGQoZnJhZyk7IH1cbiAgfVxuXG4gIC8qKlxuICAgKiBtYWtlcyBhIHRhZyB2aXJ0dWFsIGFuZCByZXBsYWNlcyBhIHJlZmVyZW5jZSBpbiB0aGUgZG9tXG4gICAqIEB0aGlzIFRhZ1xuICAgKiBAcGFyYW0geyB0YWcgfSB0aGUgdGFnIHRvIG1ha2UgdmlydHVhbFxuICAgKiBAcGFyYW0geyByZWYgfSB0aGUgZG9tIHJlZmVyZW5jZSBsb2NhdGlvblxuICAgKi9cbiAgZnVuY3Rpb24gbWFrZVJlcGxhY2VWaXJ0dWFsKHRhZywgcmVmKSB7XG4gICAgdmFyIGZyYWcgPSBjcmVhdGVGcmFnbWVudCgpO1xuICAgIG1ha2VWaXJ0dWFsLmNhbGwodGFnLCBmcmFnKTtcbiAgICByZWYucGFyZW50Tm9kZS5yZXBsYWNlQ2hpbGQoZnJhZywgcmVmKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBVcGRhdGUgZHluYW1pY2FsbHkgY3JlYXRlZCBkYXRhLWlzIHRhZ3Mgd2l0aCBjaGFuZ2luZyBleHByZXNzaW9uc1xuICAgKiBAcGFyYW0geyBPYmplY3QgfSBleHByIC0gZXhwcmVzc2lvbiB0YWcgYW5kIGV4cHJlc3Npb24gaW5mb1xuICAgKiBAcGFyYW0geyBUYWcgfSAgICBwYXJlbnQgLSBwYXJlbnQgZm9yIHRhZyBjcmVhdGlvblxuICAgKiBAcGFyYW0geyBTdHJpbmcgfSB0YWdOYW1lIC0gdGFnIGltcGxlbWVudGF0aW9uIHdlIHdhbnQgdG8gdXNlXG4gICAqL1xuICBmdW5jdGlvbiB1cGRhdGVEYXRhSXMoZXhwciwgcGFyZW50LCB0YWdOYW1lKSB7XG4gICAgdmFyIHRhZyA9IGV4cHIudGFnIHx8IGV4cHIuZG9tLl90YWc7XG4gICAgdmFyIHJlZjtcblxuICAgIHZhciByZWYkMSA9IHRhZyA/IHRhZy5fXyA6IHt9O1xuICAgIHZhciBoZWFkID0gcmVmJDEuaGVhZDtcbiAgICB2YXIgaXNWaXJ0dWFsID0gZXhwci5kb20udGFnTmFtZSA9PT0gJ1ZJUlRVQUwnO1xuXG4gICAgaWYgKHRhZyAmJiBleHByLnRhZ05hbWUgPT09IHRhZ05hbWUpIHtcbiAgICAgIHRhZy51cGRhdGUoKTtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIC8vIHN5bmMgX3BhcmVudCB0byBhY2NvbW1vZGF0ZSBjaGFuZ2luZyB0YWduYW1lc1xuICAgIGlmICh0YWcpIHtcbiAgICAgIC8vIG5lZWQgcGxhY2Vob2xkZXIgYmVmb3JlIHVubW91bnRcbiAgICAgIGlmKGlzVmlydHVhbCkge1xuICAgICAgICByZWYgPSBjcmVhdGVET01QbGFjZWhvbGRlcigpO1xuICAgICAgICBoZWFkLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKHJlZiwgaGVhZCk7XG4gICAgICB9XG5cbiAgICAgIHRhZy51bm1vdW50KHRydWUpO1xuICAgIH1cblxuICAgIC8vIHVuYWJsZSB0byBnZXQgdGhlIHRhZyBuYW1lXG4gICAgaWYgKCFpc1N0cmluZyh0YWdOYW1lKSkgeyByZXR1cm4gfVxuXG4gICAgZXhwci5pbXBsID0gX19UQUdfSU1QTFt0YWdOYW1lXTtcblxuICAgIC8vIHVua25vd24gaW1wbGVtZW50YXRpb25cbiAgICBpZiAoIWV4cHIuaW1wbCkgeyByZXR1cm4gfVxuXG4gICAgZXhwci50YWcgPSB0YWcgPSBpbml0Q2hpbGQoXG4gICAgICBleHByLmltcGwsIHtcbiAgICAgICAgcm9vdDogZXhwci5kb20sXG4gICAgICAgIHBhcmVudDogcGFyZW50LFxuICAgICAgICB0YWdOYW1lOiB0YWdOYW1lXG4gICAgICB9LFxuICAgICAgZXhwci5kb20uaW5uZXJIVE1MLFxuICAgICAgcGFyZW50XG4gICAgKTtcblxuICAgIGVhY2goZXhwci5hdHRycywgZnVuY3Rpb24gKGEpIHsgcmV0dXJuIHNldEF0dHJpYnV0ZSh0YWcucm9vdCwgYS5uYW1lLCBhLnZhbHVlKTsgfSk7XG4gICAgZXhwci50YWdOYW1lID0gdGFnTmFtZTtcbiAgICB0YWcubW91bnQoKTtcblxuICAgIC8vIHJvb3QgZXhpc3QgZmlyc3QgdGltZSwgYWZ0ZXIgdXNlIHBsYWNlaG9sZGVyXG4gICAgaWYgKGlzVmlydHVhbCkgeyBtYWtlUmVwbGFjZVZpcnR1YWwodGFnLCByZWYgfHwgdGFnLnJvb3QpOyB9XG5cbiAgICAvLyBwYXJlbnQgaXMgdGhlIHBsYWNlaG9sZGVyIHRhZywgbm90IHRoZSBkeW5hbWljIHRhZyBzbyBjbGVhbiB1cFxuICAgIHBhcmVudC5fXy5vblVubW91bnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgZGVsTmFtZSA9IHRhZy5vcHRzLmRhdGFJcztcbiAgICAgIGFycmF5aXNoUmVtb3ZlKHRhZy5wYXJlbnQudGFncywgZGVsTmFtZSwgdGFnKTtcbiAgICAgIGFycmF5aXNoUmVtb3ZlKHRhZy5fXy5wYXJlbnQudGFncywgZGVsTmFtZSwgdGFnKTtcbiAgICAgIHRhZy51bm1vdW50KCk7XG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBOb21hbGl6ZSBhbnkgYXR0cmlidXRlIHJlbW92aW5nIHRoZSBcInJpb3QtXCIgcHJlZml4XG4gICAqIEBwYXJhbSAgIHsgU3RyaW5nIH0gYXR0ck5hbWUgLSBvcmlnaW5hbCBhdHRyaWJ1dGUgbmFtZVxuICAgKiBAcmV0dXJucyB7IFN0cmluZyB9IHZhbGlkIGh0bWwgYXR0cmlidXRlIG5hbWVcbiAgICovXG4gIGZ1bmN0aW9uIG5vcm1hbGl6ZUF0dHJOYW1lKGF0dHJOYW1lKSB7XG4gICAgaWYgKCFhdHRyTmFtZSkgeyByZXR1cm4gbnVsbCB9XG4gICAgYXR0ck5hbWUgPSBhdHRyTmFtZS5yZXBsYWNlKEFUVFJTX1BSRUZJWCwgJycpO1xuICAgIGlmIChDQVNFX1NFTlNJVElWRV9BVFRSSUJVVEVTW2F0dHJOYW1lXSkgeyBhdHRyTmFtZSA9IENBU0VfU0VOU0lUSVZFX0FUVFJJQlVURVNbYXR0ck5hbWVdOyB9XG4gICAgcmV0dXJuIGF0dHJOYW1lXG4gIH1cblxuICAvKipcbiAgICogVXBkYXRlIG9uIHNpbmdsZSB0YWcgZXhwcmVzc2lvblxuICAgKiBAdGhpcyBUYWdcbiAgICogQHBhcmFtIHsgT2JqZWN0IH0gZXhwciAtIGV4cHJlc3Npb24gbG9naWNcbiAgICogQHJldHVybnMgeyB1bmRlZmluZWQgfVxuICAgKi9cbiAgZnVuY3Rpb24gdXBkYXRlRXhwcmVzc2lvbihleHByKSB7XG4gICAgaWYgKHRoaXMucm9vdCAmJiBnZXRBdHRyaWJ1dGUodGhpcy5yb290LCd2aXJ0dWFsaXplZCcpKSB7IHJldHVybiB9XG5cbiAgICB2YXIgZG9tID0gZXhwci5kb207XG4gICAgLy8gcmVtb3ZlIHRoZSByaW90LSBwcmVmaXhcbiAgICB2YXIgYXR0ck5hbWUgPSBub3JtYWxpemVBdHRyTmFtZShleHByLmF0dHIpO1xuICAgIHZhciBpc1RvZ2dsZSA9IGNvbnRhaW5zKFtTSE9XX0RJUkVDVElWRSwgSElERV9ESVJFQ1RJVkVdLCBhdHRyTmFtZSk7XG4gICAgdmFyIGlzVmlydHVhbCA9IGV4cHIucm9vdCAmJiBleHByLnJvb3QudGFnTmFtZSA9PT0gJ1ZJUlRVQUwnO1xuICAgIHZhciByZWYgPSB0aGlzLl9fO1xuICAgIHZhciBpc0Fub255bW91cyA9IHJlZi5pc0Fub255bW91cztcbiAgICB2YXIgcGFyZW50ID0gZG9tICYmIChleHByLnBhcmVudCB8fCBkb20ucGFyZW50Tm9kZSk7XG4gICAgLy8gZGV0ZWN0IHRoZSBzdHlsZSBhdHRyaWJ1dGVzXG4gICAgdmFyIGlzU3R5bGVBdHRyID0gYXR0ck5hbWUgPT09ICdzdHlsZSc7XG4gICAgdmFyIGlzQ2xhc3NBdHRyID0gYXR0ck5hbWUgPT09ICdjbGFzcyc7XG5cbiAgICB2YXIgdmFsdWU7XG5cbiAgICAvLyBpZiBpdCdzIGEgdGFnIHdlIGNvdWxkIHRvdGFsbHkgc2tpcCB0aGUgcmVzdFxuICAgIGlmIChleHByLl9yaW90X2lkKSB7XG4gICAgICBpZiAoZXhwci5fXy53YXNDcmVhdGVkKSB7XG4gICAgICAgIGV4cHIudXBkYXRlKCk7XG4gICAgICAvLyBpZiBpdCBoYXNuJ3QgYmVlbiBtb3VudGVkIHlldCwgZG8gdGhhdCBub3cuXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBleHByLm1vdW50KCk7XG4gICAgICAgIGlmIChpc1ZpcnR1YWwpIHtcbiAgICAgICAgICBtYWtlUmVwbGFjZVZpcnR1YWwoZXhwciwgZXhwci5yb290KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgLy8gaWYgdGhpcyBleHByZXNzaW9uIGhhcyB0aGUgdXBkYXRlIG1ldGhvZCBpdCBtZWFucyBpdCBjYW4gaGFuZGxlIHRoZSBET00gY2hhbmdlcyBieSBpdHNlbGZcbiAgICBpZiAoZXhwci51cGRhdGUpIHsgcmV0dXJuIGV4cHIudXBkYXRlKCkgfVxuXG4gICAgdmFyIGNvbnRleHQgPSBpc1RvZ2dsZSAmJiAhaXNBbm9ueW1vdXMgPyBpbmhlcml0UGFyZW50UHJvcHMuY2FsbCh0aGlzKSA6IHRoaXM7XG5cbiAgICAvLyAuLi5pdCBzZWVtcyB0byBiZSBhIHNpbXBsZSBleHByZXNzaW9uIHNvIHdlIHRyeSB0byBjYWxjdWxhdGUgaXRzIHZhbHVlXG4gICAgdmFsdWUgPSB0bXBsKGV4cHIuZXhwciwgY29udGV4dCk7XG5cbiAgICB2YXIgaGFzVmFsdWUgPSAhaXNCbGFuayh2YWx1ZSk7XG4gICAgdmFyIGlzT2JqID0gaXNPYmplY3QodmFsdWUpO1xuXG4gICAgLy8gY29udmVydCB0aGUgc3R5bGUvY2xhc3Mgb2JqZWN0cyB0byBzdHJpbmdzXG4gICAgaWYgKGlzT2JqKSB7XG4gICAgICBpZiAoaXNDbGFzc0F0dHIpIHtcbiAgICAgICAgdmFsdWUgPSB0bXBsKEpTT04uc3RyaW5naWZ5KHZhbHVlKSwgdGhpcyk7XG4gICAgICB9IGVsc2UgaWYgKGlzU3R5bGVBdHRyKSB7XG4gICAgICAgIHZhbHVlID0gc3R5bGVPYmplY3RUb1N0cmluZyh2YWx1ZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gcmVtb3ZlIG9yaWdpbmFsIGF0dHJpYnV0ZVxuICAgIGlmIChleHByLmF0dHIgJiYgKCFleHByLndhc1BhcnNlZE9uY2UgfHwgIWhhc1ZhbHVlIHx8IHZhbHVlID09PSBmYWxzZSkpIHtcbiAgICAgIC8vIHJlbW92ZSBlaXRoZXIgcmlvdC0qIGF0dHJpYnV0ZXMgb3IganVzdCB0aGUgYXR0cmlidXRlIG5hbWVcbiAgICAgIHJlbW92ZUF0dHJpYnV0ZShkb20sIGdldEF0dHJpYnV0ZShkb20sIGV4cHIuYXR0cikgPyBleHByLmF0dHIgOiBhdHRyTmFtZSk7XG4gICAgfVxuXG4gICAgLy8gZm9yIHRoZSBib29sZWFuIGF0dHJpYnV0ZXMgd2UgZG9uJ3QgbmVlZCB0aGUgdmFsdWVcbiAgICAvLyB3ZSBjYW4gY29udmVydCBpdCB0byBjaGVja2VkPXRydWUgdG8gY2hlY2tlZD1jaGVja2VkXG4gICAgaWYgKGV4cHIuYm9vbCkgeyB2YWx1ZSA9IHZhbHVlID8gYXR0ck5hbWUgOiBmYWxzZTsgfVxuICAgIGlmIChleHByLmlzUnRhZykgeyByZXR1cm4gdXBkYXRlRGF0YUlzKGV4cHIsIHRoaXMsIHZhbHVlKSB9XG4gICAgaWYgKGV4cHIud2FzUGFyc2VkT25jZSAmJiBleHByLnZhbHVlID09PSB2YWx1ZSkgeyByZXR1cm4gfVxuXG4gICAgLy8gdXBkYXRlIHRoZSBleHByZXNzaW9uIHZhbHVlXG4gICAgZXhwci52YWx1ZSA9IHZhbHVlO1xuICAgIGV4cHIud2FzUGFyc2VkT25jZSA9IHRydWU7XG5cbiAgICAvLyBpZiB0aGUgdmFsdWUgaXMgYW4gb2JqZWN0IChhbmQgaXQncyBub3QgYSBzdHlsZSBvciBjbGFzcyBhdHRyaWJ1dGUpIHdlIGNhbiBub3QgZG8gbXVjaCBtb3JlIHdpdGggaXRcbiAgICBpZiAoaXNPYmogJiYgIWlzQ2xhc3NBdHRyICYmICFpc1N0eWxlQXR0ciAmJiAhaXNUb2dnbGUpIHsgcmV0dXJuIH1cbiAgICAvLyBhdm9pZCB0byByZW5kZXIgdW5kZWZpbmVkL251bGwgdmFsdWVzXG4gICAgaWYgKCFoYXNWYWx1ZSkgeyB2YWx1ZSA9ICcnOyB9XG5cbiAgICAvLyB0ZXh0YXJlYSBhbmQgdGV4dCBub2RlcyBoYXZlIG5vIGF0dHJpYnV0ZSBuYW1lXG4gICAgaWYgKCFhdHRyTmFtZSkge1xuICAgICAgLy8gYWJvdXQgIzgxNSB3L28gcmVwbGFjZTogdGhlIGJyb3dzZXIgY29udmVydHMgdGhlIHZhbHVlIHRvIGEgc3RyaW5nLFxuICAgICAgLy8gdGhlIGNvbXBhcmlzb24gYnkgXCI9PVwiIGRvZXMgdG9vLCBidXQgbm90IGluIHRoZSBzZXJ2ZXJcbiAgICAgIHZhbHVlICs9ICcnO1xuICAgICAgLy8gdGVzdCBmb3IgcGFyZW50IGF2b2lkcyBlcnJvciB3aXRoIGludmFsaWQgYXNzaWdubWVudCB0byBub2RlVmFsdWVcbiAgICAgIGlmIChwYXJlbnQpIHtcbiAgICAgICAgLy8gY2FjaGUgdGhlIHBhcmVudCBub2RlIGJlY2F1c2Ugc29tZWhvdyBpdCB3aWxsIGJlY29tZSBudWxsIG9uIElFXG4gICAgICAgIC8vIG9uIHRoZSBuZXh0IGl0ZXJhdGlvblxuICAgICAgICBleHByLnBhcmVudCA9IHBhcmVudDtcbiAgICAgICAgaWYgKHBhcmVudC50YWdOYW1lID09PSAnVEVYVEFSRUEnKSB7XG4gICAgICAgICAgcGFyZW50LnZhbHVlID0gdmFsdWU7ICAgICAgICAgICAgICAgICAgICAvLyAjMTExM1xuICAgICAgICAgIGlmICghSUVfVkVSU0lPTikgeyBkb20ubm9kZVZhbHVlID0gdmFsdWU7IH0gIC8vICMxNjI1IElFIHRocm93cyBoZXJlLCBub2RlVmFsdWVcbiAgICAgICAgfSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gd2lsbCBiZSBhdmFpbGFibGUgb24gJ3VwZGF0ZWQnXG4gICAgICAgIGVsc2UgeyBkb20ubm9kZVZhbHVlID0gdmFsdWU7IH1cbiAgICAgIH1cbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIHN3aXRjaCAodHJ1ZSkge1xuICAgIC8vIGhhbmRsZSBldmVudHMgYmluZGluZ1xuICAgIGNhc2UgaXNGdW5jdGlvbih2YWx1ZSk6XG4gICAgICBpZiAoaXNFdmVudEF0dHJpYnV0ZShhdHRyTmFtZSkpIHtcbiAgICAgICAgc2V0RXZlbnRIYW5kbGVyKGF0dHJOYW1lLCB2YWx1ZSwgZG9tLCB0aGlzKTtcbiAgICAgIH1cbiAgICAgIGJyZWFrXG4gICAgLy8gc2hvdyAvIGhpZGVcbiAgICBjYXNlIGlzVG9nZ2xlOlxuICAgICAgdG9nZ2xlVmlzaWJpbGl0eShkb20sIGF0dHJOYW1lID09PSBISURFX0RJUkVDVElWRSA/ICF2YWx1ZSA6IHZhbHVlKTtcbiAgICAgIGJyZWFrXG4gICAgLy8gaGFuZGxlIGF0dHJpYnV0ZXNcbiAgICBkZWZhdWx0OlxuICAgICAgaWYgKGV4cHIuYm9vbCkge1xuICAgICAgICBkb21bYXR0ck5hbWVdID0gdmFsdWU7XG4gICAgICB9XG5cbiAgICAgIGlmIChhdHRyTmFtZSA9PT0gJ3ZhbHVlJyAmJiBkb20udmFsdWUgIT09IHZhbHVlKSB7XG4gICAgICAgIGRvbS52YWx1ZSA9IHZhbHVlO1xuICAgICAgfSBlbHNlIGlmIChoYXNWYWx1ZSAmJiB2YWx1ZSAhPT0gZmFsc2UpIHtcbiAgICAgICAgc2V0QXR0cmlidXRlKGRvbSwgYXR0ck5hbWUsIHZhbHVlKTtcbiAgICAgIH1cblxuICAgICAgLy8gbWFrZSBzdXJlIHRoYXQgaW4gY2FzZSBvZiBzdHlsZSBjaGFuZ2VzXG4gICAgICAvLyB0aGUgZWxlbWVudCBzdGF5cyBoaWRkZW5cbiAgICAgIGlmIChpc1N0eWxlQXR0ciAmJiBkb20uaGlkZGVuKSB7IHRvZ2dsZVZpc2liaWxpdHkoZG9tLCBmYWxzZSk7IH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogVXBkYXRlIGFsbCB0aGUgZXhwcmVzc2lvbnMgaW4gYSBUYWcgaW5zdGFuY2VcbiAgICogQHRoaXMgVGFnXG4gICAqIEBwYXJhbSB7IEFycmF5IH0gZXhwcmVzc2lvbnMgLSBleHByZXNzaW9uIHRoYXQgbXVzdCBiZSByZSBldmFsdWF0ZWRcbiAgICovXG4gIGZ1bmN0aW9uIHVwZGF0ZShleHByZXNzaW9ucykge1xuICAgIGVhY2goZXhwcmVzc2lvbnMsIHVwZGF0ZUV4cHJlc3Npb24uYmluZCh0aGlzKSk7XG4gIH1cblxuICAvKipcbiAgICogV2UgbmVlZCB0byB1cGRhdGUgb3B0cyBmb3IgdGhpcyB0YWcuIFRoYXQgcmVxdWlyZXMgdXBkYXRpbmcgdGhlIGV4cHJlc3Npb25zXG4gICAqIGluIGFueSBhdHRyaWJ1dGVzIG9uIHRoZSB0YWcsIGFuZCB0aGVuIGNvcHlpbmcgdGhlIHJlc3VsdCBvbnRvIG9wdHMuXG4gICAqIEB0aGlzIFRhZ1xuICAgKiBAcGFyYW0gICB7Qm9vbGVhbn0gaXNMb29wIC0gaXMgaXQgYSBsb29wIHRhZz9cbiAgICogQHBhcmFtICAgeyBUYWcgfSAgcGFyZW50IC0gcGFyZW50IHRhZyBub2RlXG4gICAqIEBwYXJhbSAgIHsgQm9vbGVhbiB9ICBpc0Fub255bW91cyAtIGlzIGl0IGEgdGFnIHdpdGhvdXQgYW55IGltcGw/IChhIHRhZyBub3QgcmVnaXN0ZXJlZClcbiAgICogQHBhcmFtICAgeyBPYmplY3QgfSAgb3B0cyAtIHRhZyBvcHRpb25zXG4gICAqIEBwYXJhbSAgIHsgQXJyYXkgfSAgaW5zdEF0dHJzIC0gdGFnIGF0dHJpYnV0ZXMgYXJyYXlcbiAgICovXG4gIGZ1bmN0aW9uIHVwZGF0ZU9wdHMoaXNMb29wLCBwYXJlbnQsIGlzQW5vbnltb3VzLCBvcHRzLCBpbnN0QXR0cnMpIHtcbiAgICAvLyBpc0Fub255bW91cyBgZWFjaGAgdGFncyB0cmVhdCBgZG9tYCBhbmQgYHJvb3RgIGRpZmZlcmVudGx5LiBJbiB0aGlzIGNhc2VcbiAgICAvLyAoYW5kIG9ubHkgdGhpcyBjYXNlKSB3ZSBkb24ndCBuZWVkIHRvIGRvIHVwZGF0ZU9wdHMsIGJlY2F1c2UgdGhlIHJlZ3VsYXIgcGFyc2VcbiAgICAvLyB3aWxsIHVwZGF0ZSB0aG9zZSBhdHRycy4gUGx1cywgaXNBbm9ueW1vdXMgdGFncyBkb24ndCBuZWVkIG9wdHMgYW55d2F5XG4gICAgaWYgKGlzTG9vcCAmJiBpc0Fub255bW91cykgeyByZXR1cm4gfVxuICAgIHZhciBjdHggPSBpc0xvb3AgPyBpbmhlcml0UGFyZW50UHJvcHMuY2FsbCh0aGlzKSA6IHBhcmVudCB8fCB0aGlzO1xuXG4gICAgZWFjaChpbnN0QXR0cnMsIGZ1bmN0aW9uIChhdHRyKSB7XG4gICAgICBpZiAoYXR0ci5leHByKSB7IHVwZGF0ZUV4cHJlc3Npb24uY2FsbChjdHgsIGF0dHIuZXhwcik7IH1cbiAgICAgIC8vIG5vcm1hbGl6ZSB0aGUgYXR0cmlidXRlIG5hbWVzXG4gICAgICBvcHRzW3RvQ2FtZWwoYXR0ci5uYW1lKS5yZXBsYWNlKEFUVFJTX1BSRUZJWCwgJycpXSA9IGF0dHIuZXhwciA/IGF0dHIuZXhwci52YWx1ZSA6IGF0dHIudmFsdWU7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogVXBkYXRlIHRoZSB0YWcgZXhwcmVzc2lvbnMgYW5kIG9wdGlvbnNcbiAgICogQHBhcmFtIHsgVGFnIH0gdGFnIC0gdGFnIG9iamVjdFxuICAgKiBAcGFyYW0geyAqIH0gZGF0YSAtIGRhdGEgd2Ugd2FudCB0byB1c2UgdG8gZXh0ZW5kIHRoZSB0YWcgcHJvcGVydGllc1xuICAgKiBAcGFyYW0geyBBcnJheSB9IGV4cHJlc3Npb25zIC0gY29tcG9uZW50IGV4cHJlc3Npb25zIGFycmF5XG4gICAqIEByZXR1cm5zIHsgVGFnIH0gdGhlIGN1cnJlbnQgdGFnIGluc3RhbmNlXG4gICAqL1xuICBmdW5jdGlvbiBjb21wb25lbnRVcGRhdGUodGFnLCBkYXRhLCBleHByZXNzaW9ucykge1xuICAgIHZhciBfXyA9IHRhZy5fXztcbiAgICB2YXIgbmV4dE9wdHMgPSB7fTtcbiAgICB2YXIgY2FuVHJpZ2dlciA9IHRhZy5pc01vdW50ZWQgJiYgIV9fLnNraXBBbm9ueW1vdXM7XG5cbiAgICAvLyBpbmhlcml0IHByb3BlcnRpZXMgZnJvbSB0aGUgcGFyZW50IHRhZ1xuICAgIGlmIChfXy5pc0Fub255bW91cyAmJiBfXy5wYXJlbnQpIHsgZXh0ZW5kKHRhZywgX18ucGFyZW50KTsgfVxuICAgIGV4dGVuZCh0YWcsIGRhdGEpO1xuXG4gICAgdXBkYXRlT3B0cy5hcHBseSh0YWcsIFtfXy5pc0xvb3AsIF9fLnBhcmVudCwgX18uaXNBbm9ueW1vdXMsIG5leHRPcHRzLCBfXy5pbnN0QXR0cnNdKTtcblxuICAgIGlmIChcbiAgICAgIGNhblRyaWdnZXIgJiZcbiAgICAgIHRhZy5pc01vdW50ZWQgJiZcbiAgICAgIGlzRnVuY3Rpb24odGFnLnNob3VsZFVwZGF0ZSkgJiYgIXRhZy5zaG91bGRVcGRhdGUoZGF0YSwgbmV4dE9wdHMpXG4gICAgKSB7XG4gICAgICByZXR1cm4gdGFnXG4gICAgfVxuXG4gICAgZXh0ZW5kKHRhZy5vcHRzLCBuZXh0T3B0cyk7XG5cbiAgICBpZiAoY2FuVHJpZ2dlcikgeyB0YWcudHJpZ2dlcigndXBkYXRlJywgZGF0YSk7IH1cbiAgICB1cGRhdGUuY2FsbCh0YWcsIGV4cHJlc3Npb25zKTtcbiAgICBpZiAoY2FuVHJpZ2dlcikgeyB0YWcudHJpZ2dlcigndXBkYXRlZCcpOyB9XG5cbiAgICByZXR1cm4gdGFnXG4gIH1cblxuICAvKipcbiAgICogR2V0IHNlbGVjdG9ycyBmb3IgdGFnc1xuICAgKiBAcGFyYW0gICB7IEFycmF5IH0gdGFncyAtIHRhZyBuYW1lcyB0byBzZWxlY3RcbiAgICogQHJldHVybnMgeyBTdHJpbmcgfSBzZWxlY3RvclxuICAgKi9cbiAgZnVuY3Rpb24gcXVlcnkodGFncykge1xuICAgIC8vIHNlbGVjdCBhbGwgdGFnc1xuICAgIGlmICghdGFncykge1xuICAgICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhfX1RBR19JTVBMKTtcbiAgICAgIHJldHVybiBrZXlzICsgcXVlcnkoa2V5cylcbiAgICB9XG5cbiAgICByZXR1cm4gdGFnc1xuICAgICAgLmZpbHRlcihmdW5jdGlvbiAodCkgeyByZXR1cm4gIS9bXi1cXHddLy50ZXN0KHQpOyB9KVxuICAgICAgLnJlZHVjZShmdW5jdGlvbiAobGlzdCwgdCkge1xuICAgICAgICB2YXIgbmFtZSA9IHQudHJpbSgpLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIHJldHVybiBsaXN0ICsgXCIsW1wiICsgSVNfRElSRUNUSVZFICsgXCI9XFxcIlwiICsgbmFtZSArIFwiXFxcIl1cIlxuICAgICAgfSwgJycpXG4gIH1cblxuICAvKipcbiAgICogQW5vdGhlciB3YXkgdG8gY3JlYXRlIGEgcmlvdCB0YWcgYSBiaXQgbW9yZSBlczYgZnJpZW5kbHlcbiAgICogQHBhcmFtIHsgSFRNTEVsZW1lbnQgfSBlbCAtIHRhZyBET00gc2VsZWN0b3Igb3IgRE9NIG5vZGUvc1xuICAgKiBAcGFyYW0geyBPYmplY3QgfSBvcHRzIC0gdGFnIGxvZ2ljXG4gICAqIEByZXR1cm5zIHsgVGFnIH0gbmV3IHJpb3QgdGFnIGluc3RhbmNlXG4gICAqL1xuICBmdW5jdGlvbiBUYWcoZWwsIG9wdHMpIHtcbiAgICAvLyBnZXQgdGhlIHRhZyBwcm9wZXJ0aWVzIGZyb20gdGhlIGNsYXNzIGNvbnN0cnVjdG9yXG4gICAgdmFyIHJlZiA9IHRoaXM7XG4gICAgdmFyIG5hbWUgPSByZWYubmFtZTtcbiAgICB2YXIgdG1wbCA9IHJlZi50bXBsO1xuICAgIHZhciBjc3MgPSByZWYuY3NzO1xuICAgIHZhciBhdHRycyA9IHJlZi5hdHRycztcbiAgICB2YXIgb25DcmVhdGUgPSByZWYub25DcmVhdGU7XG4gICAgLy8gcmVnaXN0ZXIgYSBuZXcgdGFnIGFuZCBjYWNoZSB0aGUgY2xhc3MgcHJvdG90eXBlXG4gICAgaWYgKCFfX1RBR19JTVBMW25hbWVdKSB7XG4gICAgICB0YWcobmFtZSwgdG1wbCwgY3NzLCBhdHRycywgb25DcmVhdGUpO1xuICAgICAgLy8gY2FjaGUgdGhlIGNsYXNzIGNvbnN0cnVjdG9yXG4gICAgICBfX1RBR19JTVBMW25hbWVdLmNsYXNzID0gdGhpcy5jb25zdHJ1Y3RvcjtcbiAgICB9XG5cbiAgICAvLyBtb3VudCB0aGUgdGFnIHVzaW5nIHRoZSBjbGFzcyBpbnN0YW5jZVxuICAgIG1vdW50JDEoZWwsIG5hbWUsIG9wdHMsIHRoaXMpO1xuICAgIC8vIGluamVjdCB0aGUgY29tcG9uZW50IGNzc1xuICAgIGlmIChjc3MpIHsgc3R5bGVNYW5hZ2VyLmluamVjdCgpOyB9XG5cbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIG5ldyByaW90IHRhZyBpbXBsZW1lbnRhdGlvblxuICAgKiBAcGFyYW0gICB7IFN0cmluZyB9ICAgbmFtZSAtIG5hbWUvaWQgb2YgdGhlIG5ldyByaW90IHRhZ1xuICAgKiBAcGFyYW0gICB7IFN0cmluZyB9ICAgdG1wbCAtIHRhZyB0ZW1wbGF0ZVxuICAgKiBAcGFyYW0gICB7IFN0cmluZyB9ICAgY3NzIC0gY3VzdG9tIHRhZyBjc3NcbiAgICogQHBhcmFtICAgeyBTdHJpbmcgfSAgIGF0dHJzIC0gcm9vdCB0YWcgYXR0cmlidXRlc1xuICAgKiBAcGFyYW0gICB7IEZ1bmN0aW9uIH0gZm4gLSB1c2VyIGZ1bmN0aW9uXG4gICAqIEByZXR1cm5zIHsgU3RyaW5nIH0gbmFtZS9pZCBvZiB0aGUgdGFnIGp1c3QgY3JlYXRlZFxuICAgKi9cbiAgZnVuY3Rpb24gdGFnKG5hbWUsIHRtcGwsIGNzcywgYXR0cnMsIGZuKSB7XG4gICAgaWYgKGlzRnVuY3Rpb24oYXR0cnMpKSB7XG4gICAgICBmbiA9IGF0dHJzO1xuXG4gICAgICBpZiAoL15bXFx3LV0rXFxzPz0vLnRlc3QoY3NzKSkge1xuICAgICAgICBhdHRycyA9IGNzcztcbiAgICAgICAgY3NzID0gJyc7XG4gICAgICB9IGVsc2VcbiAgICAgICAgeyBhdHRycyA9ICcnOyB9XG4gICAgfVxuXG4gICAgaWYgKGNzcykge1xuICAgICAgaWYgKGlzRnVuY3Rpb24oY3NzKSlcbiAgICAgICAgeyBmbiA9IGNzczsgfVxuICAgICAgZWxzZVxuICAgICAgICB7IHN0eWxlTWFuYWdlci5hZGQoY3NzLCBuYW1lKTsgfVxuICAgIH1cblxuICAgIG5hbWUgPSBuYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgX19UQUdfSU1QTFtuYW1lXSA9IHsgbmFtZTogbmFtZSwgdG1wbDogdG1wbCwgYXR0cnM6IGF0dHJzLCBmbjogZm4gfTtcblxuICAgIHJldHVybiBuYW1lXG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIGEgbmV3IHJpb3QgdGFnIGltcGxlbWVudGF0aW9uIChmb3IgdXNlIGJ5IHRoZSBjb21waWxlcilcbiAgICogQHBhcmFtICAgeyBTdHJpbmcgfSAgIG5hbWUgLSBuYW1lL2lkIG9mIHRoZSBuZXcgcmlvdCB0YWdcbiAgICogQHBhcmFtICAgeyBTdHJpbmcgfSAgIHRtcGwgLSB0YWcgdGVtcGxhdGVcbiAgICogQHBhcmFtICAgeyBTdHJpbmcgfSAgIGNzcyAtIGN1c3RvbSB0YWcgY3NzXG4gICAqIEBwYXJhbSAgIHsgU3RyaW5nIH0gICBhdHRycyAtIHJvb3QgdGFnIGF0dHJpYnV0ZXNcbiAgICogQHBhcmFtICAgeyBGdW5jdGlvbiB9IGZuIC0gdXNlciBmdW5jdGlvblxuICAgKiBAcmV0dXJucyB7IFN0cmluZyB9IG5hbWUvaWQgb2YgdGhlIHRhZyBqdXN0IGNyZWF0ZWRcbiAgICovXG4gIGZ1bmN0aW9uIHRhZzIobmFtZSwgdG1wbCwgY3NzLCBhdHRycywgZm4pIHtcbiAgICBpZiAoY3NzKSB7IHN0eWxlTWFuYWdlci5hZGQoY3NzLCBuYW1lKTsgfVxuXG4gICAgX19UQUdfSU1QTFtuYW1lXSA9IHsgbmFtZTogbmFtZSwgdG1wbDogdG1wbCwgYXR0cnM6IGF0dHJzLCBmbjogZm4gfTtcblxuICAgIHJldHVybiBuYW1lXG4gIH1cblxuICAvKipcbiAgICogTW91bnQgYSB0YWcgdXNpbmcgYSBzcGVjaWZpYyB0YWcgaW1wbGVtZW50YXRpb25cbiAgICogQHBhcmFtICAgeyAqIH0gc2VsZWN0b3IgLSB0YWcgRE9NIHNlbGVjdG9yIG9yIERPTSBub2RlL3NcbiAgICogQHBhcmFtICAgeyBTdHJpbmcgfSB0YWdOYW1lIC0gdGFnIGltcGxlbWVudGF0aW9uIG5hbWVcbiAgICogQHBhcmFtICAgeyBPYmplY3QgfSBvcHRzIC0gdGFnIGxvZ2ljXG4gICAqIEByZXR1cm5zIHsgQXJyYXkgfSBuZXcgdGFncyBpbnN0YW5jZXNcbiAgICovXG4gIGZ1bmN0aW9uIG1vdW50KHNlbGVjdG9yLCB0YWdOYW1lLCBvcHRzKSB7XG4gICAgdmFyIHRhZ3MgPSBbXTtcbiAgICB2YXIgZWxlbSwgYWxsVGFncztcblxuICAgIGZ1bmN0aW9uIHB1c2hUYWdzVG8ocm9vdCkge1xuICAgICAgaWYgKHJvb3QudGFnTmFtZSkge1xuICAgICAgICB2YXIgcmlvdFRhZyA9IGdldEF0dHJpYnV0ZShyb290LCBJU19ESVJFQ1RJVkUpLCB0YWc7XG5cbiAgICAgICAgLy8gaGF2ZSB0YWdOYW1lPyBmb3JjZSByaW90LXRhZyB0byBiZSB0aGUgc2FtZVxuICAgICAgICBpZiAodGFnTmFtZSAmJiByaW90VGFnICE9PSB0YWdOYW1lKSB7XG4gICAgICAgICAgcmlvdFRhZyA9IHRhZ05hbWU7XG4gICAgICAgICAgc2V0QXR0cmlidXRlKHJvb3QsIElTX0RJUkVDVElWRSwgdGFnTmFtZSk7XG4gICAgICAgIH1cblxuICAgICAgICB0YWcgPSBtb3VudCQxKHJvb3QsIHJpb3RUYWcgfHwgcm9vdC50YWdOYW1lLnRvTG93ZXJDYXNlKCksIG9wdHMpO1xuXG4gICAgICAgIGlmICh0YWcpXG4gICAgICAgICAgeyB0YWdzLnB1c2godGFnKTsgfVxuICAgICAgfSBlbHNlIGlmIChyb290Lmxlbmd0aClcbiAgICAgICAgeyBlYWNoKHJvb3QsIHB1c2hUYWdzVG8pOyB9IC8vIGFzc3VtZSBub2RlTGlzdFxuICAgIH1cblxuICAgIC8vIGluamVjdCBzdHlsZXMgaW50byBET01cbiAgICBzdHlsZU1hbmFnZXIuaW5qZWN0KCk7XG5cbiAgICBpZiAoaXNPYmplY3QodGFnTmFtZSkpIHtcbiAgICAgIG9wdHMgPSB0YWdOYW1lO1xuICAgICAgdGFnTmFtZSA9IDA7XG4gICAgfVxuXG4gICAgLy8gY3Jhd2wgdGhlIERPTSB0byBmaW5kIHRoZSB0YWdcbiAgICBpZiAoaXNTdHJpbmcoc2VsZWN0b3IpKSB7XG4gICAgICBzZWxlY3RvciA9IHNlbGVjdG9yID09PSAnKicgP1xuICAgICAgICAvLyBzZWxlY3QgYWxsIHJlZ2lzdGVyZWQgdGFnc1xuICAgICAgICAvLyAmIHRhZ3MgZm91bmQgd2l0aCB0aGUgcmlvdC10YWcgYXR0cmlidXRlIHNldFxuICAgICAgICBhbGxUYWdzID0gcXVlcnkoKSA6XG4gICAgICAgIC8vIG9yIGp1c3QgdGhlIG9uZXMgbmFtZWQgbGlrZSB0aGUgc2VsZWN0b3JcbiAgICAgICAgc2VsZWN0b3IgKyBxdWVyeShzZWxlY3Rvci5zcGxpdCgvLCAqLykpO1xuXG4gICAgICAvLyBtYWtlIHN1cmUgdG8gcGFzcyBhbHdheXMgYSBzZWxlY3RvclxuICAgICAgLy8gdG8gdGhlIHF1ZXJ5U2VsZWN0b3JBbGwgZnVuY3Rpb25cbiAgICAgIGVsZW0gPSBzZWxlY3RvciA/ICQkKHNlbGVjdG9yKSA6IFtdO1xuICAgIH1cbiAgICBlbHNlXG4gICAgICAvLyBwcm9iYWJseSB5b3UgaGF2ZSBwYXNzZWQgYWxyZWFkeSBhIHRhZyBvciBhIE5vZGVMaXN0XG4gICAgICB7IGVsZW0gPSBzZWxlY3RvcjsgfVxuXG4gICAgLy8gc2VsZWN0IGFsbCB0aGUgcmVnaXN0ZXJlZCBhbmQgbW91bnQgdGhlbSBpbnNpZGUgdGhlaXIgcm9vdCBlbGVtZW50c1xuICAgIGlmICh0YWdOYW1lID09PSAnKicpIHtcbiAgICAgIC8vIGdldCBhbGwgY3VzdG9tIHRhZ3NcbiAgICAgIHRhZ05hbWUgPSBhbGxUYWdzIHx8IHF1ZXJ5KCk7XG4gICAgICAvLyBpZiB0aGUgcm9vdCBlbHMgaXQncyBqdXN0IGEgc2luZ2xlIHRhZ1xuICAgICAgaWYgKGVsZW0udGFnTmFtZSlcbiAgICAgICAgeyBlbGVtID0gJCQodGFnTmFtZSwgZWxlbSk7IH1cbiAgICAgIGVsc2Uge1xuICAgICAgICAvLyBzZWxlY3QgYWxsIHRoZSBjaGlsZHJlbiBmb3IgYWxsIHRoZSBkaWZmZXJlbnQgcm9vdCBlbGVtZW50c1xuICAgICAgICB2YXIgbm9kZUxpc3QgPSBbXTtcblxuICAgICAgICBlYWNoKGVsZW0sIGZ1bmN0aW9uIChfZWwpIHsgcmV0dXJuIG5vZGVMaXN0LnB1c2goJCQodGFnTmFtZSwgX2VsKSk7IH0pO1xuXG4gICAgICAgIGVsZW0gPSBub2RlTGlzdDtcbiAgICAgIH1cbiAgICAgIC8vIGdldCByaWQgb2YgdGhlIHRhZ05hbWVcbiAgICAgIHRhZ05hbWUgPSAwO1xuICAgIH1cblxuICAgIHB1c2hUYWdzVG8oZWxlbSk7XG5cbiAgICByZXR1cm4gdGFnc1xuICB9XG5cbiAgLy8gQ3JlYXRlIGEgbWl4aW4gdGhhdCBjb3VsZCBiZSBnbG9iYWxseSBzaGFyZWQgYWNyb3NzIGFsbCB0aGUgdGFnc1xuICB2YXIgbWl4aW5zID0ge307XG4gIHZhciBnbG9iYWxzID0gbWl4aW5zW0dMT0JBTF9NSVhJTl0gPSB7fTtcbiAgdmFyIG1peGluc19pZCA9IDA7XG5cbiAgLyoqXG4gICAqIENyZWF0ZS9SZXR1cm4gYSBtaXhpbiBieSBpdHMgbmFtZVxuICAgKiBAcGFyYW0gICB7IFN0cmluZyB9ICBuYW1lIC0gbWl4aW4gbmFtZSAoZ2xvYmFsIG1peGluIGlmIG9iamVjdClcbiAgICogQHBhcmFtICAgeyBPYmplY3QgfSAgbWl4IC0gbWl4aW4gbG9naWNcbiAgICogQHBhcmFtICAgeyBCb29sZWFuIH0gZyAtIGlzIGdsb2JhbD9cbiAgICogQHJldHVybnMgeyBPYmplY3QgfSAgdGhlIG1peGluIGxvZ2ljXG4gICAqL1xuICBmdW5jdGlvbiBtaXhpbihuYW1lLCBtaXgsIGcpIHtcbiAgICAvLyBVbm5hbWVkIGdsb2JhbFxuICAgIGlmIChpc09iamVjdChuYW1lKSkge1xuICAgICAgbWl4aW4oKFwiX19cIiArIChtaXhpbnNfaWQrKykgKyBcIl9fXCIpLCBuYW1lLCB0cnVlKTtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIHZhciBzdG9yZSA9IGcgPyBnbG9iYWxzIDogbWl4aW5zO1xuXG4gICAgLy8gR2V0dGVyXG4gICAgaWYgKCFtaXgpIHtcbiAgICAgIGlmIChpc1VuZGVmaW5lZChzdG9yZVtuYW1lXSkpXG4gICAgICAgIHsgdGhyb3cgbmV3IEVycm9yKChcIlVucmVnaXN0ZXJlZCBtaXhpbjogXCIgKyBuYW1lKSkgfVxuXG4gICAgICByZXR1cm4gc3RvcmVbbmFtZV1cbiAgICB9XG5cbiAgICAvLyBTZXR0ZXJcbiAgICBzdG9yZVtuYW1lXSA9IGlzRnVuY3Rpb24obWl4KSA/XG4gICAgICBleHRlbmQobWl4LnByb3RvdHlwZSwgc3RvcmVbbmFtZV0gfHwge30pICYmIG1peCA6XG4gICAgICBleHRlbmQoc3RvcmVbbmFtZV0gfHwge30sIG1peCk7XG4gIH1cblxuICAvKipcbiAgICogVXBkYXRlIGFsbCB0aGUgdGFncyBpbnN0YW5jZXMgY3JlYXRlZFxuICAgKiBAcmV0dXJucyB7IEFycmF5IH0gYWxsIHRoZSB0YWdzIGluc3RhbmNlc1xuICAgKi9cbiAgZnVuY3Rpb24gdXBkYXRlJDEoKSB7XG4gICAgcmV0dXJuIGVhY2goX19UQUdTX0NBQ0hFLCBmdW5jdGlvbiAodGFnKSB7IHJldHVybiB0YWcudXBkYXRlKCk7IH0pXG4gIH1cblxuICBmdW5jdGlvbiB1bnJlZ2lzdGVyKG5hbWUpIHtcbiAgICBzdHlsZU1hbmFnZXIucmVtb3ZlKG5hbWUpO1xuICAgIHJldHVybiBkZWxldGUgX19UQUdfSU1QTFtuYW1lXVxuICB9XG5cbiAgdmFyIHZlcnNpb24gPSAndjMuMTAuMic7XG5cbiAgdmFyIGNvcmUgPSAvKiNfX1BVUkVfXyovT2JqZWN0LmZyZWV6ZSh7XG4gICAgVGFnOiBUYWcsXG4gICAgdGFnOiB0YWcsXG4gICAgdGFnMjogdGFnMixcbiAgICBtb3VudDogbW91bnQsXG4gICAgbWl4aW46IG1peGluLFxuICAgIHVwZGF0ZTogdXBkYXRlJDEsXG4gICAgdW5yZWdpc3RlcjogdW5yZWdpc3RlcixcbiAgICB2ZXJzaW9uOiB2ZXJzaW9uXG4gIH0pO1xuXG4gIC8qKlxuICAgKiBBZGQgYSBtaXhpbiB0byB0aGlzIHRhZ1xuICAgKiBAcmV0dXJucyB7IFRhZyB9IHRoZSBjdXJyZW50IHRhZyBpbnN0YW5jZVxuICAgKi9cbiAgZnVuY3Rpb24gY29tcG9uZW50TWl4aW4odGFnJCQxKSB7XG4gICAgdmFyIG1peGlucyA9IFtdLCBsZW4gPSBhcmd1bWVudHMubGVuZ3RoIC0gMTtcbiAgICB3aGlsZSAoIGxlbi0tID4gMCApIG1peGluc1sgbGVuIF0gPSBhcmd1bWVudHNbIGxlbiArIDEgXTtcblxuICAgIGVhY2gobWl4aW5zLCBmdW5jdGlvbiAobWl4KSB7XG4gICAgICB2YXIgaW5zdGFuY2U7XG4gICAgICB2YXIgb2JqO1xuICAgICAgdmFyIHByb3BzID0gW107XG5cbiAgICAgIC8vIHByb3BlcnRpZXMgYmxhY2tsaXN0ZWQgYW5kIHdpbGwgbm90IGJlIGJvdW5kIHRvIHRoZSB0YWcgaW5zdGFuY2VcbiAgICAgIHZhciBwcm9wc0JsYWNrbGlzdCA9IFsnaW5pdCcsICdfX3Byb3RvX18nXTtcblxuICAgICAgbWl4ID0gaXNTdHJpbmcobWl4KSA/IG1peGluKG1peCkgOiBtaXg7XG5cbiAgICAgIC8vIGNoZWNrIGlmIHRoZSBtaXhpbiBpcyBhIGZ1bmN0aW9uXG4gICAgICBpZiAoaXNGdW5jdGlvbihtaXgpKSB7XG4gICAgICAgIC8vIGNyZWF0ZSB0aGUgbmV3IG1peGluIGluc3RhbmNlXG4gICAgICAgIGluc3RhbmNlID0gbmV3IG1peCgpO1xuICAgICAgfSBlbHNlIHsgaW5zdGFuY2UgPSBtaXg7IH1cblxuICAgICAgdmFyIHByb3RvID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKGluc3RhbmNlKTtcblxuICAgICAgLy8gYnVpbGQgbXVsdGlsZXZlbCBwcm90b3R5cGUgaW5oZXJpdGFuY2UgY2hhaW4gcHJvcGVydHkgbGlzdFxuICAgICAgZG8geyBwcm9wcyA9IHByb3BzLmNvbmNhdChPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhvYmogfHwgaW5zdGFuY2UpKTsgfVxuICAgICAgd2hpbGUgKG9iaiA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihvYmogfHwgaW5zdGFuY2UpKVxuXG4gICAgICAvLyBsb29wIHRoZSBrZXlzIGluIHRoZSBmdW5jdGlvbiBwcm90b3R5cGUgb3IgdGhlIGFsbCBvYmplY3Qga2V5c1xuICAgICAgZWFjaChwcm9wcywgZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAvLyBiaW5kIG1ldGhvZHMgdG8gdGFnXG4gICAgICAgIC8vIGFsbG93IG1peGlucyB0byBvdmVycmlkZSBvdGhlciBwcm9wZXJ0aWVzL3BhcmVudCBtaXhpbnNcbiAgICAgICAgaWYgKCFjb250YWlucyhwcm9wc0JsYWNrbGlzdCwga2V5KSkge1xuICAgICAgICAgIC8vIGNoZWNrIGZvciBnZXR0ZXJzL3NldHRlcnNcbiAgICAgICAgICB2YXIgZGVzY3JpcHRvciA9IGdldFByb3BEZXNjcmlwdG9yKGluc3RhbmNlLCBrZXkpIHx8IGdldFByb3BEZXNjcmlwdG9yKHByb3RvLCBrZXkpO1xuICAgICAgICAgIHZhciBoYXNHZXR0ZXJTZXR0ZXIgPSBkZXNjcmlwdG9yICYmIChkZXNjcmlwdG9yLmdldCB8fCBkZXNjcmlwdG9yLnNldCk7XG5cbiAgICAgICAgICAvLyBhcHBseSBtZXRob2Qgb25seSBpZiBpdCBkb2VzIG5vdCBhbHJlYWR5IGV4aXN0IG9uIHRoZSBpbnN0YW5jZVxuICAgICAgICAgIGlmICghdGFnJCQxLmhhc093blByb3BlcnR5KGtleSkgJiYgaGFzR2V0dGVyU2V0dGVyKSB7XG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFnJCQxLCBrZXksIGRlc2NyaXB0b3IpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0YWckJDFba2V5XSA9IGlzRnVuY3Rpb24oaW5zdGFuY2Vba2V5XSkgP1xuICAgICAgICAgICAgICBpbnN0YW5jZVtrZXldLmJpbmQodGFnJCQxKSA6XG4gICAgICAgICAgICAgIGluc3RhbmNlW2tleV07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgLy8gaW5pdCBtZXRob2Qgd2lsbCBiZSBjYWxsZWQgYXV0b21hdGljYWxseVxuICAgICAgaWYgKGluc3RhbmNlLmluaXQpXG4gICAgICAgIHsgaW5zdGFuY2UuaW5pdC5iaW5kKHRhZyQkMSkodGFnJCQxLm9wdHMpOyB9XG4gICAgfSk7XG5cbiAgICByZXR1cm4gdGFnJCQxXG4gIH1cblxuICAvKipcbiAgICogTW92ZSB0aGUgcG9zaXRpb24gb2YgYSBjdXN0b20gdGFnIGluIGl0cyBwYXJlbnQgdGFnXG4gICAqIEB0aGlzIFRhZ1xuICAgKiBAcGFyYW0gICB7IFN0cmluZyB9IHRhZ05hbWUgLSBrZXkgd2hlcmUgdGhlIHRhZyB3YXMgc3RvcmVkXG4gICAqIEBwYXJhbSAgIHsgTnVtYmVyIH0gbmV3UG9zIC0gaW5kZXggd2hlcmUgdGhlIG5ldyB0YWcgd2lsbCBiZSBzdG9yZWRcbiAgICovXG4gIGZ1bmN0aW9uIG1vdmVDaGlsZCh0YWdOYW1lLCBuZXdQb3MpIHtcbiAgICB2YXIgcGFyZW50ID0gdGhpcy5wYXJlbnQ7XG4gICAgdmFyIHRhZ3M7XG4gICAgLy8gbm8gcGFyZW50IG5vIG1vdmVcbiAgICBpZiAoIXBhcmVudCkgeyByZXR1cm4gfVxuXG4gICAgdGFncyA9IHBhcmVudC50YWdzW3RhZ05hbWVdO1xuXG4gICAgaWYgKGlzQXJyYXkodGFncykpXG4gICAgICB7IHRhZ3Muc3BsaWNlKG5ld1BvcywgMCwgdGFncy5zcGxpY2UodGFncy5pbmRleE9mKHRoaXMpLCAxKVswXSk7IH1cbiAgICBlbHNlIHsgYXJyYXlpc2hBZGQocGFyZW50LnRhZ3MsIHRhZ05hbWUsIHRoaXMpOyB9XG4gIH1cblxuICAvKipcbiAgICogTW92ZSB2aXJ0dWFsIHRhZyBhbmQgYWxsIGNoaWxkIG5vZGVzXG4gICAqIEB0aGlzIFRhZ1xuICAgKiBAcGFyYW0geyBOb2RlIH0gc3JjICAtIHRoZSBub2RlIHRoYXQgd2lsbCBkbyB0aGUgaW5zZXJ0aW5nXG4gICAqIEBwYXJhbSB7IFRhZyB9IHRhcmdldCAtIGluc2VydCBiZWZvcmUgdGhpcyB0YWcncyBmaXJzdCBjaGlsZFxuICAgKi9cbiAgZnVuY3Rpb24gbW92ZVZpcnR1YWwoc3JjLCB0YXJnZXQpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgIHZhciBlbCA9IHRoaXMuX18uaGVhZDtcbiAgICB2YXIgc2liO1xuICAgIHZhciBmcmFnID0gY3JlYXRlRnJhZ21lbnQoKTtcblxuICAgIHdoaWxlIChlbCkge1xuICAgICAgc2liID0gZWwubmV4dFNpYmxpbmc7XG4gICAgICBmcmFnLmFwcGVuZENoaWxkKGVsKTtcbiAgICAgIGVsID0gc2liO1xuICAgICAgaWYgKGVsID09PSB0aGlzJDEuX18udGFpbCkge1xuICAgICAgICBmcmFnLmFwcGVuZENoaWxkKGVsKTtcbiAgICAgICAgc3JjLmluc2VydEJlZm9yZShmcmFnLCB0YXJnZXQuX18uaGVhZCk7XG4gICAgICAgIGJyZWFrXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENvbnZlcnQgdGhlIGl0ZW0gbG9vcGVkIGludG8gYW4gb2JqZWN0IHVzZWQgdG8gZXh0ZW5kIHRoZSBjaGlsZCB0YWcgcHJvcGVydGllc1xuICAgKiBAcGFyYW0gICB7IE9iamVjdCB9IGV4cHIgLSBvYmplY3QgY29udGFpbmluZyB0aGUga2V5cyB1c2VkIHRvIGV4dGVuZCB0aGUgY2hpbGRyZW4gdGFnc1xuICAgKiBAcGFyYW0gICB7ICogfSBrZXkgLSB2YWx1ZSB0byBhc3NpZ24gdG8gdGhlIG5ldyBvYmplY3QgcmV0dXJuZWRcbiAgICogQHBhcmFtICAgeyAqIH0gdmFsIC0gdmFsdWUgY29udGFpbmluZyB0aGUgcG9zaXRpb24gb2YgdGhlIGl0ZW0gaW4gdGhlIGFycmF5XG4gICAqIEByZXR1cm5zIHsgT2JqZWN0IH0gLSBuZXcgb2JqZWN0IGNvbnRhaW5pbmcgdGhlIHZhbHVlcyBvZiB0aGUgb3JpZ2luYWwgaXRlbVxuICAgKlxuICAgKiBUaGUgdmFyaWFibGVzICdrZXknIGFuZCAndmFsJyBhcmUgYXJiaXRyYXJ5LlxuICAgKiBUaGV5IGRlcGVuZCBvbiB0aGUgY29sbGVjdGlvbiB0eXBlIGxvb3BlZCAoQXJyYXksIE9iamVjdClcbiAgICogYW5kIG9uIHRoZSBleHByZXNzaW9uIHVzZWQgb24gdGhlIGVhY2ggdGFnXG4gICAqXG4gICAqL1xuICBmdW5jdGlvbiBta2l0ZW0oZXhwciwga2V5LCB2YWwpIHtcbiAgICB2YXIgaXRlbSA9IHt9O1xuICAgIGl0ZW1bZXhwci5rZXldID0ga2V5O1xuICAgIGlmIChleHByLnBvcykgeyBpdGVtW2V4cHIucG9zXSA9IHZhbDsgfVxuICAgIHJldHVybiBpdGVtXG4gIH1cblxuICAvKipcbiAgICogVW5tb3VudCB0aGUgcmVkdW5kYW50IHRhZ3NcbiAgICogQHBhcmFtICAgeyBBcnJheSB9IGl0ZW1zIC0gYXJyYXkgY29udGFpbmluZyB0aGUgY3VycmVudCBpdGVtcyB0byBsb29wXG4gICAqIEBwYXJhbSAgIHsgQXJyYXkgfSB0YWdzIC0gYXJyYXkgY29udGFpbmluZyBhbGwgdGhlIGNoaWxkcmVuIHRhZ3NcbiAgICovXG4gIGZ1bmN0aW9uIHVubW91bnRSZWR1bmRhbnQoaXRlbXMsIHRhZ3MsIGZpbHRlcmVkSXRlbXNDb3VudCkge1xuICAgIHZhciBpID0gdGFncy5sZW5ndGg7XG4gICAgdmFyIGogPSBpdGVtcy5sZW5ndGggLSBmaWx0ZXJlZEl0ZW1zQ291bnQ7XG5cbiAgICB3aGlsZSAoaSA+IGopIHtcbiAgICAgIGktLTtcbiAgICAgIHJlbW92ZS5hcHBseSh0YWdzW2ldLCBbdGFncywgaV0pO1xuICAgIH1cbiAgfVxuXG5cbiAgLyoqXG4gICAqIFJlbW92ZSBhIGNoaWxkIHRhZ1xuICAgKiBAdGhpcyBUYWdcbiAgICogQHBhcmFtICAgeyBBcnJheSB9IHRhZ3MgLSB0YWdzIGNvbGxlY3Rpb25cbiAgICogQHBhcmFtICAgeyBOdW1iZXIgfSBpIC0gaW5kZXggb2YgdGhlIHRhZyB0byByZW1vdmVcbiAgICovXG4gIGZ1bmN0aW9uIHJlbW92ZSh0YWdzLCBpKSB7XG4gICAgdGFncy5zcGxpY2UoaSwgMSk7XG4gICAgdGhpcy51bm1vdW50KCk7XG4gICAgYXJyYXlpc2hSZW1vdmUodGhpcy5wYXJlbnQsIHRoaXMsIHRoaXMuX18udGFnTmFtZSwgdHJ1ZSk7XG4gIH1cblxuICAvKipcbiAgICogTW92ZSB0aGUgbmVzdGVkIGN1c3RvbSB0YWdzIGluIG5vbiBjdXN0b20gbG9vcCB0YWdzXG4gICAqIEB0aGlzIFRhZ1xuICAgKiBAcGFyYW0gICB7IE51bWJlciB9IGkgLSBjdXJyZW50IHBvc2l0aW9uIG9mIHRoZSBsb29wIHRhZ1xuICAgKi9cbiAgZnVuY3Rpb24gbW92ZU5lc3RlZFRhZ3MoaSkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgZWFjaChPYmplY3Qua2V5cyh0aGlzLnRhZ3MpLCBmdW5jdGlvbiAodGFnTmFtZSkge1xuICAgICAgbW92ZUNoaWxkLmFwcGx5KHRoaXMkMS50YWdzW3RhZ05hbWVdLCBbdGFnTmFtZSwgaV0pO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIE1vdmUgYSBjaGlsZCB0YWdcbiAgICogQHRoaXMgVGFnXG4gICAqIEBwYXJhbSAgIHsgSFRNTEVsZW1lbnQgfSByb290IC0gZG9tIG5vZGUgY29udGFpbmluZyBhbGwgdGhlIGxvb3AgY2hpbGRyZW5cbiAgICogQHBhcmFtICAgeyBUYWcgfSBuZXh0VGFnIC0gaW5zdGFuY2Ugb2YgdGhlIG5leHQgdGFnIHByZWNlZGluZyB0aGUgb25lIHdlIHdhbnQgdG8gbW92ZVxuICAgKiBAcGFyYW0gICB7IEJvb2xlYW4gfSBpc1ZpcnR1YWwgLSBpcyBpdCBhIHZpcnR1YWwgdGFnP1xuICAgKi9cbiAgZnVuY3Rpb24gbW92ZShyb290LCBuZXh0VGFnLCBpc1ZpcnR1YWwpIHtcbiAgICBpZiAoaXNWaXJ0dWFsKVxuICAgICAgeyBtb3ZlVmlydHVhbC5hcHBseSh0aGlzLCBbcm9vdCwgbmV4dFRhZ10pOyB9XG4gICAgZWxzZVxuICAgICAgeyBzYWZlSW5zZXJ0KHJvb3QsIHRoaXMucm9vdCwgbmV4dFRhZy5yb290KTsgfVxuICB9XG5cbiAgLyoqXG4gICAqIEluc2VydCBhbmQgbW91bnQgYSBjaGlsZCB0YWdcbiAgICogQHRoaXMgVGFnXG4gICAqIEBwYXJhbSAgIHsgSFRNTEVsZW1lbnQgfSByb290IC0gZG9tIG5vZGUgY29udGFpbmluZyBhbGwgdGhlIGxvb3AgY2hpbGRyZW5cbiAgICogQHBhcmFtICAgeyBUYWcgfSBuZXh0VGFnIC0gaW5zdGFuY2Ugb2YgdGhlIG5leHQgdGFnIHByZWNlZGluZyB0aGUgb25lIHdlIHdhbnQgdG8gaW5zZXJ0XG4gICAqIEBwYXJhbSAgIHsgQm9vbGVhbiB9IGlzVmlydHVhbCAtIGlzIGl0IGEgdmlydHVhbCB0YWc/XG4gICAqL1xuICBmdW5jdGlvbiBpbnNlcnQocm9vdCwgbmV4dFRhZywgaXNWaXJ0dWFsKSB7XG4gICAgaWYgKGlzVmlydHVhbClcbiAgICAgIHsgbWFrZVZpcnR1YWwuYXBwbHkodGhpcywgW3Jvb3QsIG5leHRUYWddKTsgfVxuICAgIGVsc2VcbiAgICAgIHsgc2FmZUluc2VydChyb290LCB0aGlzLnJvb3QsIG5leHRUYWcucm9vdCk7IH1cbiAgfVxuXG4gIC8qKlxuICAgKiBBcHBlbmQgYSBuZXcgdGFnIGludG8gdGhlIERPTVxuICAgKiBAdGhpcyBUYWdcbiAgICogQHBhcmFtICAgeyBIVE1MRWxlbWVudCB9IHJvb3QgLSBkb20gbm9kZSBjb250YWluaW5nIGFsbCB0aGUgbG9vcCBjaGlsZHJlblxuICAgKiBAcGFyYW0gICB7IEJvb2xlYW4gfSBpc1ZpcnR1YWwgLSBpcyBpdCBhIHZpcnR1YWwgdGFnP1xuICAgKi9cbiAgZnVuY3Rpb24gYXBwZW5kKHJvb3QsIGlzVmlydHVhbCkge1xuICAgIGlmIChpc1ZpcnR1YWwpXG4gICAgICB7IG1ha2VWaXJ0dWFsLmNhbGwodGhpcywgcm9vdCk7IH1cbiAgICBlbHNlXG4gICAgICB7IHJvb3QuYXBwZW5kQ2hpbGQodGhpcy5yb290KTsgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiB0aGUgdmFsdWUgd2Ugd2FudCB0byB1c2UgdG8gbG9va3VwIHRoZSBwb3N0aW9uIG9mIG91ciBpdGVtcyBpbiB0aGUgY29sbGVjdGlvblxuICAgKiBAcGFyYW0gICB7IFN0cmluZyB9ICBrZXlBdHRyICAgICAgICAgLSBsb29rdXAgc3RyaW5nIG9yIGV4cHJlc3Npb25cbiAgICogQHBhcmFtICAgeyAqIH0gICAgICAgb3JpZ2luYWxJdGVtICAgIC0gb3JpZ2luYWwgaXRlbSBmcm9tIHRoZSBjb2xsZWN0aW9uXG4gICAqIEBwYXJhbSAgIHsgT2JqZWN0IH0gIGtleWVkSXRlbSAgICAgICAtIG9iamVjdCBjcmVhdGVkIGJ5IHJpb3QgdmlhIHsgaXRlbSwgaSBpbiBjb2xsZWN0aW9uIH1cbiAgICogQHBhcmFtICAgeyBCb29sZWFuIH0gaGFzS2V5QXR0ckV4cHIgIC0gZmxhZyB0byBjaGVjayB3aGV0aGVyIHRoZSBrZXkgaXMgYW4gZXhwcmVzc2lvblxuICAgKiBAcmV0dXJucyB7ICogfSB2YWx1ZSB0aGF0IHdlIHdpbGwgdXNlIHRvIGZpZ3VyZSBvdXQgdGhlIGl0ZW0gcG9zaXRpb24gdmlhIGNvbGxlY3Rpb24uaW5kZXhPZlxuICAgKi9cbiAgZnVuY3Rpb24gZ2V0SXRlbUlkKGtleUF0dHIsIG9yaWdpbmFsSXRlbSwga2V5ZWRJdGVtLCBoYXNLZXlBdHRyRXhwcikge1xuICAgIGlmIChrZXlBdHRyKSB7XG4gICAgICByZXR1cm4gaGFzS2V5QXR0ckV4cHIgPyAgdG1wbChrZXlBdHRyLCBrZXllZEl0ZW0pIDogIG9yaWdpbmFsSXRlbVtrZXlBdHRyXVxuICAgIH1cblxuICAgIHJldHVybiBvcmlnaW5hbEl0ZW1cbiAgfVxuXG4gIC8qKlxuICAgKiBNYW5hZ2UgdGFncyBoYXZpbmcgdGhlICdlYWNoJ1xuICAgKiBAcGFyYW0gICB7IEhUTUxFbGVtZW50IH0gZG9tIC0gRE9NIG5vZGUgd2UgbmVlZCB0byBsb29wXG4gICAqIEBwYXJhbSAgIHsgVGFnIH0gcGFyZW50IC0gcGFyZW50IHRhZyBpbnN0YW5jZSB3aGVyZSB0aGUgZG9tIG5vZGUgaXMgY29udGFpbmVkXG4gICAqIEBwYXJhbSAgIHsgU3RyaW5nIH0gZXhwciAtIHN0cmluZyBjb250YWluZWQgaW4gdGhlICdlYWNoJyBhdHRyaWJ1dGVcbiAgICogQHJldHVybnMgeyBPYmplY3QgfSBleHByZXNzaW9uIG9iamVjdCBmb3IgdGhpcyBlYWNoIGxvb3BcbiAgICovXG4gIGZ1bmN0aW9uIF9lYWNoKGRvbSwgcGFyZW50LCBleHByKSB7XG4gICAgdmFyIG11c3RSZW9yZGVyID0gdHlwZW9mIGdldEF0dHJpYnV0ZShkb20sIExPT1BfTk9fUkVPUkRFUl9ESVJFQ1RJVkUpICE9PSBUX1NUUklORyB8fCByZW1vdmVBdHRyaWJ1dGUoZG9tLCBMT09QX05PX1JFT1JERVJfRElSRUNUSVZFKTtcbiAgICB2YXIga2V5QXR0ciA9IGdldEF0dHJpYnV0ZShkb20sIEtFWV9ESVJFQ1RJVkUpO1xuICAgIHZhciBoYXNLZXlBdHRyRXhwciA9IGtleUF0dHIgPyB0bXBsLmhhc0V4cHIoa2V5QXR0cikgOiBmYWxzZTtcbiAgICB2YXIgdGFnTmFtZSA9IGdldE5hbWUoZG9tKTtcbiAgICB2YXIgaW1wbCA9IF9fVEFHX0lNUExbdGFnTmFtZV07XG4gICAgdmFyIHBhcmVudE5vZGUgPSBkb20ucGFyZW50Tm9kZTtcbiAgICB2YXIgcGxhY2Vob2xkZXIgPSBjcmVhdGVET01QbGFjZWhvbGRlcigpO1xuICAgIHZhciBjaGlsZCA9IGdldChkb20pO1xuICAgIHZhciBpZkV4cHIgPSBnZXRBdHRyaWJ1dGUoZG9tLCBDT05ESVRJT05BTF9ESVJFQ1RJVkUpO1xuICAgIHZhciB0YWdzID0gW107XG4gICAgdmFyIGlzTG9vcCA9IHRydWU7XG4gICAgdmFyIGlubmVySFRNTCA9IGRvbS5pbm5lckhUTUw7XG4gICAgdmFyIGlzQW5vbnltb3VzID0gIV9fVEFHX0lNUExbdGFnTmFtZV07XG4gICAgdmFyIGlzVmlydHVhbCA9IGRvbS50YWdOYW1lID09PSAnVklSVFVBTCc7XG4gICAgdmFyIG9sZEl0ZW1zID0gW107XG5cbiAgICAvLyByZW1vdmUgdGhlIGVhY2ggcHJvcGVydHkgZnJvbSB0aGUgb3JpZ2luYWwgdGFnXG4gICAgcmVtb3ZlQXR0cmlidXRlKGRvbSwgTE9PUF9ESVJFQ1RJVkUpO1xuICAgIHJlbW92ZUF0dHJpYnV0ZShkb20sIEtFWV9ESVJFQ1RJVkUpO1xuXG4gICAgLy8gcGFyc2UgdGhlIGVhY2ggZXhwcmVzc2lvblxuICAgIGV4cHIgPSB0bXBsLmxvb3BLZXlzKGV4cHIpO1xuICAgIGV4cHIuaXNMb29wID0gdHJ1ZTtcblxuICAgIGlmIChpZkV4cHIpIHsgcmVtb3ZlQXR0cmlidXRlKGRvbSwgQ09ORElUSU9OQUxfRElSRUNUSVZFKTsgfVxuXG4gICAgLy8gaW5zZXJ0IGEgbWFya2VkIHdoZXJlIHRoZSBsb29wIHRhZ3Mgd2lsbCBiZSBpbmplY3RlZFxuICAgIHBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKHBsYWNlaG9sZGVyLCBkb20pO1xuICAgIHBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoZG9tKTtcblxuICAgIGV4cHIudXBkYXRlID0gZnVuY3Rpb24gdXBkYXRlRWFjaCgpIHtcbiAgICAgIC8vIGdldCB0aGUgbmV3IGl0ZW1zIGNvbGxlY3Rpb25cbiAgICAgIGV4cHIudmFsdWUgPSB0bXBsKGV4cHIudmFsLCBwYXJlbnQpO1xuXG4gICAgICB2YXIgaXRlbXMgPSBleHByLnZhbHVlO1xuICAgICAgdmFyIGZyYWcgPSBjcmVhdGVGcmFnbWVudCgpO1xuICAgICAgdmFyIGlzT2JqZWN0ID0gIWlzQXJyYXkoaXRlbXMpICYmICFpc1N0cmluZyhpdGVtcyk7XG4gICAgICB2YXIgcm9vdCA9IHBsYWNlaG9sZGVyLnBhcmVudE5vZGU7XG4gICAgICB2YXIgdG1wSXRlbXMgPSBbXTtcbiAgICAgIHZhciBoYXNLZXlzID0gaXNPYmplY3QgJiYgISFpdGVtcztcblxuICAgICAgLy8gaWYgdGhpcyBET00gd2FzIHJlbW92ZWQgdGhlIHVwZGF0ZSBoZXJlIGlzIHVzZWxlc3NcbiAgICAgIC8vIHRoaXMgY29uZGl0aW9uIGZpeGVzIGFsc28gYSB3ZWlyZCBhc3luYyBpc3N1ZSBvbiBJRSBpbiBvdXIgdW5pdCB0ZXN0XG4gICAgICBpZiAoIXJvb3QpIHsgcmV0dXJuIH1cblxuICAgICAgLy8gb2JqZWN0IGxvb3AuIGFueSBjaGFuZ2VzIGNhdXNlIGZ1bGwgcmVkcmF3XG4gICAgICBpZiAoaXNPYmplY3QpIHtcbiAgICAgICAgaXRlbXMgPSBpdGVtcyA/IE9iamVjdC5rZXlzKGl0ZW1zKS5tYXAoZnVuY3Rpb24gKGtleSkgeyByZXR1cm4gbWtpdGVtKGV4cHIsIGl0ZW1zW2tleV0sIGtleSk7IH0pIDogW107XG4gICAgICB9XG5cbiAgICAgIC8vIHN0b3JlIHRoZSBhbW91bnQgb2YgZmlsdGVyZWQgaXRlbXNcbiAgICAgIHZhciBmaWx0ZXJlZEl0ZW1zQ291bnQgPSAwO1xuXG4gICAgICAvLyBsb29wIGFsbCB0aGUgbmV3IGl0ZW1zXG4gICAgICBlYWNoKGl0ZW1zLCBmdW5jdGlvbiAoX2l0ZW0sIGkpIHtcbiAgICAgICAgaSAtPSBmaWx0ZXJlZEl0ZW1zQ291bnQ7XG5cbiAgICAgICAgdmFyIGl0ZW0gPSAhaGFzS2V5cyAmJiBleHByLmtleSA/IG1raXRlbShleHByLCBfaXRlbSwgaSkgOiBfaXRlbTtcblxuICAgICAgICAvLyBza2lwIHRoaXMgaXRlbSBiZWNhdXNlIGl0IG11c3QgYmUgZmlsdGVyZWRcbiAgICAgICAgaWYgKGlmRXhwciAmJiAhdG1wbChpZkV4cHIsIGV4dGVuZChjcmVhdGUocGFyZW50KSwgaXRlbSkpKSB7XG4gICAgICAgICAgZmlsdGVyZWRJdGVtc0NvdW50ICsrO1xuICAgICAgICAgIHJldHVyblxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGl0ZW1JZCA9IGdldEl0ZW1JZChrZXlBdHRyLCBfaXRlbSwgaXRlbSwgaGFzS2V5QXR0ckV4cHIpO1xuICAgICAgICAvLyByZW9yZGVyIG9ubHkgaWYgdGhlIGl0ZW1zIGFyZSBub3Qgb2JqZWN0c1xuICAgICAgICAvLyBvciBhIGtleSBhdHRyaWJ1dGUgaGFzIGJlZW4gcHJvdmlkZWRcbiAgICAgICAgdmFyIGRvUmVvcmRlciA9ICFpc09iamVjdCAmJiBtdXN0UmVvcmRlciAmJiB0eXBlb2YgX2l0ZW0gPT09IFRfT0JKRUNUIHx8IGtleUF0dHI7XG4gICAgICAgIHZhciBvbGRQb3MgPSBvbGRJdGVtcy5pbmRleE9mKGl0ZW1JZCk7XG4gICAgICAgIHZhciBpc05ldyA9IG9sZFBvcyA9PT0gLTE7XG4gICAgICAgIHZhciBwb3MgPSAhaXNOZXcgJiYgZG9SZW9yZGVyID8gb2xkUG9zIDogaTtcbiAgICAgICAgLy8gZG9lcyBhIHRhZyBleGlzdCBpbiB0aGlzIHBvc2l0aW9uP1xuICAgICAgICB2YXIgdGFnID0gdGFnc1twb3NdO1xuICAgICAgICB2YXIgbXVzdEFwcGVuZCA9IGkgPj0gb2xkSXRlbXMubGVuZ3RoO1xuICAgICAgICB2YXIgbXVzdENyZWF0ZSA9IGRvUmVvcmRlciAmJiBpc05ldyB8fCAhZG9SZW9yZGVyICYmICF0YWcgfHwgIXRhZ3NbaV07XG5cbiAgICAgICAgLy8gbmV3IHRhZ1xuICAgICAgICBpZiAobXVzdENyZWF0ZSkge1xuICAgICAgICAgIHRhZyA9IGNyZWF0ZVRhZyhpbXBsLCB7XG4gICAgICAgICAgICBwYXJlbnQ6IHBhcmVudCxcbiAgICAgICAgICAgIGlzTG9vcDogaXNMb29wLFxuICAgICAgICAgICAgaXNBbm9ueW1vdXM6IGlzQW5vbnltb3VzLFxuICAgICAgICAgICAgdGFnTmFtZTogdGFnTmFtZSxcbiAgICAgICAgICAgIHJvb3Q6IGRvbS5jbG9uZU5vZGUoaXNBbm9ueW1vdXMpLFxuICAgICAgICAgICAgaXRlbTogaXRlbSxcbiAgICAgICAgICAgIGluZGV4OiBpLFxuICAgICAgICAgIH0sIGlubmVySFRNTCk7XG5cbiAgICAgICAgICAvLyBtb3VudCB0aGUgdGFnXG4gICAgICAgICAgdGFnLm1vdW50KCk7XG5cbiAgICAgICAgICBpZiAobXVzdEFwcGVuZClcbiAgICAgICAgICAgIHsgYXBwZW5kLmFwcGx5KHRhZywgW2ZyYWcgfHwgcm9vdCwgaXNWaXJ0dWFsXSk7IH1cbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICB7IGluc2VydC5hcHBseSh0YWcsIFtyb290LCB0YWdzW2ldLCBpc1ZpcnR1YWxdKTsgfVxuXG4gICAgICAgICAgaWYgKCFtdXN0QXBwZW5kKSB7IG9sZEl0ZW1zLnNwbGljZShpLCAwLCBpdGVtKTsgfVxuICAgICAgICAgIHRhZ3Muc3BsaWNlKGksIDAsIHRhZyk7XG4gICAgICAgICAgaWYgKGNoaWxkKSB7IGFycmF5aXNoQWRkKHBhcmVudC50YWdzLCB0YWdOYW1lLCB0YWcsIHRydWUpOyB9XG4gICAgICAgIH0gZWxzZSBpZiAocG9zICE9PSBpICYmIGRvUmVvcmRlcikge1xuICAgICAgICAgIC8vIG1vdmVcbiAgICAgICAgICBpZiAoa2V5QXR0ciB8fCBjb250YWlucyhpdGVtcywgb2xkSXRlbXNbcG9zXSkpIHtcbiAgICAgICAgICAgIG1vdmUuYXBwbHkodGFnLCBbcm9vdCwgdGFnc1tpXSwgaXNWaXJ0dWFsXSk7XG4gICAgICAgICAgICAvLyBtb3ZlIHRoZSBvbGQgdGFnIGluc3RhbmNlXG4gICAgICAgICAgICB0YWdzLnNwbGljZShpLCAwLCB0YWdzLnNwbGljZShwb3MsIDEpWzBdKTtcbiAgICAgICAgICAgIC8vIG1vdmUgdGhlIG9sZCBpdGVtXG4gICAgICAgICAgICBvbGRJdGVtcy5zcGxpY2UoaSwgMCwgb2xkSXRlbXMuc3BsaWNlKHBvcywgMSlbMF0pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIHVwZGF0ZSB0aGUgcG9zaXRpb24gYXR0cmlidXRlIGlmIGl0IGV4aXN0c1xuICAgICAgICAgIGlmIChleHByLnBvcykgeyB0YWdbZXhwci5wb3NdID0gaTsgfVxuXG4gICAgICAgICAgLy8gaWYgdGhlIGxvb3AgdGFncyBhcmUgbm90IGN1c3RvbVxuICAgICAgICAgIC8vIHdlIG5lZWQgdG8gbW92ZSBhbGwgdGhlaXIgY3VzdG9tIHRhZ3MgaW50byB0aGUgcmlnaHQgcG9zaXRpb25cbiAgICAgICAgICBpZiAoIWNoaWxkICYmIHRhZy50YWdzKSB7IG1vdmVOZXN0ZWRUYWdzLmNhbGwodGFnLCBpKTsgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gY2FjaGUgdGhlIG9yaWdpbmFsIGl0ZW0gdG8gdXNlIGl0IGluIHRoZSBldmVudHMgYm91bmQgdG8gdGhpcyBub2RlXG4gICAgICAgIC8vIGFuZCBpdHMgY2hpbGRyZW5cbiAgICAgICAgZXh0ZW5kKHRhZy5fXywge1xuICAgICAgICAgIGl0ZW06IGl0ZW0sXG4gICAgICAgICAgaW5kZXg6IGksXG4gICAgICAgICAgcGFyZW50OiBwYXJlbnRcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdG1wSXRlbXNbaV0gPSBpdGVtSWQ7XG5cbiAgICAgICAgaWYgKCFtdXN0Q3JlYXRlKSB7IHRhZy51cGRhdGUoaXRlbSk7IH1cbiAgICAgIH0pO1xuXG4gICAgICAvLyByZW1vdmUgdGhlIHJlZHVuZGFudCB0YWdzXG4gICAgICB1bm1vdW50UmVkdW5kYW50KGl0ZW1zLCB0YWdzLCBmaWx0ZXJlZEl0ZW1zQ291bnQpO1xuXG4gICAgICAvLyBjbG9uZSB0aGUgaXRlbXMgYXJyYXlcbiAgICAgIG9sZEl0ZW1zID0gdG1wSXRlbXMuc2xpY2UoKTtcblxuICAgICAgcm9vdC5pbnNlcnRCZWZvcmUoZnJhZywgcGxhY2Vob2xkZXIpO1xuICAgIH07XG5cbiAgICBleHByLnVubW91bnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBlYWNoKHRhZ3MsIGZ1bmN0aW9uICh0KSB7IHQudW5tb3VudCgpOyB9KTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIGV4cHJcbiAgfVxuXG4gIHZhciBSZWZFeHByID0ge1xuICAgIGluaXQ6IGZ1bmN0aW9uIGluaXQoZG9tLCBwYXJlbnQsIGF0dHJOYW1lLCBhdHRyVmFsdWUpIHtcbiAgICAgIHRoaXMuZG9tID0gZG9tO1xuICAgICAgdGhpcy5hdHRyID0gYXR0ck5hbWU7XG4gICAgICB0aGlzLnJhd1ZhbHVlID0gYXR0clZhbHVlO1xuICAgICAgdGhpcy5wYXJlbnQgPSBwYXJlbnQ7XG4gICAgICB0aGlzLmhhc0V4cCA9IHRtcGwuaGFzRXhwcihhdHRyVmFsdWUpO1xuICAgICAgcmV0dXJuIHRoaXNcbiAgICB9LFxuICAgIHVwZGF0ZTogZnVuY3Rpb24gdXBkYXRlKCkge1xuICAgICAgdmFyIG9sZCA9IHRoaXMudmFsdWU7XG4gICAgICB2YXIgY3VzdG9tUGFyZW50ID0gdGhpcy5wYXJlbnQgJiYgZ2V0SW1tZWRpYXRlQ3VzdG9tUGFyZW50KHRoaXMucGFyZW50KTtcbiAgICAgIC8vIGlmIHRoZSByZWZlcmVuY2VkIGVsZW1lbnQgaXMgYSBjdXN0b20gdGFnLCB0aGVuIHdlIHNldCB0aGUgdGFnIGl0c2VsZiwgcmF0aGVyIHRoYW4gRE9NXG4gICAgICB2YXIgdGFnT3JEb20gPSB0aGlzLmRvbS5fX3JlZiB8fCB0aGlzLnRhZyB8fCB0aGlzLmRvbTtcblxuICAgICAgdGhpcy52YWx1ZSA9IHRoaXMuaGFzRXhwID8gdG1wbCh0aGlzLnJhd1ZhbHVlLCB0aGlzLnBhcmVudCkgOiB0aGlzLnJhd1ZhbHVlO1xuXG4gICAgICAvLyB0aGUgbmFtZSBjaGFuZ2VkLCBzbyB3ZSBuZWVkIHRvIHJlbW92ZSBpdCBmcm9tIHRoZSBvbGQga2V5IChpZiBwcmVzZW50KVxuICAgICAgaWYgKCFpc0JsYW5rKG9sZCkgJiYgY3VzdG9tUGFyZW50KSB7IGFycmF5aXNoUmVtb3ZlKGN1c3RvbVBhcmVudC5yZWZzLCBvbGQsIHRhZ09yRG9tKTsgfVxuICAgICAgaWYgKCFpc0JsYW5rKHRoaXMudmFsdWUpICYmIGlzU3RyaW5nKHRoaXMudmFsdWUpKSB7XG4gICAgICAgIC8vIGFkZCBpdCB0byB0aGUgcmVmcyBvZiBwYXJlbnQgdGFnICh0aGlzIGJlaGF2aW9yIHdhcyBjaGFuZ2VkID49My4wKVxuICAgICAgICBpZiAoY3VzdG9tUGFyZW50KSB7IGFycmF5aXNoQWRkKFxuICAgICAgICAgIGN1c3RvbVBhcmVudC5yZWZzLFxuICAgICAgICAgIHRoaXMudmFsdWUsXG4gICAgICAgICAgdGFnT3JEb20sXG4gICAgICAgICAgLy8gdXNlIGFuIGFycmF5IGlmIGl0J3MgYSBsb29wZWQgbm9kZSBhbmQgdGhlIHJlZiBpcyBub3QgYW4gZXhwcmVzc2lvblxuICAgICAgICAgIG51bGwsXG4gICAgICAgICAgdGhpcy5wYXJlbnQuX18uaW5kZXhcbiAgICAgICAgKTsgfVxuXG4gICAgICAgIGlmICh0aGlzLnZhbHVlICE9PSBvbGQpIHtcbiAgICAgICAgICBzZXRBdHRyaWJ1dGUodGhpcy5kb20sIHRoaXMuYXR0ciwgdGhpcy52YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlbW92ZUF0dHJpYnV0ZSh0aGlzLmRvbSwgdGhpcy5hdHRyKTtcbiAgICAgIH1cblxuICAgICAgLy8gY2FjaGUgdGhlIHJlZiBib3VuZCB0byB0aGlzIGRvbSBub2RlXG4gICAgICAvLyB0byByZXVzZSBpdCBpbiBmdXR1cmUgKHNlZSBhbHNvICMyMzI5KVxuICAgICAgaWYgKCF0aGlzLmRvbS5fX3JlZikgeyB0aGlzLmRvbS5fX3JlZiA9IHRhZ09yRG9tOyB9XG4gICAgfSxcbiAgICB1bm1vdW50OiBmdW5jdGlvbiB1bm1vdW50KCkge1xuICAgICAgdmFyIHRhZ09yRG9tID0gdGhpcy50YWcgfHwgdGhpcy5kb207XG4gICAgICB2YXIgY3VzdG9tUGFyZW50ID0gdGhpcy5wYXJlbnQgJiYgZ2V0SW1tZWRpYXRlQ3VzdG9tUGFyZW50KHRoaXMucGFyZW50KTtcbiAgICAgIGlmICghaXNCbGFuayh0aGlzLnZhbHVlKSAmJiBjdXN0b21QYXJlbnQpXG4gICAgICAgIHsgYXJyYXlpc2hSZW1vdmUoY3VzdG9tUGFyZW50LnJlZnMsIHRoaXMudmFsdWUsIHRhZ09yRG9tKTsgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSBuZXcgcmVmIGRpcmVjdGl2ZVxuICAgKiBAcGFyYW0gICB7IEhUTUxFbGVtZW50IH0gZG9tIC0gZG9tIG5vZGUgaGF2aW5nIHRoZSByZWYgYXR0cmlidXRlXG4gICAqIEBwYXJhbSAgIHsgVGFnIH0gY29udGV4dCAtIHRhZyBpbnN0YW5jZSB3aGVyZSB0aGUgRE9NIG5vZGUgaXMgbG9jYXRlZFxuICAgKiBAcGFyYW0gICB7IFN0cmluZyB9IGF0dHJOYW1lIC0gZWl0aGVyICdyZWYnIG9yICdkYXRhLXJlZidcbiAgICogQHBhcmFtICAgeyBTdHJpbmcgfSBhdHRyVmFsdWUgLSB2YWx1ZSBvZiB0aGUgcmVmIGF0dHJpYnV0ZVxuICAgKiBAcmV0dXJucyB7IFJlZkV4cHIgfSBhIG5ldyBSZWZFeHByIG9iamVjdFxuICAgKi9cbiAgZnVuY3Rpb24gY3JlYXRlUmVmRGlyZWN0aXZlKGRvbSwgdGFnLCBhdHRyTmFtZSwgYXR0clZhbHVlKSB7XG4gICAgcmV0dXJuIGNyZWF0ZShSZWZFeHByKS5pbml0KGRvbSwgdGFnLCBhdHRyTmFtZSwgYXR0clZhbHVlKVxuICB9XG5cbiAgLyoqXG4gICAqIFRyaWdnZXIgdGhlIHVubW91bnQgbWV0aG9kIG9uIGFsbCB0aGUgZXhwcmVzc2lvbnNcbiAgICogQHBhcmFtICAgeyBBcnJheSB9IGV4cHJlc3Npb25zIC0gRE9NIGV4cHJlc3Npb25zXG4gICAqL1xuICBmdW5jdGlvbiB1bm1vdW50QWxsKGV4cHJlc3Npb25zKSB7XG4gICAgZWFjaChleHByZXNzaW9ucywgZnVuY3Rpb24gKGV4cHIpIHtcbiAgICAgIGlmIChleHByLnVubW91bnQpIHsgZXhwci51bm1vdW50KHRydWUpOyB9XG4gICAgICBlbHNlIGlmIChleHByLnRhZ05hbWUpIHsgZXhwci50YWcudW5tb3VudCh0cnVlKTsgfVxuICAgICAgZWxzZSBpZiAoZXhwci51bm1vdW50KSB7IGV4cHIudW5tb3VudCgpOyB9XG4gICAgfSk7XG4gIH1cblxuICB2YXIgSWZFeHByID0ge1xuICAgIGluaXQ6IGZ1bmN0aW9uIGluaXQoZG9tLCB0YWcsIGV4cHIpIHtcbiAgICAgIHJlbW92ZUF0dHJpYnV0ZShkb20sIENPTkRJVElPTkFMX0RJUkVDVElWRSk7XG4gICAgICBleHRlbmQodGhpcywgeyB0YWc6IHRhZywgZXhwcjogZXhwciwgc3R1YjogY3JlYXRlRE9NUGxhY2Vob2xkZXIoKSwgcHJpc3RpbmU6IGRvbSB9KTtcbiAgICAgIHZhciBwID0gZG9tLnBhcmVudE5vZGU7XG4gICAgICBwLmluc2VydEJlZm9yZSh0aGlzLnN0dWIsIGRvbSk7XG4gICAgICBwLnJlbW92ZUNoaWxkKGRvbSk7XG5cbiAgICAgIHJldHVybiB0aGlzXG4gICAgfSxcbiAgICB1cGRhdGU6IGZ1bmN0aW9uIHVwZGF0ZSQkMSgpIHtcbiAgICAgIHRoaXMudmFsdWUgPSB0bXBsKHRoaXMuZXhwciwgdGhpcy50YWcpO1xuXG4gICAgICBpZiAodGhpcy52YWx1ZSAmJiAhdGhpcy5jdXJyZW50KSB7IC8vIGluc2VydFxuICAgICAgICB0aGlzLmN1cnJlbnQgPSB0aGlzLnByaXN0aW5lLmNsb25lTm9kZSh0cnVlKTtcbiAgICAgICAgdGhpcy5zdHViLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKHRoaXMuY3VycmVudCwgdGhpcy5zdHViKTtcbiAgICAgICAgdGhpcy5leHByZXNzaW9ucyA9IHBhcnNlRXhwcmVzc2lvbnMuYXBwbHkodGhpcy50YWcsIFt0aGlzLmN1cnJlbnQsIHRydWVdKTtcbiAgICAgIH0gZWxzZSBpZiAoIXRoaXMudmFsdWUgJiYgdGhpcy5jdXJyZW50KSB7IC8vIHJlbW92ZVxuICAgICAgICB0aGlzLnVubW91bnQoKTtcbiAgICAgICAgdGhpcy5jdXJyZW50ID0gbnVsbDtcbiAgICAgICAgdGhpcy5leHByZXNzaW9ucyA9IFtdO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy52YWx1ZSkgeyB1cGRhdGUuY2FsbCh0aGlzLnRhZywgdGhpcy5leHByZXNzaW9ucyk7IH1cbiAgICB9LFxuICAgIHVubW91bnQ6IGZ1bmN0aW9uIHVubW91bnQoKSB7XG4gICAgICBpZiAodGhpcy5jdXJyZW50KSB7XG4gICAgICAgIGlmICh0aGlzLmN1cnJlbnQuX3RhZykge1xuICAgICAgICAgIHRoaXMuY3VycmVudC5fdGFnLnVubW91bnQoKTtcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLmN1cnJlbnQucGFyZW50Tm9kZSkge1xuICAgICAgICAgIHRoaXMuY3VycmVudC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRoaXMuY3VycmVudCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdW5tb3VudEFsbCh0aGlzLmV4cHJlc3Npb25zIHx8IFtdKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIGEgbmV3IGlmIGRpcmVjdGl2ZVxuICAgKiBAcGFyYW0gICB7IEhUTUxFbGVtZW50IH0gZG9tIC0gaWYgcm9vdCBkb20gbm9kZVxuICAgKiBAcGFyYW0gICB7IFRhZyB9IGNvbnRleHQgLSB0YWcgaW5zdGFuY2Ugd2hlcmUgdGhlIERPTSBub2RlIGlzIGxvY2F0ZWRcbiAgICogQHBhcmFtICAgeyBTdHJpbmcgfSBhdHRyIC0gaWYgZXhwcmVzc2lvblxuICAgKiBAcmV0dXJucyB7IElGRXhwciB9IGEgbmV3IElmRXhwciBvYmplY3RcbiAgICovXG4gIGZ1bmN0aW9uIGNyZWF0ZUlmRGlyZWN0aXZlKGRvbSwgdGFnLCBhdHRyKSB7XG4gICAgcmV0dXJuIGNyZWF0ZShJZkV4cHIpLmluaXQoZG9tLCB0YWcsIGF0dHIpXG4gIH1cblxuICAvKipcbiAgICogV2FsayB0aGUgdGFnIERPTSB0byBkZXRlY3QgdGhlIGV4cHJlc3Npb25zIHRvIGV2YWx1YXRlXG4gICAqIEB0aGlzIFRhZ1xuICAgKiBAcGFyYW0gICB7IEhUTUxFbGVtZW50IH0gcm9vdCAtIHJvb3QgdGFnIHdoZXJlIHdlIHdpbGwgc3RhcnQgZGlnZ2luZyB0aGUgZXhwcmVzc2lvbnNcbiAgICogQHBhcmFtICAgeyBCb29sZWFuIH0gbXVzdEluY2x1ZGVSb290IC0gZmxhZyB0byBkZWNpZGUgd2hldGhlciB0aGUgcm9vdCBtdXN0IGJlIHBhcnNlZCBhcyB3ZWxsXG4gICAqIEByZXR1cm5zIHsgQXJyYXkgfSBhbGwgdGhlIGV4cHJlc3Npb25zIGZvdW5kXG4gICAqL1xuICBmdW5jdGlvbiBwYXJzZUV4cHJlc3Npb25zKHJvb3QsIG11c3RJbmNsdWRlUm9vdCkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgdmFyIGV4cHJlc3Npb25zID0gW107XG5cbiAgICB3YWxrTm9kZXMocm9vdCwgZnVuY3Rpb24gKGRvbSkge1xuICAgICAgdmFyIHR5cGUgPSBkb20ubm9kZVR5cGU7XG4gICAgICB2YXIgYXR0cjtcbiAgICAgIHZhciB0YWdJbXBsO1xuXG4gICAgICBpZiAoIW11c3RJbmNsdWRlUm9vdCAmJiBkb20gPT09IHJvb3QpIHsgcmV0dXJuIH1cblxuICAgICAgLy8gdGV4dCBub2RlXG4gICAgICBpZiAodHlwZSA9PT0gMyAmJiBkb20ucGFyZW50Tm9kZS50YWdOYW1lICE9PSAnU1RZTEUnICYmIHRtcGwuaGFzRXhwcihkb20ubm9kZVZhbHVlKSlcbiAgICAgICAgeyBleHByZXNzaW9ucy5wdXNoKHtkb206IGRvbSwgZXhwcjogZG9tLm5vZGVWYWx1ZX0pOyB9XG5cbiAgICAgIGlmICh0eXBlICE9PSAxKSB7IHJldHVybiB9XG5cbiAgICAgIHZhciBpc1ZpcnR1YWwgPSBkb20udGFnTmFtZSA9PT0gJ1ZJUlRVQUwnO1xuXG4gICAgICAvLyBsb29wLiBlYWNoIGRvZXMgaXQncyBvd24gdGhpbmcgKGZvciBub3cpXG4gICAgICBpZiAoYXR0ciA9IGdldEF0dHJpYnV0ZShkb20sIExPT1BfRElSRUNUSVZFKSkge1xuICAgICAgICBpZihpc1ZpcnR1YWwpIHsgc2V0QXR0cmlidXRlKGRvbSwgJ2xvb3BWaXJ0dWFsJywgdHJ1ZSk7IH0gLy8gaWdub3JlIGhlcmUsIGhhbmRsZWQgaW4gX2VhY2hcbiAgICAgICAgZXhwcmVzc2lvbnMucHVzaChfZWFjaChkb20sIHRoaXMkMSwgYXR0cikpO1xuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgIH1cblxuICAgICAgLy8gaWYtYXR0cnMgYmVjb21lIHRoZSBuZXcgcGFyZW50LiBBbnkgZm9sbG93aW5nIGV4cHJlc3Npb25zIChlaXRoZXIgb24gdGhlIGN1cnJlbnRcbiAgICAgIC8vIGVsZW1lbnQsIG9yIGJlbG93IGl0KSBiZWNvbWUgY2hpbGRyZW4gb2YgdGhpcyBleHByZXNzaW9uLlxuICAgICAgaWYgKGF0dHIgPSBnZXRBdHRyaWJ1dGUoZG9tLCBDT05ESVRJT05BTF9ESVJFQ1RJVkUpKSB7XG4gICAgICAgIGV4cHJlc3Npb25zLnB1c2goY3JlYXRlSWZEaXJlY3RpdmUoZG9tLCB0aGlzJDEsIGF0dHIpKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICB9XG5cbiAgICAgIGlmIChhdHRyID0gZ2V0QXR0cmlidXRlKGRvbSwgSVNfRElSRUNUSVZFKSkge1xuICAgICAgICBpZiAodG1wbC5oYXNFeHByKGF0dHIpKSB7XG4gICAgICAgICAgZXhwcmVzc2lvbnMucHVzaCh7XG4gICAgICAgICAgICBpc1J0YWc6IHRydWUsXG4gICAgICAgICAgICBleHByOiBhdHRyLFxuICAgICAgICAgICAgZG9tOiBkb20sXG4gICAgICAgICAgICBhdHRyczogW10uc2xpY2UuY2FsbChkb20uYXR0cmlidXRlcylcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIGlmIHRoaXMgaXMgYSB0YWcsIHN0b3AgdHJhdmVyc2luZyBoZXJlLlxuICAgICAgLy8gd2UgaWdub3JlIHRoZSByb290LCBzaW5jZSBwYXJzZUV4cHJlc3Npb25zIGlzIGNhbGxlZCB3aGlsZSB3ZSdyZSBtb3VudGluZyB0aGF0IHJvb3RcbiAgICAgIHRhZ0ltcGwgPSBnZXQoZG9tKTtcblxuICAgICAgaWYoaXNWaXJ0dWFsKSB7XG4gICAgICAgIGlmKGdldEF0dHJpYnV0ZShkb20sICd2aXJ0dWFsaXplZCcpKSB7ZG9tLnBhcmVudEVsZW1lbnQucmVtb3ZlQ2hpbGQoZG9tKTsgfSAvLyB0YWcgY3JlYXRlZCwgcmVtb3ZlIGZyb20gZG9tXG4gICAgICAgIGlmKCF0YWdJbXBsICYmICFnZXRBdHRyaWJ1dGUoZG9tLCAndmlydHVhbGl6ZWQnKSAmJiAhZ2V0QXR0cmlidXRlKGRvbSwgJ2xvb3BWaXJ0dWFsJykpICAvLyBvayB0byBjcmVhdGUgdmlydHVhbCB0YWdcbiAgICAgICAgICB7IHRhZ0ltcGwgPSB7IHRtcGw6IGRvbS5vdXRlckhUTUwgfTsgfVxuICAgICAgfVxuXG4gICAgICBpZiAodGFnSW1wbCAmJiAoZG9tICE9PSByb290IHx8IG11c3RJbmNsdWRlUm9vdCkpIHtcbiAgICAgICAgdmFyIGhhc0lzRGlyZWN0aXZlID0gZ2V0QXR0cmlidXRlKGRvbSwgSVNfRElSRUNUSVZFKTtcbiAgICAgICAgaWYoaXNWaXJ0dWFsICYmICFoYXNJc0RpcmVjdGl2ZSkgeyAvLyBoYW5kbGVkIGluIHVwZGF0ZVxuICAgICAgICAgIC8vIGNhbiBub3QgcmVtb3ZlIGF0dHJpYnV0ZSBsaWtlIGRpcmVjdGl2ZXNcbiAgICAgICAgICAvLyBzbyBmbGFnIGZvciByZW1vdmFsIGFmdGVyIGNyZWF0aW9uIHRvIHByZXZlbnQgbWF4aW11bSBzdGFjayBlcnJvclxuICAgICAgICAgIHNldEF0dHJpYnV0ZShkb20sICd2aXJ0dWFsaXplZCcsIHRydWUpO1xuICAgICAgICAgIHZhciB0YWcgPSBjcmVhdGVUYWcoXG4gICAgICAgICAgICB7dG1wbDogZG9tLm91dGVySFRNTH0sXG4gICAgICAgICAgICB7cm9vdDogZG9tLCBwYXJlbnQ6IHRoaXMkMX0sXG4gICAgICAgICAgICBkb20uaW5uZXJIVE1MXG4gICAgICAgICAgKTtcblxuICAgICAgICAgIGV4cHJlc3Npb25zLnB1c2godGFnKTsgLy8gbm8gcmV0dXJuLCBhbm9ueW1vdXMgdGFnLCBrZWVwIHBhcnNpbmdcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAoaGFzSXNEaXJlY3RpdmUgJiYgaXNWaXJ0dWFsKVxuICAgICAgICAgICAgeyB3YXJuKChcIlZpcnR1YWwgdGFncyBzaG91bGRuJ3QgYmUgdXNlZCB0b2dldGhlciB3aXRoIHRoZSBcXFwiXCIgKyBJU19ESVJFQ1RJVkUgKyBcIlxcXCIgYXR0cmlidXRlIC0gaHR0cHM6Ly9naXRodWIuY29tL3Jpb3QvcmlvdC9pc3N1ZXMvMjUxMVwiKSk7IH1cblxuICAgICAgICAgIGV4cHJlc3Npb25zLnB1c2goXG4gICAgICAgICAgICBpbml0Q2hpbGQoXG4gICAgICAgICAgICAgIHRhZ0ltcGwsXG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICByb290OiBkb20sXG4gICAgICAgICAgICAgICAgcGFyZW50OiB0aGlzJDFcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgZG9tLmlubmVySFRNTCxcbiAgICAgICAgICAgICAgdGhpcyQxXG4gICAgICAgICAgICApXG4gICAgICAgICAgKTtcbiAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBhdHRyaWJ1dGUgZXhwcmVzc2lvbnNcbiAgICAgIHBhcnNlQXR0cmlidXRlcy5hcHBseSh0aGlzJDEsIFtkb20sIGRvbS5hdHRyaWJ1dGVzLCBmdW5jdGlvbiAoYXR0ciwgZXhwcikge1xuICAgICAgICBpZiAoIWV4cHIpIHsgcmV0dXJuIH1cbiAgICAgICAgZXhwcmVzc2lvbnMucHVzaChleHByKTtcbiAgICAgIH1dKTtcbiAgICB9KTtcblxuICAgIHJldHVybiBleHByZXNzaW9uc1xuICB9XG5cbiAgLyoqXG4gICAqIENhbGxzIGBmbmAgZm9yIGV2ZXJ5IGF0dHJpYnV0ZSBvbiBhbiBlbGVtZW50LiBJZiB0aGF0IGF0dHIgaGFzIGFuIGV4cHJlc3Npb24sXG4gICAqIGl0IGlzIGFsc28gcGFzc2VkIHRvIGZuLlxuICAgKiBAdGhpcyBUYWdcbiAgICogQHBhcmFtICAgeyBIVE1MRWxlbWVudCB9IGRvbSAtIGRvbSBub2RlIHRvIHBhcnNlXG4gICAqIEBwYXJhbSAgIHsgQXJyYXkgfSBhdHRycyAtIGFycmF5IG9mIGF0dHJpYnV0ZXNcbiAgICogQHBhcmFtICAgeyBGdW5jdGlvbiB9IGZuIC0gY2FsbGJhY2sgdG8gZXhlYyBvbiBhbnkgaXRlcmF0aW9uXG4gICAqL1xuICBmdW5jdGlvbiBwYXJzZUF0dHJpYnV0ZXMoZG9tLCBhdHRycywgZm4pIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgIGVhY2goYXR0cnMsIGZ1bmN0aW9uIChhdHRyKSB7XG4gICAgICBpZiAoIWF0dHIpIHsgcmV0dXJuIGZhbHNlIH1cblxuICAgICAgdmFyIG5hbWUgPSBhdHRyLm5hbWU7XG4gICAgICB2YXIgYm9vbCA9IGlzQm9vbEF0dHIobmFtZSk7XG4gICAgICB2YXIgZXhwcjtcblxuICAgICAgaWYgKGNvbnRhaW5zKFJFRl9ESVJFQ1RJVkVTLCBuYW1lKSAmJiBkb20udGFnTmFtZS50b0xvd2VyQ2FzZSgpICE9PSBZSUVMRF9UQUcpIHtcbiAgICAgICAgZXhwciA9ICBjcmVhdGVSZWZEaXJlY3RpdmUoZG9tLCB0aGlzJDEsIG5hbWUsIGF0dHIudmFsdWUpO1xuICAgICAgfSBlbHNlIGlmICh0bXBsLmhhc0V4cHIoYXR0ci52YWx1ZSkpIHtcbiAgICAgICAgZXhwciA9IHtkb206IGRvbSwgZXhwcjogYXR0ci52YWx1ZSwgYXR0cjogbmFtZSwgYm9vbDogYm9vbH07XG4gICAgICB9XG5cbiAgICAgIGZuKGF0dHIsIGV4cHIpO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIE1hbmFnZSB0aGUgbW91bnQgc3RhdGUgb2YgYSB0YWcgdHJpZ2dlcmluZyBhbHNvIHRoZSBvYnNlcnZhYmxlIGV2ZW50c1xuICAgKiBAdGhpcyBUYWdcbiAgICogQHBhcmFtIHsgQm9vbGVhbiB9IHZhbHVlIC0gLi5vZiB0aGUgaXNNb3VudGVkIGZsYWdcbiAgICovXG4gIGZ1bmN0aW9uIHNldE1vdW50U3RhdGUodmFsdWUpIHtcbiAgICB2YXIgcmVmID0gdGhpcy5fXztcbiAgICB2YXIgaXNBbm9ueW1vdXMgPSByZWYuaXNBbm9ueW1vdXM7XG5cbiAgICBkZWZpbmUodGhpcywgJ2lzTW91bnRlZCcsIHZhbHVlKTtcblxuICAgIGlmICghaXNBbm9ueW1vdXMpIHtcbiAgICAgIGlmICh2YWx1ZSkgeyB0aGlzLnRyaWdnZXIoJ21vdW50Jyk7IH1cbiAgICAgIGVsc2Uge1xuICAgICAgICB0aGlzLnRyaWdnZXIoJ3VubW91bnQnKTtcbiAgICAgICAgdGhpcy5vZmYoJyonKTtcbiAgICAgICAgdGhpcy5fXy53YXNDcmVhdGVkID0gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIE1vdW50IHRoZSBjdXJyZW50IHRhZyBpbnN0YW5jZVxuICAgKiBAcmV0dXJucyB7IFRhZyB9IHRoZSBjdXJyZW50IHRhZyBpbnN0YW5jZVxuICAgKi9cbiAgZnVuY3Rpb24gY29tcG9uZW50TW91bnQodGFnJCQxLCBkb20sIGV4cHJlc3Npb25zLCBvcHRzKSB7XG4gICAgdmFyIF9fID0gdGFnJCQxLl9fO1xuICAgIHZhciByb290ID0gX18ucm9vdDtcbiAgICByb290Ll90YWcgPSB0YWckJDE7IC8vIGtlZXAgYSByZWZlcmVuY2UgdG8gdGhlIHRhZyBqdXN0IGNyZWF0ZWRcblxuICAgIC8vIFJlYWQgYWxsIHRoZSBhdHRycyBvbiB0aGlzIGluc3RhbmNlLiBUaGlzIGdpdmUgdXMgdGhlIGluZm8gd2UgbmVlZCBmb3IgdXBkYXRlT3B0c1xuICAgIHBhcnNlQXR0cmlidXRlcy5hcHBseShfXy5wYXJlbnQsIFtyb290LCByb290LmF0dHJpYnV0ZXMsIGZ1bmN0aW9uIChhdHRyLCBleHByKSB7XG4gICAgICBpZiAoIV9fLmlzQW5vbnltb3VzICYmIFJlZkV4cHIuaXNQcm90b3R5cGVPZihleHByKSkgeyBleHByLnRhZyA9IHRhZyQkMTsgfVxuICAgICAgYXR0ci5leHByID0gZXhwcjtcbiAgICAgIF9fLmluc3RBdHRycy5wdXNoKGF0dHIpO1xuICAgIH1dKTtcblxuICAgIC8vIHVwZGF0ZSB0aGUgcm9vdCBhZGRpbmcgY3VzdG9tIGF0dHJpYnV0ZXMgY29taW5nIGZyb20gdGhlIGNvbXBpbGVyXG4gICAgd2Fsa0F0dHJpYnV0ZXMoX18uaW1wbC5hdHRycywgZnVuY3Rpb24gKGssIHYpIHsgX18uaW1wbEF0dHJzLnB1c2goe25hbWU6IGssIHZhbHVlOiB2fSk7IH0pO1xuICAgIHBhcnNlQXR0cmlidXRlcy5hcHBseSh0YWckJDEsIFtyb290LCBfXy5pbXBsQXR0cnMsIGZ1bmN0aW9uIChhdHRyLCBleHByKSB7XG4gICAgICBpZiAoZXhwcikgeyBleHByZXNzaW9ucy5wdXNoKGV4cHIpOyB9XG4gICAgICBlbHNlIHsgc2V0QXR0cmlidXRlKHJvb3QsIGF0dHIubmFtZSwgYXR0ci52YWx1ZSk7IH1cbiAgICB9XSk7XG5cbiAgICAvLyBpbml0aWFsaWF0aW9uXG4gICAgdXBkYXRlT3B0cy5hcHBseSh0YWckJDEsIFtfXy5pc0xvb3AsIF9fLnBhcmVudCwgX18uaXNBbm9ueW1vdXMsIG9wdHMsIF9fLmluc3RBdHRyc10pO1xuXG4gICAgLy8gYWRkIGdsb2JhbCBtaXhpbnNcbiAgICB2YXIgZ2xvYmFsTWl4aW4gPSBtaXhpbihHTE9CQUxfTUlYSU4pO1xuXG4gICAgaWYgKGdsb2JhbE1peGluICYmICFfXy5za2lwQW5vbnltb3VzKSB7XG4gICAgICBmb3IgKHZhciBpIGluIGdsb2JhbE1peGluKSB7XG4gICAgICAgIGlmIChnbG9iYWxNaXhpbi5oYXNPd25Qcm9wZXJ0eShpKSkge1xuICAgICAgICAgIHRhZyQkMS5taXhpbihnbG9iYWxNaXhpbltpXSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoX18uaW1wbC5mbikgeyBfXy5pbXBsLmZuLmNhbGwodGFnJCQxLCBvcHRzKTsgfVxuXG4gICAgaWYgKCFfXy5za2lwQW5vbnltb3VzKSB7IHRhZyQkMS50cmlnZ2VyKCdiZWZvcmUtbW91bnQnKTsgfVxuXG4gICAgLy8gcGFyc2UgbGF5b3V0IGFmdGVyIGluaXQuIGZuIG1heSBjYWxjdWxhdGUgYXJncyBmb3IgbmVzdGVkIGN1c3RvbSB0YWdzXG4gICAgZWFjaChwYXJzZUV4cHJlc3Npb25zLmFwcGx5KHRhZyQkMSwgW2RvbSwgX18uaXNBbm9ueW1vdXNdKSwgZnVuY3Rpb24gKGUpIHsgcmV0dXJuIGV4cHJlc3Npb25zLnB1c2goZSk7IH0pO1xuXG4gICAgdGFnJCQxLnVwZGF0ZShfXy5pdGVtKTtcblxuICAgIGlmICghX18uaXNBbm9ueW1vdXMgJiYgIV9fLmlzSW5saW5lKSB7XG4gICAgICB3aGlsZSAoZG9tLmZpcnN0Q2hpbGQpIHsgcm9vdC5hcHBlbmRDaGlsZChkb20uZmlyc3RDaGlsZCk7IH1cbiAgICB9XG5cbiAgICBkZWZpbmUodGFnJCQxLCAncm9vdCcsIHJvb3QpO1xuXG4gICAgLy8gaWYgd2UgbmVlZCB0byB3YWl0IHRoYXQgdGhlIHBhcmVudCBcIm1vdW50XCIgb3IgXCJ1cGRhdGVkXCIgZXZlbnQgZ2V0cyB0cmlnZ2VyZWRcbiAgICBpZiAoIV9fLnNraXBBbm9ueW1vdXMgJiYgdGFnJCQxLnBhcmVudCkge1xuICAgICAgdmFyIHAgPSBnZXRJbW1lZGlhdGVDdXN0b21QYXJlbnQodGFnJCQxLnBhcmVudCk7XG4gICAgICBwLm9uZSghcC5pc01vdW50ZWQgPyAnbW91bnQnIDogJ3VwZGF0ZWQnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHNldE1vdW50U3RhdGUuY2FsbCh0YWckJDEsIHRydWUpO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIG90aGVyd2lzZSBpdCdzIG5vdCBhIGNoaWxkIHRhZyB3ZSBjYW4gdHJpZ2dlciBpdHMgbW91bnQgZXZlbnRcbiAgICAgIHNldE1vdW50U3RhdGUuY2FsbCh0YWckJDEsIHRydWUpO1xuICAgIH1cblxuICAgIHRhZyQkMS5fXy53YXNDcmVhdGVkID0gdHJ1ZTtcblxuICAgIHJldHVybiB0YWckJDFcbiAgfVxuXG4gIC8qKlxuICAgKiBVbm1vdW50IHRoZSB0YWcgaW5zdGFuY2VcbiAgICogQHBhcmFtIHsgQm9vbGVhbiB9IG11c3RLZWVwUm9vdCAtIGlmIGl0J3MgdHJ1ZSB0aGUgcm9vdCBub2RlIHdpbGwgbm90IGJlIHJlbW92ZWRcbiAgICogQHJldHVybnMgeyBUYWcgfSB0aGUgY3VycmVudCB0YWcgaW5zdGFuY2VcbiAgICovXG4gIGZ1bmN0aW9uIHRhZ1VubW91bnQodGFnLCBtdXN0S2VlcFJvb3QsIGV4cHJlc3Npb25zKSB7XG4gICAgdmFyIF9fID0gdGFnLl9fO1xuICAgIHZhciByb290ID0gX18ucm9vdDtcbiAgICB2YXIgdGFnSW5kZXggPSBfX1RBR1NfQ0FDSEUuaW5kZXhPZih0YWcpO1xuICAgIHZhciBwID0gcm9vdC5wYXJlbnROb2RlO1xuXG4gICAgaWYgKCFfXy5za2lwQW5vbnltb3VzKSB7IHRhZy50cmlnZ2VyKCdiZWZvcmUtdW5tb3VudCcpOyB9XG5cbiAgICAvLyBjbGVhciBhbGwgYXR0cmlidXRlcyBjb21pbmcgZnJvbSB0aGUgbW91bnRlZCB0YWdcbiAgICB3YWxrQXR0cmlidXRlcyhfXy5pbXBsLmF0dHJzLCBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgaWYgKHN0YXJ0c1dpdGgobmFtZSwgQVRUUlNfUFJFRklYKSlcbiAgICAgICAgeyBuYW1lID0gbmFtZS5zbGljZShBVFRSU19QUkVGSVgubGVuZ3RoKTsgfVxuXG4gICAgICByZW1vdmVBdHRyaWJ1dGUocm9vdCwgbmFtZSk7XG4gICAgfSk7XG5cbiAgICAvLyByZW1vdmUgYWxsIHRoZSBldmVudCBsaXN0ZW5lcnNcbiAgICB0YWcuX18ubGlzdGVuZXJzLmZvckVhY2goZnVuY3Rpb24gKGRvbSkge1xuICAgICAgT2JqZWN0LmtleXMoZG9tW1JJT1RfRVZFTlRTX0tFWV0pLmZvckVhY2goZnVuY3Rpb24gKGV2ZW50TmFtZSkge1xuICAgICAgICBkb20ucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudE5hbWUsIGRvbVtSSU9UX0VWRU5UU19LRVldW2V2ZW50TmFtZV0pO1xuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICAvLyByZW1vdmUgdGFnIGluc3RhbmNlIGZyb20gdGhlIGdsb2JhbCB0YWdzIGNhY2hlIGNvbGxlY3Rpb25cbiAgICBpZiAodGFnSW5kZXggIT09IC0xKSB7IF9fVEFHU19DQUNIRS5zcGxpY2UodGFnSW5kZXgsIDEpOyB9XG5cbiAgICAvLyBjbGVhbiB1cCB0aGUgcGFyZW50IHRhZ3Mgb2JqZWN0XG4gICAgaWYgKF9fLnBhcmVudCAmJiAhX18uaXNBbm9ueW1vdXMpIHtcbiAgICAgIHZhciBwdGFnID0gZ2V0SW1tZWRpYXRlQ3VzdG9tUGFyZW50KF9fLnBhcmVudCk7XG5cbiAgICAgIGlmIChfXy5pc1ZpcnR1YWwpIHtcbiAgICAgICAgT2JqZWN0XG4gICAgICAgICAgLmtleXModGFnLnRhZ3MpXG4gICAgICAgICAgLmZvckVhY2goZnVuY3Rpb24gKHRhZ05hbWUpIHsgcmV0dXJuIGFycmF5aXNoUmVtb3ZlKHB0YWcudGFncywgdGFnTmFtZSwgdGFnLnRhZ3NbdGFnTmFtZV0pOyB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGFycmF5aXNoUmVtb3ZlKHB0YWcudGFncywgX18udGFnTmFtZSwgdGFnKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyB1bm1vdW50IGFsbCB0aGUgdmlydHVhbCBkaXJlY3RpdmVzXG4gICAgaWYgKHRhZy5fXy52aXJ0cykge1xuICAgICAgZWFjaCh0YWcuX18udmlydHMsIGZ1bmN0aW9uICh2KSB7XG4gICAgICAgIGlmICh2LnBhcmVudE5vZGUpIHsgdi5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHYpOyB9XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvLyBhbGxvdyBleHByZXNzaW9ucyB0byB1bm1vdW50IHRoZW1zZWx2ZXNcbiAgICB1bm1vdW50QWxsKGV4cHJlc3Npb25zKTtcbiAgICBlYWNoKF9fLmluc3RBdHRycywgZnVuY3Rpb24gKGEpIHsgcmV0dXJuIGEuZXhwciAmJiBhLmV4cHIudW5tb3VudCAmJiBhLmV4cHIudW5tb3VudCgpOyB9KTtcblxuICAgIC8vIGNsZWFyIHRoZSB0YWcgaHRtbCBpZiBpdCdzIG5lY2Vzc2FyeVxuICAgIGlmIChtdXN0S2VlcFJvb3QpIHsgc2V0SW5uZXJIVE1MKHJvb3QsICcnKTsgfVxuICAgIC8vIG90aGVyd2lzZSBkZXRhY2ggdGhlIHJvb3QgdGFnIGZyb20gdGhlIERPTVxuICAgIGVsc2UgaWYgKHApIHsgcC5yZW1vdmVDaGlsZChyb290KTsgfVxuXG4gICAgLy8gY3VzdG9tIGludGVybmFsIHVubW91bnQgZnVuY3Rpb24gdG8gYXZvaWQgcmVseWluZyBvbiB0aGUgb2JzZXJ2YWJsZVxuICAgIGlmIChfXy5vblVubW91bnQpIHsgX18ub25Vbm1vdW50KCk7IH1cblxuICAgIC8vIHdlaXJkIGZpeCBmb3IgYSB3ZWlyZCBlZGdlIGNhc2UgIzI0MDkgYW5kICMyNDM2XG4gICAgLy8gc29tZSB1c2VycyBtaWdodCB1c2UgeW91ciBzb2Z0d2FyZSBub3QgYXMgeW91J3ZlIGV4cGVjdGVkXG4gICAgLy8gc28gSSBuZWVkIHRvIGFkZCB0aGVzZSBkaXJ0eSBoYWNrcyB0byBtaXRpZ2F0ZSB1bmV4cGVjdGVkIGlzc3Vlc1xuICAgIGlmICghdGFnLmlzTW91bnRlZCkgeyBzZXRNb3VudFN0YXRlLmNhbGwodGFnLCB0cnVlKTsgfVxuXG4gICAgc2V0TW91bnRTdGF0ZS5jYWxsKHRhZywgZmFsc2UpO1xuXG4gICAgZGVsZXRlIHJvb3QuX3RhZztcblxuICAgIHJldHVybiB0YWdcbiAgfVxuXG4gIC8qKlxuICAgKiBUYWcgY3JlYXRpb24gZmFjdG9yeSBmdW5jdGlvblxuICAgKiBAY29uc3RydWN0b3JcbiAgICogQHBhcmFtIHsgT2JqZWN0IH0gaW1wbCAtIGl0IGNvbnRhaW5zIHRoZSB0YWcgdGVtcGxhdGUsIGFuZCBsb2dpY1xuICAgKiBAcGFyYW0geyBPYmplY3QgfSBjb25mIC0gdGFnIG9wdGlvbnNcbiAgICogQHBhcmFtIHsgU3RyaW5nIH0gaW5uZXJIVE1MIC0gaHRtbCB0aGF0IGV2ZW50dWFsbHkgd2UgbmVlZCB0byBpbmplY3QgaW4gdGhlIHRhZ1xuICAgKi9cbiAgZnVuY3Rpb24gY3JlYXRlVGFnKGltcGwsIGNvbmYsIGlubmVySFRNTCkge1xuICAgIGlmICggaW1wbCA9PT0gdm9pZCAwICkgaW1wbCA9IHt9O1xuICAgIGlmICggY29uZiA9PT0gdm9pZCAwICkgY29uZiA9IHt9O1xuXG4gICAgdmFyIHRhZyA9IGNvbmYuY29udGV4dCB8fCB7fTtcbiAgICB2YXIgb3B0cyA9IGNvbmYub3B0cyB8fCB7fTtcbiAgICB2YXIgcGFyZW50ID0gY29uZi5wYXJlbnQ7XG4gICAgdmFyIGlzTG9vcCA9IGNvbmYuaXNMb29wO1xuICAgIHZhciBpc0Fub255bW91cyA9ICEhY29uZi5pc0Fub255bW91cztcbiAgICB2YXIgc2tpcEFub255bW91cyA9IHNldHRpbmdzLnNraXBBbm9ueW1vdXNUYWdzICYmIGlzQW5vbnltb3VzO1xuICAgIHZhciBpdGVtID0gY29uZi5pdGVtO1xuICAgIC8vIGF2YWlsYWJsZSBvbmx5IGZvciB0aGUgbG9vcGVkIG5vZGVzXG4gICAgdmFyIGluZGV4ID0gY29uZi5pbmRleDtcbiAgICAvLyBBbGwgYXR0cmlidXRlcyBvbiB0aGUgVGFnIHdoZW4gaXQncyBmaXJzdCBwYXJzZWRcbiAgICB2YXIgaW5zdEF0dHJzID0gW107XG4gICAgLy8gZXhwcmVzc2lvbnMgb24gdGhpcyB0eXBlIG9mIFRhZ1xuICAgIHZhciBpbXBsQXR0cnMgPSBbXTtcbiAgICB2YXIgdG1wbCA9IGltcGwudG1wbDtcbiAgICB2YXIgZXhwcmVzc2lvbnMgPSBbXTtcbiAgICB2YXIgcm9vdCA9IGNvbmYucm9vdDtcbiAgICB2YXIgdGFnTmFtZSA9IGNvbmYudGFnTmFtZSB8fCBnZXROYW1lKHJvb3QpO1xuICAgIHZhciBpc1ZpcnR1YWwgPSB0YWdOYW1lID09PSAndmlydHVhbCc7XG4gICAgdmFyIGlzSW5saW5lID0gIWlzVmlydHVhbCAmJiAhdG1wbDtcbiAgICB2YXIgZG9tO1xuXG4gICAgaWYgKGlzSW5saW5lIHx8IGlzTG9vcCAmJiBpc0Fub255bW91cykge1xuICAgICAgZG9tID0gcm9vdDtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKCFpc1ZpcnR1YWwpIHsgcm9vdC5pbm5lckhUTUwgPSAnJzsgfVxuICAgICAgZG9tID0gbWtkb20odG1wbCwgaW5uZXJIVE1MLCBpc1N2Zyhyb290KSk7XG4gICAgfVxuXG4gICAgLy8gbWFrZSB0aGlzIHRhZyBvYnNlcnZhYmxlXG4gICAgaWYgKCFza2lwQW5vbnltb3VzKSB7IG9ic2VydmFibGUodGFnKTsgfVxuXG4gICAgLy8gb25seSBjYWxsIHVubW91bnQgaWYgd2UgaGF2ZSBhIHZhbGlkIF9fVEFHX0lNUEwgKGhhcyBuYW1lIHByb3BlcnR5KVxuICAgIGlmIChpbXBsLm5hbWUgJiYgcm9vdC5fdGFnKSB7IHJvb3QuX3RhZy51bm1vdW50KHRydWUpOyB9XG5cbiAgICBkZWZpbmUodGFnLCAnX18nLCB7XG4gICAgICBpbXBsOiBpbXBsLFxuICAgICAgcm9vdDogcm9vdCxcbiAgICAgIHNraXBBbm9ueW1vdXM6IHNraXBBbm9ueW1vdXMsXG4gICAgICBpbXBsQXR0cnM6IGltcGxBdHRycyxcbiAgICAgIGlzQW5vbnltb3VzOiBpc0Fub255bW91cyxcbiAgICAgIGluc3RBdHRyczogaW5zdEF0dHJzLFxuICAgICAgaW5uZXJIVE1MOiBpbm5lckhUTUwsXG4gICAgICB0YWdOYW1lOiB0YWdOYW1lLFxuICAgICAgaW5kZXg6IGluZGV4LFxuICAgICAgaXNMb29wOiBpc0xvb3AsXG4gICAgICBpc0lubGluZTogaXNJbmxpbmUsXG4gICAgICBpdGVtOiBpdGVtLFxuICAgICAgcGFyZW50OiBwYXJlbnQsXG4gICAgICAvLyB0YWdzIGhhdmluZyBldmVudCBsaXN0ZW5lcnNcbiAgICAgIC8vIGl0IHdvdWxkIGJlIGJldHRlciB0byB1c2Ugd2VhayBtYXBzIGhlcmUgYnV0IHdlIGNhbiBub3QgaW50cm9kdWNlIGJyZWFraW5nIGNoYW5nZXMgbm93XG4gICAgICBsaXN0ZW5lcnM6IFtdLFxuICAgICAgLy8gdGhlc2UgdmFycyB3aWxsIGJlIG5lZWRlZCBvbmx5IGZvciB0aGUgdmlydHVhbCB0YWdzXG4gICAgICB2aXJ0czogW10sXG4gICAgICB3YXNDcmVhdGVkOiBmYWxzZSxcbiAgICAgIHRhaWw6IG51bGwsXG4gICAgICBoZWFkOiBudWxsXG4gICAgfSk7XG5cbiAgICAvLyB0YWcgcHJvdGVjdGVkIHByb3BlcnRpZXNcbiAgICByZXR1cm4gW1xuICAgICAgWydpc01vdW50ZWQnLCBmYWxzZV0sXG4gICAgICAvLyBjcmVhdGUgYSB1bmlxdWUgaWQgdG8gdGhpcyB0YWdcbiAgICAgIC8vIGl0IGNvdWxkIGJlIGhhbmR5IHRvIHVzZSBpdCBhbHNvIHRvIGltcHJvdmUgdGhlIHZpcnR1YWwgZG9tIHJlbmRlcmluZyBzcGVlZFxuICAgICAgWydfcmlvdF9pZCcsIHVpZCgpXSxcbiAgICAgIFsncm9vdCcsIHJvb3RdLFxuICAgICAgWydvcHRzJywgb3B0cywgeyB3cml0YWJsZTogdHJ1ZSwgZW51bWVyYWJsZTogdHJ1ZSB9XSxcbiAgICAgIFsncGFyZW50JywgcGFyZW50IHx8IG51bGxdLFxuICAgICAgLy8gcHJvdGVjdCB0aGUgXCJ0YWdzXCIgYW5kIFwicmVmc1wiIHByb3BlcnR5IGZyb20gYmVpbmcgb3ZlcnJpZGRlblxuICAgICAgWyd0YWdzJywge31dLFxuICAgICAgWydyZWZzJywge31dLFxuICAgICAgWyd1cGRhdGUnLCBmdW5jdGlvbiAoZGF0YSkgeyByZXR1cm4gY29tcG9uZW50VXBkYXRlKHRhZywgZGF0YSwgZXhwcmVzc2lvbnMpOyB9XSxcbiAgICAgIFsnbWl4aW4nLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBtaXhpbnMgPSBbXSwgbGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICAgICAgd2hpbGUgKCBsZW4tLSApIG1peGluc1sgbGVuIF0gPSBhcmd1bWVudHNbIGxlbiBdO1xuXG4gICAgICAgIHJldHVybiBjb21wb25lbnRNaXhpbi5hcHBseSh2b2lkIDAsIFsgdGFnIF0uY29uY2F0KCBtaXhpbnMgKSk7XG4gICAgfV0sXG4gICAgICBbJ21vdW50JywgZnVuY3Rpb24gKCkgeyByZXR1cm4gY29tcG9uZW50TW91bnQodGFnLCBkb20sIGV4cHJlc3Npb25zLCBvcHRzKTsgfV0sXG4gICAgICBbJ3VubW91bnQnLCBmdW5jdGlvbiAobXVzdEtlZXBSb290KSB7IHJldHVybiB0YWdVbm1vdW50KHRhZywgbXVzdEtlZXBSb290LCBleHByZXNzaW9ucyk7IH1dXG4gICAgXS5yZWR1Y2UoZnVuY3Rpb24gKGFjYywgcmVmKSB7XG4gICAgICB2YXIga2V5ID0gcmVmWzBdO1xuICAgICAgdmFyIHZhbHVlID0gcmVmWzFdO1xuICAgICAgdmFyIG9wdHMgPSByZWZbMl07XG5cbiAgICAgIGRlZmluZSh0YWcsIGtleSwgdmFsdWUsIG9wdHMpO1xuICAgICAgcmV0dXJuIGFjY1xuICAgIH0sIGV4dGVuZCh0YWcsIGl0ZW0pKVxuICB9XG5cbiAgLyoqXG4gICAqIE1vdW50IGEgdGFnIGNyZWF0aW5nIG5ldyBUYWcgaW5zdGFuY2VcbiAgICogQHBhcmFtICAgeyBPYmplY3QgfSByb290IC0gZG9tIG5vZGUgd2hlcmUgdGhlIHRhZyB3aWxsIGJlIG1vdW50ZWRcbiAgICogQHBhcmFtICAgeyBTdHJpbmcgfSB0YWdOYW1lIC0gbmFtZSBvZiB0aGUgcmlvdCB0YWcgd2Ugd2FudCB0byBtb3VudFxuICAgKiBAcGFyYW0gICB7IE9iamVjdCB9IG9wdHMgLSBvcHRpb25zIHRvIHBhc3MgdG8gdGhlIFRhZyBpbnN0YW5jZVxuICAgKiBAcGFyYW0gICB7IE9iamVjdCB9IGN0eCAtIG9wdGlvbmFsIGNvbnRleHQgdGhhdCB3aWxsIGJlIHVzZWQgdG8gZXh0ZW5kIGFuIGV4aXN0aW5nIGNsYXNzICggdXNlZCBpbiByaW90LlRhZyApXG4gICAqIEByZXR1cm5zIHsgVGFnIH0gYSBuZXcgVGFnIGluc3RhbmNlXG4gICAqL1xuICBmdW5jdGlvbiBtb3VudCQxKHJvb3QsIHRhZ05hbWUsIG9wdHMsIGN0eCkge1xuICAgIHZhciBpbXBsID0gX19UQUdfSU1QTFt0YWdOYW1lXTtcbiAgICB2YXIgaW1wbENsYXNzID0gX19UQUdfSU1QTFt0YWdOYW1lXS5jbGFzcztcbiAgICB2YXIgY29udGV4dCA9IGN0eCB8fCAoaW1wbENsYXNzID8gY3JlYXRlKGltcGxDbGFzcy5wcm90b3R5cGUpIDoge30pO1xuICAgIC8vIGNhY2hlIHRoZSBpbm5lciBIVE1MIHRvIGZpeCAjODU1XG4gICAgdmFyIGlubmVySFRNTCA9IHJvb3QuX2lubmVySFRNTCA9IHJvb3QuX2lubmVySFRNTCB8fCByb290LmlubmVySFRNTDtcbiAgICB2YXIgY29uZiA9IGV4dGVuZCh7IHJvb3Q6IHJvb3QsIG9wdHM6IG9wdHMsIGNvbnRleHQ6IGNvbnRleHQgfSwgeyBwYXJlbnQ6IG9wdHMgPyBvcHRzLnBhcmVudCA6IG51bGwgfSk7XG4gICAgdmFyIHRhZztcblxuICAgIGlmIChpbXBsICYmIHJvb3QpIHsgdGFnID0gY3JlYXRlVGFnKGltcGwsIGNvbmYsIGlubmVySFRNTCk7IH1cblxuICAgIGlmICh0YWcgJiYgdGFnLm1vdW50KSB7XG4gICAgICB0YWcubW91bnQodHJ1ZSk7XG4gICAgICAvLyBhZGQgdGhpcyB0YWcgdG8gdGhlIHZpcnR1YWxEb20gdmFyaWFibGVcbiAgICAgIGlmICghY29udGFpbnMoX19UQUdTX0NBQ0hFLCB0YWcpKSB7IF9fVEFHU19DQUNIRS5wdXNoKHRhZyk7IH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGFnXG4gIH1cblxuXG5cbiAgdmFyIHRhZ3MgPSAvKiNfX1BVUkVfXyovT2JqZWN0LmZyZWV6ZSh7XG4gICAgYXJyYXlpc2hBZGQ6IGFycmF5aXNoQWRkLFxuICAgIGdldFRhZ05hbWU6IGdldE5hbWUsXG4gICAgaW5oZXJpdFBhcmVudFByb3BzOiBpbmhlcml0UGFyZW50UHJvcHMsXG4gICAgbW91bnRUbzogbW91bnQkMSxcbiAgICBzZWxlY3RUYWdzOiBxdWVyeSxcbiAgICBhcnJheWlzaFJlbW92ZTogYXJyYXlpc2hSZW1vdmUsXG4gICAgZ2V0VGFnOiBnZXQsXG4gICAgaW5pdENoaWxkVGFnOiBpbml0Q2hpbGQsXG4gICAgbW92ZUNoaWxkVGFnOiBtb3ZlQ2hpbGQsXG4gICAgbWFrZVJlcGxhY2VWaXJ0dWFsOiBtYWtlUmVwbGFjZVZpcnR1YWwsXG4gICAgZ2V0SW1tZWRpYXRlQ3VzdG9tUGFyZW50VGFnOiBnZXRJbW1lZGlhdGVDdXN0b21QYXJlbnQsXG4gICAgbWFrZVZpcnR1YWw6IG1ha2VWaXJ0dWFsLFxuICAgIG1vdmVWaXJ0dWFsOiBtb3ZlVmlydHVhbCxcbiAgICB1bm1vdW50QWxsOiB1bm1vdW50QWxsLFxuICAgIGNyZWF0ZUlmRGlyZWN0aXZlOiBjcmVhdGVJZkRpcmVjdGl2ZSxcbiAgICBjcmVhdGVSZWZEaXJlY3RpdmU6IGNyZWF0ZVJlZkRpcmVjdGl2ZVxuICB9KTtcblxuICAvKipcbiAgICogUmlvdCBwdWJsaWMgYXBpXG4gICAqL1xuICB2YXIgc2V0dGluZ3MkMSA9IHNldHRpbmdzO1xuICB2YXIgdXRpbCA9IHtcbiAgICB0bXBsOiB0bXBsLFxuICAgIGJyYWNrZXRzOiBicmFja2V0cyxcbiAgICBzdHlsZU1hbmFnZXI6IHN0eWxlTWFuYWdlcixcbiAgICB2ZG9tOiBfX1RBR1NfQ0FDSEUsXG4gICAgc3R5bGVOb2RlOiBzdHlsZU1hbmFnZXIuc3R5bGVOb2RlLFxuICAgIC8vIGV4cG9ydCB0aGUgcmlvdCBpbnRlcm5hbCB1dGlscyBhcyB3ZWxsXG4gICAgZG9tOiBkb20sXG4gICAgY2hlY2s6IGNoZWNrLFxuICAgIG1pc2M6IG1pc2MsXG4gICAgdGFnczogdGFnc1xuICB9O1xuXG4gIC8vIGV4cG9ydCB0aGUgY29yZSBwcm9wcy9tZXRob2RzXG4gIHZhciBUYWckMSA9IFRhZztcbiAgdmFyIHRhZyQxID0gdGFnO1xuICB2YXIgdGFnMiQxID0gdGFnMjtcbiAgdmFyIG1vdW50JDIgPSBtb3VudDtcbiAgdmFyIG1peGluJDEgPSBtaXhpbjtcbiAgdmFyIHVwZGF0ZSQyID0gdXBkYXRlJDE7XG4gIHZhciB1bnJlZ2lzdGVyJDEgPSB1bnJlZ2lzdGVyO1xuICB2YXIgdmVyc2lvbiQxID0gdmVyc2lvbjtcbiAgdmFyIG9ic2VydmFibGUkMSA9IG9ic2VydmFibGU7XG5cbiAgdmFyIHJpb3QkMSA9IGV4dGVuZCh7fSwgY29yZSwge1xuICAgIG9ic2VydmFibGU6IG9ic2VydmFibGUsXG4gICAgc2V0dGluZ3M6IHNldHRpbmdzJDEsXG4gICAgdXRpbDogdXRpbCxcbiAgfSlcblxuICBleHBvcnRzLnNldHRpbmdzID0gc2V0dGluZ3MkMTtcbiAgZXhwb3J0cy51dGlsID0gdXRpbDtcbiAgZXhwb3J0cy5UYWcgPSBUYWckMTtcbiAgZXhwb3J0cy50YWcgPSB0YWckMTtcbiAgZXhwb3J0cy50YWcyID0gdGFnMiQxO1xuICBleHBvcnRzLm1vdW50ID0gbW91bnQkMjtcbiAgZXhwb3J0cy5taXhpbiA9IG1peGluJDE7XG4gIGV4cG9ydHMudXBkYXRlID0gdXBkYXRlJDI7XG4gIGV4cG9ydHMudW5yZWdpc3RlciA9IHVucmVnaXN0ZXIkMTtcbiAgZXhwb3J0cy52ZXJzaW9uID0gdmVyc2lvbiQxO1xuICBleHBvcnRzLm9ic2VydmFibGUgPSBvYnNlcnZhYmxlJDE7XG4gIGV4cG9ydHMuZGVmYXVsdCA9IHJpb3QkMTtcblxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG59KSkpO1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/riot/riot.js\n")},"./src/index.js":
/*!**********************!*\
  !*** ./src/index.js ***!
  \**********************/
/*! no static exports found */function(module,exports,__webpack_require__){"use strict";eval("\n\nvar _riot = __webpack_require__(/*! riot */ \"./node_modules/riot/riot.js\");\n\nvar _riot2 = _interopRequireDefault(_riot);\n\n__webpack_require__(/*! ./pages/course/index */ \"./src/pages/course/index.js\");\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\ndocument.addEventListener('DOMContentLoaded', function () {\n    _riot2.default.mount('*');\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvaW5kZXguanM/YjYzNSJdLCJuYW1lcyI6WyJkb2N1bWVudCIsImFkZEV2ZW50TGlzdGVuZXIiLCJyaW90IiwibW91bnQiXSwibWFwcGluZ3MiOiI7O0FBQUE7Ozs7QUFDQTs7OztBQUVBQSxTQUFTQyxnQkFBVCxDQUEwQixrQkFBMUIsRUFBOEMsWUFBTTtBQUNoREMsbUJBQUtDLEtBQUwsQ0FBVyxHQUFYO0FBQ0gsQ0FGRCIsImZpbGUiOiIuL3NyYy9pbmRleC5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCByaW90IGZyb20ncmlvdCdcbmltcG9ydCAnLi9wYWdlcy9jb3Vyc2UvaW5kZXgnXG5cbmRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ0RPTUNvbnRlbnRMb2FkZWQnLCAoKSA9PiB7XG4gICAgcmlvdC5tb3VudCgnKicpXG59KSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/index.js\n")},"./src/pages/course/course.tag":
/*!*************************************!*\
  !*** ./src/pages/course/course.tag ***!
  \*************************************/
/*! no static exports found */function(module,exports,__webpack_require__){eval("\n    var riot = __webpack_require__(/*! riot */ \"./node_modules/riot/riot.js\")\n    riot.tag2('coursepage', '<div>观察者模式(目标 - 观察者)</div> <div>目标数: {courseSum} / 订阅者数: {observerSum}</div> <courselist courselist=\"{courseList}\"></courseList> <studentslist studentslist=\"{studentsList}\"></studentsList>', '', '', function(opts) {\n\n\n        this.on('before-mount', () => {\n            console.log(this);\n        this.courses = [new Subject('html'), new Subject('css'), new Subject('javascript')];\n        let student1 = new Observer('lucy').subscribe(this.courses[0]);\n        let student2 = new Observer('john').subscribe(this.courses[1]);\n        let student3 = new Observer('jack').subscribe(this.courses[2]);\n        this.students = [student1, student2, student3];\n\n        this.courseSum = this.courses.length;\n        this.studentSum = this.students.length;\n        this.courseList = this.courses;\n        this.studentsList = this.students;\n        })\n});\n    \n  if (true) {\n    module.hot.accept()\n    if (module.hot.data) {\n      riot.reload('coursepage')\n    }\n  }\n  //# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvcGFnZXMvY291cnNlL2NvdXJzZS50YWc/YWVhMSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFFSTtDQVNJO0NBQ0k7QUFZUjtBQVZJO0NBQ0E7Q0FDQTtDQUNBO0NBRUE7Q0FDQTtDQUtSO0NBSFE7QUFDQSIsImZpbGUiOiIuL3NyYy9wYWdlcy9jb3Vyc2UvY291cnNlLnRhZy5qcyIsInNvdXJjZXNDb250ZW50IjpbIjxjb3Vyc2VQYWdlPlxuICAgIDxkaXY+6KeC5a+f6ICF5qih5byPKOebruaghyAtIOinguWvn+iAhSk8L2Rpdj5cbiAgICA8ZGl2Puebruagh+aVsDoge2NvdXJzZVN1bX0gLyDorqLpmIXogIXmlbA6IHtvYnNlcnZlclN1bX08L2Rpdj5cblxuICAgIDxjb3Vyc2VMaXN0IGNvdXJzZUxpc3Q9XCJ7IGNvdXJzZUxpc3QgfVwiPjwvY291cnNlTGlzdD5cbiAgICA8c3R1ZGVudHNMaXN0IHN0dWRlbnRzTGlzdD1cInsgc3R1ZGVudHNMaXN0IH1cIj48L3N0dWRlbnRzTGlzdD5cblxuICAgIDxzY3JpcHQ+XG4gICAgICAgIC8vaW1wb3J0IENvdXJzZSBmcm9tICcuL3NjcmlwdCdcbiAgICAgICAgLy9uZXcgQ291cnNlKHRoaXMpXG5cbiAgICAgICAgdGhpcy5vbignYmVmb3JlLW1vdW50JywgKCkgPT4ge1xuICAgICAgICAgICAgY29uc29sZS5sb2codGhpcyk7XG4gICAgICAgIHRoaXMuY291cnNlcyA9IFtuZXcgU3ViamVjdCgnaHRtbCcpLCBuZXcgU3ViamVjdCgnY3NzJyksIG5ldyBTdWJqZWN0KCdqYXZhc2NyaXB0JyldO1xuICAgICAgICBsZXQgc3R1ZGVudDEgPSBuZXcgT2JzZXJ2ZXIoJ2x1Y3knKS5zdWJzY3JpYmUodGhpcy5jb3Vyc2VzWzBdKTtcbiAgICAgICAgbGV0IHN0dWRlbnQyID0gbmV3IE9ic2VydmVyKCdqb2huJykuc3Vic2NyaWJlKHRoaXMuY291cnNlc1sxXSk7XG4gICAgICAgIGxldCBzdHVkZW50MyA9IG5ldyBPYnNlcnZlcignamFjaycpLnN1YnNjcmliZSh0aGlzLmNvdXJzZXNbMl0pO1xuICAgICAgICB0aGlzLnN0dWRlbnRzID0gW3N0dWRlbnQxLCBzdHVkZW50Miwgc3R1ZGVudDNdO1xuXG4gICAgICAgIHRoaXMuY291cnNlU3VtID0gdGhpcy5jb3Vyc2VzLmxlbmd0aDtcbiAgICAgICAgdGhpcy5zdHVkZW50U3VtID0gdGhpcy5zdHVkZW50cy5sZW5ndGg7XG4gICAgICAgIHRoaXMuY291cnNlTGlzdCA9IHRoaXMuY291cnNlcztcbiAgICAgICAgdGhpcy5zdHVkZW50c0xpc3QgPSB0aGlzLnN0dWRlbnRzO1xuICAgICAgICB9KVxuICAgIDwvc2NyaXB0PlxuPC9jb3Vyc2VQYWdlPiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/pages/course/course.tag\n")},"./src/pages/course/index.js":
/*!***********************************!*\
  !*** ./src/pages/course/index.js ***!
  \***********************************/
/*! no static exports found */function(module,exports,__webpack_require__){"use strict";eval('\n\n__webpack_require__(/*! ./course.tag */ "./src/pages/course/course.tag");//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvcGFnZXMvY291cnNlL2luZGV4LmpzPzdjMDIiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7QUFBQSIsImZpbGUiOiIuL3NyYy9wYWdlcy9jb3Vyc2UvaW5kZXguanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgJy4vY291cnNlLnRhZyciXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/pages/course/index.js\n')}});